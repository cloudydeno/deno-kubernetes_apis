// Autogenerated Schema file for StorageV1alpha1
import * as c from "../../common.ts";

import * as CoreV1 from "../core@v1/structs.ts";
import * as MetaV1 from "../meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.

For example this can express things like: - StorageClass "standard" has "1234 GiB" available in "topology.kubernetes.io/zone=us-east1" - StorageClass "localssd" has "10 GiB" available in "kubernetes.io/hostname=knode-abc123"

The following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero

The producer of these objects can decide which approach is more suitable.

They are consumed by the kube-scheduler if the CSIStorageCapacity beta feature gate is enabled there and a CSI driver opts into capacity-aware scheduling with CSIDriver.StorageCapacity. */
export interface CSIStorageCapacity {
  apiVersion?: "storage.k8s.io/v1alpha1";
  kind?: "CSIStorageCapacity";
  capacity?: c.Quantity | null;
  maximumVolumeSize?: c.Quantity | null;
  metadata?: MetaV1.ObjectMeta | null;
  nodeTopology?: MetaV1.LabelSelector | null;
  storageClassName: string;
}
export function toCSIStorageCapacity(input: c.JSONValue): CSIStorageCapacity & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "storage.k8s.io/v1alpha1", "CSIStorageCapacity"),
    capacity: c.readOpt(obj["capacity"], c.toQuantity),
    maximumVolumeSize: c.readOpt(obj["maximumVolumeSize"], c.toQuantity),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    nodeTopology: c.readOpt(obj["nodeTopology"], MetaV1.toLabelSelector),
    storageClassName: c.checkStr(obj["storageClassName"]),
  }}
export function fromCSIStorageCapacity(input: CSIStorageCapacity): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "storage.k8s.io/v1alpha1", "CSIStorageCapacity"),
    ...input,
    capacity: input.capacity != null ? c.fromQuantity(input.capacity) : undefined,
    maximumVolumeSize: input.maximumVolumeSize != null ? c.fromQuantity(input.maximumVolumeSize) : undefined,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    nodeTopology: input.nodeTopology != null ? MetaV1.fromLabelSelector(input.nodeTopology) : undefined,
  }}

/** CSIStorageCapacityList is a collection of CSIStorageCapacity objects. */
export interface CSIStorageCapacityList extends ListOf<CSIStorageCapacity> {
  apiVersion?: "storage.k8s.io/v1alpha1";
  kind?: "CSIStorageCapacityList";
};
export function toCSIStorageCapacityList(input: c.JSONValue): CSIStorageCapacityList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "storage.k8s.io/v1alpha1", "CSIStorageCapacityList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toCSIStorageCapacity),
  }}

/** VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.

VolumeAttachment objects are non-namespaced. */
export interface VolumeAttachment {
  apiVersion?: "storage.k8s.io/v1alpha1";
  kind?: "VolumeAttachment";
  metadata?: MetaV1.ObjectMeta | null;
  spec: VolumeAttachmentSpec;
  status?: VolumeAttachmentStatus | null;
}
export function toVolumeAttachment(input: c.JSONValue): VolumeAttachment & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "storage.k8s.io/v1alpha1", "VolumeAttachment"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toVolumeAttachmentSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toVolumeAttachmentStatus),
  }}
export function fromVolumeAttachment(input: VolumeAttachment): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "storage.k8s.io/v1alpha1", "VolumeAttachment"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromVolumeAttachmentSpec(input.spec) : undefined,
    status: input.status != null ? fromVolumeAttachmentStatus(input.status) : undefined,
  }}

/** VolumeAttachmentSpec is the specification of a VolumeAttachment request. */
export interface VolumeAttachmentSpec {
  attacher: string;
  nodeName: string;
  source: VolumeAttachmentSource;
}
export function toVolumeAttachmentSpec(input: c.JSONValue): VolumeAttachmentSpec {
  const obj = c.checkObj(input);
  return {
    attacher: c.checkStr(obj["attacher"]),
    nodeName: c.checkStr(obj["nodeName"]),
    source: toVolumeAttachmentSource(obj["source"]),
  }}
export function fromVolumeAttachmentSpec(input: VolumeAttachmentSpec): c.JSONValue {
  return {
    ...input,
    source: input.source != null ? fromVolumeAttachmentSource(input.source) : undefined,
  }}

/** VolumeAttachmentSource represents a volume that should be attached. Right now only PersistenVolumes can be attached via external attacher, in future we may allow also inline volumes in pods. Exactly one member can be set. */
export interface VolumeAttachmentSource {
  inlineVolumeSpec?: CoreV1.PersistentVolumeSpec | null;
  persistentVolumeName?: string | null;
}
export function toVolumeAttachmentSource(input: c.JSONValue): VolumeAttachmentSource {
  const obj = c.checkObj(input);
  return {
    inlineVolumeSpec: c.readOpt(obj["inlineVolumeSpec"], CoreV1.toPersistentVolumeSpec),
    persistentVolumeName: c.readOpt(obj["persistentVolumeName"], c.checkStr),
  }}
export function fromVolumeAttachmentSource(input: VolumeAttachmentSource): c.JSONValue {
  return {
    ...input,
    inlineVolumeSpec: input.inlineVolumeSpec != null ? CoreV1.fromPersistentVolumeSpec(input.inlineVolumeSpec) : undefined,
  }}

/** VolumeAttachmentStatus is the status of a VolumeAttachment request. */
export interface VolumeAttachmentStatus {
  attachError?: VolumeError | null;
  attached: boolean;
  attachmentMetadata?: Record<string,string> | null;
  detachError?: VolumeError | null;
}
export function toVolumeAttachmentStatus(input: c.JSONValue): VolumeAttachmentStatus {
  const obj = c.checkObj(input);
  return {
    attachError: c.readOpt(obj["attachError"], toVolumeError),
    attached: c.checkBool(obj["attached"]),
    attachmentMetadata: c.readOpt(obj["attachmentMetadata"], x => c.readMap(x, c.checkStr)),
    detachError: c.readOpt(obj["detachError"], toVolumeError),
  }}
export function fromVolumeAttachmentStatus(input: VolumeAttachmentStatus): c.JSONValue {
  return {
    ...input,
    attachError: input.attachError != null ? fromVolumeError(input.attachError) : undefined,
    detachError: input.detachError != null ? fromVolumeError(input.detachError) : undefined,
  }}

/** VolumeError captures an error encountered during a volume operation. */
export interface VolumeError {
  message?: string | null;
  time?: c.Time | null;
}
export function toVolumeError(input: c.JSONValue): VolumeError {
  const obj = c.checkObj(input);
  return {
    message: c.readOpt(obj["message"], c.checkStr),
    time: c.readOpt(obj["time"], c.toTime),
  }}
export function fromVolumeError(input: VolumeError): c.JSONValue {
  return {
    ...input,
    time: input.time != null ? c.fromTime(input.time) : undefined,
  }}

/** VolumeAttachmentList is a collection of VolumeAttachment objects. */
export interface VolumeAttachmentList extends ListOf<VolumeAttachment> {
  apiVersion?: "storage.k8s.io/v1alpha1";
  kind?: "VolumeAttachmentList";
};
export function toVolumeAttachmentList(input: c.JSONValue): VolumeAttachmentList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "storage.k8s.io/v1alpha1", "VolumeAttachmentList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toVolumeAttachment),
  }}
