// Autogenerated Schema file for MetaV1
import * as c from "../../common.ts";

/** APIGroup contains the name, the supported versions, and the preferred version of a group. */
export interface APIGroup {
  apiVersion?: "v1";
  kind?: "APIGroup";
  name: string;
  preferredVersion?: GroupVersionForDiscovery | null;
  serverAddressByClientCIDRs?: Array<ServerAddressByClientCIDR> | null;
  versions: Array<GroupVersionForDiscovery>;
}
export function toAPIGroup(input: c.JSONValue): APIGroup & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "APIGroup"),
    name: c.checkStr(obj["name"]),
    preferredVersion: c.readOpt(obj["preferredVersion"], toGroupVersionForDiscovery),
    serverAddressByClientCIDRs: c.readOpt(obj["serverAddressByClientCIDRs"], x => c.readList(x, toServerAddressByClientCIDR)),
    versions: c.readList(obj["versions"], toGroupVersionForDiscovery),
  }}
export function fromAPIGroup(input: APIGroup): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "APIGroup"),
    ...input,
    preferredVersion: input.preferredVersion != null ? fromGroupVersionForDiscovery(input.preferredVersion) : undefined,
    serverAddressByClientCIDRs: input.serverAddressByClientCIDRs?.map(fromServerAddressByClientCIDR),
    versions: input.versions?.map(fromGroupVersionForDiscovery),
  }}

/** GroupVersion contains the "group/version" and "version" string of a version. It is made a struct to keep extensibility. */
export interface GroupVersionForDiscovery {
  groupVersion: string;
  version: string;
}
export function toGroupVersionForDiscovery(input: c.JSONValue): GroupVersionForDiscovery {
  const obj = c.checkObj(input);
  return {
    groupVersion: c.checkStr(obj["groupVersion"]),
    version: c.checkStr(obj["version"]),
  }}
export function fromGroupVersionForDiscovery(input: GroupVersionForDiscovery): c.JSONValue {
  return {
    ...input,
  }}

/** ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match. */
export interface ServerAddressByClientCIDR {
  clientCIDR: string;
  serverAddress: string;
}
export function toServerAddressByClientCIDR(input: c.JSONValue): ServerAddressByClientCIDR {
  const obj = c.checkObj(input);
  return {
    clientCIDR: c.checkStr(obj["clientCIDR"]),
    serverAddress: c.checkStr(obj["serverAddress"]),
  }}
export function fromServerAddressByClientCIDR(input: ServerAddressByClientCIDR): c.JSONValue {
  return {
    ...input,
  }}

/** APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis. */
export interface APIGroupList {
  apiVersion?: "v1";
  kind?: "APIGroupList";
  groups: Array<APIGroup>;
};
export function toAPIGroupList(input: c.JSONValue): APIGroupList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "APIGroupList"),
    groups: c.readList(obj["groups"], toAPIGroup),
  }}
export function fromAPIGroupList(input: APIGroupList): c.JSONValue {
  return {
    ...input,
    groups: input.groups?.map(fromAPIGroup),
  }}

/** APIResource specifies the name of a resource and whether it is namespaced. */
export interface APIResource {
  categories?: Array<string> | null;
  group?: string | null;
  kind: string;
  name: string;
  namespaced: boolean;
  shortNames?: Array<string> | null;
  singularName: string;
  storageVersionHash?: string | null;
  verbs: Array<string>;
  version?: string | null;
}
export function toAPIResource(input: c.JSONValue): APIResource {
  const obj = c.checkObj(input);
  return {
    categories: c.readOpt(obj["categories"], x => c.readList(x, c.checkStr)),
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
    namespaced: c.checkBool(obj["namespaced"]),
    shortNames: c.readOpt(obj["shortNames"], x => c.readList(x, c.checkStr)),
    singularName: c.checkStr(obj["singularName"]),
    storageVersionHash: c.readOpt(obj["storageVersionHash"], c.checkStr),
    verbs: c.readList(obj["verbs"], c.checkStr),
    version: c.readOpt(obj["version"], c.checkStr),
  }}
export function fromAPIResource(input: APIResource): c.JSONValue {
  return {
    ...input,
  }}

/** APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced. */
export interface APIResourceList {
  apiVersion?: "v1";
  kind?: "APIResourceList";
  groupVersion: string;
  resources: Array<APIResource>;
};
export function toAPIResourceList(input: c.JSONValue): APIResourceList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "APIResourceList"),
    groupVersion: c.checkStr(obj["groupVersion"]),
    resources: c.readList(obj["resources"], toAPIResource),
  }}
export function fromAPIResourceList(input: APIResourceList): c.JSONValue {
  return {
    ...input,
    resources: input.resources?.map(fromAPIResource),
  }}

/** APIVersions lists the versions that are available, to allow clients to discover the API at /api, which is the root path of the legacy v1 API. */
export interface APIVersions {
  apiVersion?: string | null;
  kind?: string | null;
  serverAddressByClientCIDRs: Array<ServerAddressByClientCIDR>;
  versions: Array<string>;
}
export function toAPIVersions(input: c.JSONValue): APIVersions {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    serverAddressByClientCIDRs: c.readList(obj["serverAddressByClientCIDRs"], toServerAddressByClientCIDR),
    versions: c.readList(obj["versions"], c.checkStr),
  }}
export function fromAPIVersions(input: APIVersions): c.JSONValue {
  return {
    ...input,
    serverAddressByClientCIDRs: input.serverAddressByClientCIDRs?.map(fromServerAddressByClientCIDR),
  }}

/** Condition contains details for one aspect of the current state of this API Resource. */
export interface Condition {
  lastTransitionTime: c.Time;
  message: string;
  observedGeneration?: number | null;
  reason: string;
  status: string;
  type: string;
}
export function toCondition(input: c.JSONValue): Condition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.toTime(obj["lastTransitionTime"]),
    message: c.checkStr(obj["message"]),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    reason: c.checkStr(obj["reason"]),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromCondition(input: Condition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** DeleteOptions may be provided when deleting an API object. */
export interface DeleteOptions {
  apiVersion?: string | null;
  dryRun?: Array<string> | null;
  gracePeriodSeconds?: number | null;
  kind?: string | null;
  orphanDependents?: boolean | null;
  preconditions?: Preconditions | null;
  propagationPolicy?: string | null;
}
export function toDeleteOptions(input: c.JSONValue): DeleteOptions {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    dryRun: c.readOpt(obj["dryRun"], x => c.readList(x, c.checkStr)),
    gracePeriodSeconds: c.readOpt(obj["gracePeriodSeconds"], c.checkNum),
    kind: c.readOpt(obj["kind"], c.checkStr),
    orphanDependents: c.readOpt(obj["orphanDependents"], c.checkBool),
    preconditions: c.readOpt(obj["preconditions"], toPreconditions),
    propagationPolicy: c.readOpt(obj["propagationPolicy"], c.checkStr),
  }}
export function fromDeleteOptions(input: DeleteOptions): c.JSONValue {
  return {
    ...input,
    preconditions: input.preconditions != null ? fromPreconditions(input.preconditions) : undefined,
  }}

/** Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out. */
export interface Preconditions {
  resourceVersion?: string | null;
  uid?: string | null;
}
export function toPreconditions(input: c.JSONValue): Preconditions {
  const obj = c.checkObj(input);
  return {
    resourceVersion: c.readOpt(obj["resourceVersion"], c.checkStr),
    uid: c.readOpt(obj["uid"], c.checkStr),
  }}
export function fromPreconditions(input: Preconditions): c.JSONValue {
  return {
    ...input,
  }}

/** FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.

Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.

The exact format is defined in sigs.k8s.io/structured-merge-diff */
export type FieldsV1 = c.JSONValue;

/** A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects. */
export interface LabelSelector {
  matchExpressions?: Array<LabelSelectorRequirement> | null;
  matchLabels?: Record<string,string> | null;
}
export function toLabelSelector(input: c.JSONValue): LabelSelector {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toLabelSelectorRequirement)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function fromLabelSelector(input: LabelSelector): c.JSONValue {
  return {
    ...input,
    matchExpressions: input.matchExpressions?.map(fromLabelSelectorRequirement),
  }}

/** A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. */
export interface LabelSelectorRequirement {
  key: string;
  operator: string;
  values?: Array<string> | null;
}
export function toLabelSelectorRequirement(input: c.JSONValue): LabelSelectorRequirement {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function fromLabelSelectorRequirement(input: LabelSelectorRequirement): c.JSONValue {
  return {
    ...input,
  }}

/** ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}. */
export interface ListMeta {
  continue?: string | null;
  remainingItemCount?: number | null;
  resourceVersion?: string | null;
  selfLink?: string | null;
}
export function toListMeta(input: c.JSONValue): ListMeta {
  const obj = c.checkObj(input);
  return {
    continue: c.readOpt(obj["continue"], c.checkStr),
    remainingItemCount: c.readOpt(obj["remainingItemCount"], c.checkNum),
    resourceVersion: c.readOpt(obj["resourceVersion"], c.checkStr),
    selfLink: c.readOpt(obj["selfLink"], c.checkStr),
  }}
export function fromListMeta(input: ListMeta): c.JSONValue {
  return {
    ...input,
  }}

/** ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to. */
export interface ManagedFieldsEntry {
  apiVersion?: string | null;
  fieldsType?: string | null;
  fieldsV1?: FieldsV1 | null;
  manager?: string | null;
  operation?: string | null;
  subresource?: string | null;
  time?: c.Time | null;
}
export function toManagedFieldsEntry(input: c.JSONValue): ManagedFieldsEntry {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    fieldsType: c.readOpt(obj["fieldsType"], c.checkStr),
    fieldsV1: c.readOpt(obj["fieldsV1"], c.identity),
    manager: c.readOpt(obj["manager"], c.checkStr),
    operation: c.readOpt(obj["operation"], c.checkStr),
    subresource: c.readOpt(obj["subresource"], c.checkStr),
    time: c.readOpt(obj["time"], c.toTime),
  }}
export function fromManagedFieldsEntry(input: ManagedFieldsEntry): c.JSONValue {
  return {
    ...input,
    time: input.time != null ? c.fromTime(input.time) : undefined,
  }}

/** ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create. */
export interface ObjectMeta {
  annotations?: Record<string,string> | null;
  creationTimestamp?: c.Time | null;
  deletionGracePeriodSeconds?: number | null;
  deletionTimestamp?: c.Time | null;
  finalizers?: Array<string> | null;
  generateName?: string | null;
  generation?: number | null;
  labels?: Record<string,string> | null;
  managedFields?: Array<ManagedFieldsEntry> | null;
  name?: string | null;
  namespace?: string | null;
  ownerReferences?: Array<OwnerReference> | null;
  resourceVersion?: string | null;
  selfLink?: string | null;
  uid?: string | null;
}
export function toObjectMeta(input: c.JSONValue): ObjectMeta {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    creationTimestamp: c.readOpt(obj["creationTimestamp"], c.toTime),
    deletionGracePeriodSeconds: c.readOpt(obj["deletionGracePeriodSeconds"], c.checkNum),
    deletionTimestamp: c.readOpt(obj["deletionTimestamp"], c.toTime),
    finalizers: c.readOpt(obj["finalizers"], x => c.readList(x, c.checkStr)),
    generateName: c.readOpt(obj["generateName"], c.checkStr),
    generation: c.readOpt(obj["generation"], c.checkNum),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
    managedFields: c.readOpt(obj["managedFields"], x => c.readList(x, toManagedFieldsEntry)),
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    ownerReferences: c.readOpt(obj["ownerReferences"], x => c.readList(x, toOwnerReference)),
    resourceVersion: c.readOpt(obj["resourceVersion"], c.checkStr),
    selfLink: c.readOpt(obj["selfLink"], c.checkStr),
    uid: c.readOpt(obj["uid"], c.checkStr),
  }}
export function fromObjectMeta(input: ObjectMeta): c.JSONValue {
  return {
    ...input,
    creationTimestamp: input.creationTimestamp != null ? c.fromTime(input.creationTimestamp) : undefined,
    deletionTimestamp: input.deletionTimestamp != null ? c.fromTime(input.deletionTimestamp) : undefined,
    managedFields: input.managedFields?.map(fromManagedFieldsEntry),
    ownerReferences: input.ownerReferences?.map(fromOwnerReference),
  }}

/** OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. */
export interface OwnerReference {
  apiVersion: string;
  blockOwnerDeletion?: boolean | null;
  controller?: boolean | null;
  kind: string;
  name: string;
  uid: string;
}
export function toOwnerReference(input: c.JSONValue): OwnerReference {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.checkStr(obj["apiVersion"]),
    blockOwnerDeletion: c.readOpt(obj["blockOwnerDeletion"], c.checkBool),
    controller: c.readOpt(obj["controller"], c.checkBool),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
    uid: c.checkStr(obj["uid"]),
  }}
export function fromOwnerReference(input: OwnerReference): c.JSONValue {
  return {
    ...input,
  }}

/** Patch is provided to give a concrete name and type to the Kubernetes PATCH request body. */
export interface Patch {
}
export function toPatch(input: c.JSONValue): Patch {
  const obj = c.checkObj(input);
  return {
  }}
export function fromPatch(input: Patch): c.JSONValue {
  return {
    ...input,
  }}

/** Status is a return value for calls that don't return other objects. */
export interface Status {
  apiVersion?: "v1";
  kind?: "Status";
  code?: number | null;
  details?: StatusDetails | null;
  message?: string | null;
  metadata?: ListMeta | null;
  reason?: string | null;
  status?: string | null;
}
export function toStatus(input: c.JSONValue): Status & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "Status"),
    code: c.readOpt(obj["code"], c.checkNum),
    details: c.readOpt(obj["details"], toStatusDetails),
    message: c.readOpt(obj["message"], c.checkStr),
    metadata: c.readOpt(obj["metadata"], toListMeta),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.readOpt(obj["status"], c.checkStr),
  }}
export function fromStatus(input: Status): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "Status"),
    ...input,
    details: input.details != null ? fromStatusDetails(input.details) : undefined,
    metadata: input.metadata != null ? fromListMeta(input.metadata) : undefined,
  }}

/** StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined. */
export interface StatusDetails {
  causes?: Array<StatusCause> | null;
  group?: string | null;
  kind?: string | null;
  name?: string | null;
  retryAfterSeconds?: number | null;
  uid?: string | null;
}
export function toStatusDetails(input: c.JSONValue): StatusDetails {
  const obj = c.checkObj(input);
  return {
    causes: c.readOpt(obj["causes"], x => c.readList(x, toStatusCause)),
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.readOpt(obj["name"], c.checkStr),
    retryAfterSeconds: c.readOpt(obj["retryAfterSeconds"], c.checkNum),
    uid: c.readOpt(obj["uid"], c.checkStr),
  }}
export function fromStatusDetails(input: StatusDetails): c.JSONValue {
  return {
    ...input,
    causes: input.causes?.map(fromStatusCause),
  }}

/** StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered. */
export interface StatusCause {
  field?: string | null;
  message?: string | null;
  reason?: string | null;
}
export function toStatusCause(input: c.JSONValue): StatusCause {
  const obj = c.checkObj(input);
  return {
    field: c.readOpt(obj["field"], c.checkStr),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
  }}
export function fromStatusCause(input: StatusCause): c.JSONValue {
  return {
    ...input,
  }}

/** Event represents a single event to a watched resource. */
export interface WatchEvent {
  object: c.JSONValue;
  type: string;
}
export function toWatchEvent(input: c.JSONValue): WatchEvent {
  const obj = c.checkObj(input);
  return {
    object: c.identity(obj["object"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromWatchEvent(input: WatchEvent): c.JSONValue {
  return {
    ...input,
  }}
