// Autogenerated Schema file for CoreV1
import * as c from "../../common.ts";

import * as MetaV1 from "../meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** Represents a Persistent Disk resource in AWS.

An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling. */
export interface AWSElasticBlockStoreVolumeSource {
  fsType?: string | null;
  partition?: number | null;
  readOnly?: boolean | null;
  volumeID: string;
}
export function toAWSElasticBlockStoreVolumeSource(input: c.JSONValue): AWSElasticBlockStoreVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    partition: c.readOpt(obj["partition"], c.checkNum),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    volumeID: c.checkStr(obj["volumeID"]),
  }}
export function fromAWSElasticBlockStoreVolumeSource(input: AWSElasticBlockStoreVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** Affinity is a group of affinity scheduling rules. */
export interface Affinity {
  nodeAffinity?: NodeAffinity | null;
  podAffinity?: PodAffinity | null;
  podAntiAffinity?: PodAntiAffinity | null;
}
export function toAffinity(input: c.JSONValue): Affinity {
  const obj = c.checkObj(input);
  return {
    nodeAffinity: c.readOpt(obj["nodeAffinity"], toNodeAffinity),
    podAffinity: c.readOpt(obj["podAffinity"], toPodAffinity),
    podAntiAffinity: c.readOpt(obj["podAntiAffinity"], toPodAntiAffinity),
  }}
export function fromAffinity(input: Affinity): c.JSONValue {
  return {
    ...input,
    nodeAffinity: input.nodeAffinity != null ? fromNodeAffinity(input.nodeAffinity) : undefined,
    podAffinity: input.podAffinity != null ? fromPodAffinity(input.podAffinity) : undefined,
    podAntiAffinity: input.podAntiAffinity != null ? fromPodAntiAffinity(input.podAntiAffinity) : undefined,
  }}

/** Node affinity is a group of node affinity scheduling rules. */
export interface NodeAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: Array<PreferredSchedulingTerm> | null;
  requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector | null;
}
export function toNodeAffinity(input: c.JSONValue): NodeAffinity {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toPreferredSchedulingTerm)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], toNodeSelector),
  }}
export function fromNodeAffinity(input: NodeAffinity): c.JSONValue {
  return {
    ...input,
    preferredDuringSchedulingIgnoredDuringExecution: input.preferredDuringSchedulingIgnoredDuringExecution?.map(fromPreferredSchedulingTerm),
    requiredDuringSchedulingIgnoredDuringExecution: input.requiredDuringSchedulingIgnoredDuringExecution != null ? fromNodeSelector(input.requiredDuringSchedulingIgnoredDuringExecution) : undefined,
  }}

/** An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op). */
export interface PreferredSchedulingTerm {
  preference: NodeSelectorTerm;
  weight: number;
}
export function toPreferredSchedulingTerm(input: c.JSONValue): PreferredSchedulingTerm {
  const obj = c.checkObj(input);
  return {
    preference: toNodeSelectorTerm(obj["preference"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function fromPreferredSchedulingTerm(input: PreferredSchedulingTerm): c.JSONValue {
  return {
    ...input,
    preference: input.preference != null ? fromNodeSelectorTerm(input.preference) : undefined,
  }}

/** A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm. */
export interface NodeSelectorTerm {
  matchExpressions?: Array<NodeSelectorRequirement> | null;
  matchFields?: Array<NodeSelectorRequirement> | null;
}
export function toNodeSelectorTerm(input: c.JSONValue): NodeSelectorTerm {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toNodeSelectorRequirement)),
    matchFields: c.readOpt(obj["matchFields"], x => c.readList(x, toNodeSelectorRequirement)),
  }}
export function fromNodeSelectorTerm(input: NodeSelectorTerm): c.JSONValue {
  return {
    ...input,
    matchExpressions: input.matchExpressions?.map(fromNodeSelectorRequirement),
    matchFields: input.matchFields?.map(fromNodeSelectorRequirement),
  }}

/** A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values. */
export interface NodeSelectorRequirement {
  key: string;
  operator: string;
  values?: Array<string> | null;
}
export function toNodeSelectorRequirement(input: c.JSONValue): NodeSelectorRequirement {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function fromNodeSelectorRequirement(input: NodeSelectorRequirement): c.JSONValue {
  return {
    ...input,
  }}

/** A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms. */
export interface NodeSelector {
  nodeSelectorTerms: Array<NodeSelectorTerm>;
}
export function toNodeSelector(input: c.JSONValue): NodeSelector {
  const obj = c.checkObj(input);
  return {
    nodeSelectorTerms: c.readList(obj["nodeSelectorTerms"], toNodeSelectorTerm),
  }}
export function fromNodeSelector(input: NodeSelector): c.JSONValue {
  return {
    ...input,
    nodeSelectorTerms: input.nodeSelectorTerms?.map(fromNodeSelectorTerm),
  }}

/** Pod affinity is a group of inter pod affinity scheduling rules. */
export interface PodAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: Array<WeightedPodAffinityTerm> | null;
  requiredDuringSchedulingIgnoredDuringExecution?: Array<PodAffinityTerm> | null;
}
export function toPodAffinity(input: c.JSONValue): PodAffinity {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toWeightedPodAffinityTerm)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toPodAffinityTerm)),
  }}
export function fromPodAffinity(input: PodAffinity): c.JSONValue {
  return {
    ...input,
    preferredDuringSchedulingIgnoredDuringExecution: input.preferredDuringSchedulingIgnoredDuringExecution?.map(fromWeightedPodAffinityTerm),
    requiredDuringSchedulingIgnoredDuringExecution: input.requiredDuringSchedulingIgnoredDuringExecution?.map(fromPodAffinityTerm),
  }}

/** The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s) */
export interface WeightedPodAffinityTerm {
  podAffinityTerm: PodAffinityTerm;
  weight: number;
}
export function toWeightedPodAffinityTerm(input: c.JSONValue): WeightedPodAffinityTerm {
  const obj = c.checkObj(input);
  return {
    podAffinityTerm: toPodAffinityTerm(obj["podAffinityTerm"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function fromWeightedPodAffinityTerm(input: WeightedPodAffinityTerm): c.JSONValue {
  return {
    ...input,
    podAffinityTerm: input.podAffinityTerm != null ? fromPodAffinityTerm(input.podAffinityTerm) : undefined,
  }}

/** Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running */
export interface PodAffinityTerm {
  labelSelector?: MetaV1.LabelSelector | null;
  namespaces?: Array<string> | null;
  topologyKey: string;
}
export function toPodAffinityTerm(input: c.JSONValue): PodAffinityTerm {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], MetaV1.toLabelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function fromPodAffinityTerm(input: PodAffinityTerm): c.JSONValue {
  return {
    ...input,
    labelSelector: input.labelSelector != null ? MetaV1.fromLabelSelector(input.labelSelector) : undefined,
  }}

/** Pod anti affinity is a group of inter pod anti affinity scheduling rules. */
export interface PodAntiAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: Array<WeightedPodAffinityTerm> | null;
  requiredDuringSchedulingIgnoredDuringExecution?: Array<PodAffinityTerm> | null;
}
export function toPodAntiAffinity(input: c.JSONValue): PodAntiAffinity {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toWeightedPodAffinityTerm)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toPodAffinityTerm)),
  }}
export function fromPodAntiAffinity(input: PodAntiAffinity): c.JSONValue {
  return {
    ...input,
    preferredDuringSchedulingIgnoredDuringExecution: input.preferredDuringSchedulingIgnoredDuringExecution?.map(fromWeightedPodAffinityTerm),
    requiredDuringSchedulingIgnoredDuringExecution: input.requiredDuringSchedulingIgnoredDuringExecution?.map(fromPodAffinityTerm),
  }}

/** AttachedVolume describes a volume attached to a node */
export interface AttachedVolume {
  devicePath: string;
  name: string;
}
export function toAttachedVolume(input: c.JSONValue): AttachedVolume {
  const obj = c.checkObj(input);
  return {
    devicePath: c.checkStr(obj["devicePath"]),
    name: c.checkStr(obj["name"]),
  }}
export function fromAttachedVolume(input: AttachedVolume): c.JSONValue {
  return {
    ...input,
  }}

/** AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. */
export interface AzureDiskVolumeSource {
  cachingMode?: string | null;
  diskName: string;
  diskURI: string;
  fsType?: string | null;
  kind?: string | null;
  readOnly?: boolean | null;
}
export function toAzureDiskVolumeSource(input: c.JSONValue): AzureDiskVolumeSource {
  const obj = c.checkObj(input);
  return {
    cachingMode: c.readOpt(obj["cachingMode"], c.checkStr),
    diskName: c.checkStr(obj["diskName"]),
    diskURI: c.checkStr(obj["diskURI"]),
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
  }}
export function fromAzureDiskVolumeSource(input: AzureDiskVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** AzureFile represents an Azure File Service mount on the host and bind mount to the pod. */
export interface AzureFilePersistentVolumeSource {
  readOnly?: boolean | null;
  secretName: string;
  secretNamespace?: string | null;
  shareName: string;
}
export function toAzureFilePersistentVolumeSource(input: c.JSONValue): AzureFilePersistentVolumeSource {
  const obj = c.checkObj(input);
  return {
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretName: c.checkStr(obj["secretName"]),
    secretNamespace: c.readOpt(obj["secretNamespace"], c.checkStr),
    shareName: c.checkStr(obj["shareName"]),
  }}
export function fromAzureFilePersistentVolumeSource(input: AzureFilePersistentVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** AzureFile represents an Azure File Service mount on the host and bind mount to the pod. */
export interface AzureFileVolumeSource {
  readOnly?: boolean | null;
  secretName: string;
  shareName: string;
}
export function toAzureFileVolumeSource(input: c.JSONValue): AzureFileVolumeSource {
  const obj = c.checkObj(input);
  return {
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretName: c.checkStr(obj["secretName"]),
    shareName: c.checkStr(obj["shareName"]),
  }}
export function fromAzureFileVolumeSource(input: AzureFileVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead. */
export interface Binding {
  apiVersion?: "v1";
  kind?: "Binding";
  metadata?: MetaV1.ObjectMeta | null;
  target: ObjectReference;
}
export function toBinding(input: c.JSONValue): Binding & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "Binding"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    target: toObjectReference(obj["target"]),
  }}
export function fromBinding(input: Binding): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "Binding"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    target: input.target != null ? fromObjectReference(input.target) : undefined,
  }}

/** ObjectReference contains enough information to let you inspect or modify the referred object. */
export interface ObjectReference {
  apiVersion?: string | null;
  fieldPath?: string | null;
  kind?: string | null;
  name?: string | null;
  namespace?: string | null;
  resourceVersion?: string | null;
  uid?: string | null;
}
export function toObjectReference(input: c.JSONValue): ObjectReference {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    fieldPath: c.readOpt(obj["fieldPath"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    resourceVersion: c.readOpt(obj["resourceVersion"], c.checkStr),
    uid: c.readOpt(obj["uid"], c.checkStr),
  }}
export function fromObjectReference(input: ObjectReference): c.JSONValue {
  return {
    ...input,
  }}

/** Represents storage that is managed by an external CSI volume driver (Beta feature) */
export interface CSIPersistentVolumeSource {
  controllerExpandSecretRef?: SecretReference | null;
  controllerPublishSecretRef?: SecretReference | null;
  driver: string;
  fsType?: string | null;
  nodePublishSecretRef?: SecretReference | null;
  nodeStageSecretRef?: SecretReference | null;
  readOnly?: boolean | null;
  volumeAttributes?: Record<string,string> | null;
  volumeHandle: string;
}
export function toCSIPersistentVolumeSource(input: c.JSONValue): CSIPersistentVolumeSource {
  const obj = c.checkObj(input);
  return {
    controllerExpandSecretRef: c.readOpt(obj["controllerExpandSecretRef"], toSecretReference),
    controllerPublishSecretRef: c.readOpt(obj["controllerPublishSecretRef"], toSecretReference),
    driver: c.checkStr(obj["driver"]),
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    nodePublishSecretRef: c.readOpt(obj["nodePublishSecretRef"], toSecretReference),
    nodeStageSecretRef: c.readOpt(obj["nodeStageSecretRef"], toSecretReference),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    volumeAttributes: c.readOpt(obj["volumeAttributes"], x => c.readMap(x, c.checkStr)),
    volumeHandle: c.checkStr(obj["volumeHandle"]),
  }}
export function fromCSIPersistentVolumeSource(input: CSIPersistentVolumeSource): c.JSONValue {
  return {
    ...input,
    controllerExpandSecretRef: input.controllerExpandSecretRef != null ? fromSecretReference(input.controllerExpandSecretRef) : undefined,
    controllerPublishSecretRef: input.controllerPublishSecretRef != null ? fromSecretReference(input.controllerPublishSecretRef) : undefined,
    nodePublishSecretRef: input.nodePublishSecretRef != null ? fromSecretReference(input.nodePublishSecretRef) : undefined,
    nodeStageSecretRef: input.nodeStageSecretRef != null ? fromSecretReference(input.nodeStageSecretRef) : undefined,
  }}

/** SecretReference represents a Secret Reference. It has enough information to retrieve secret in any namespace */
export interface SecretReference {
  name?: string | null;
  namespace?: string | null;
}
export function toSecretReference(input: c.JSONValue): SecretReference {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
  }}
export function fromSecretReference(input: SecretReference): c.JSONValue {
  return {
    ...input,
  }}

/** Represents a source location of a volume to mount, managed by an external CSI driver */
export interface CSIVolumeSource {
  driver: string;
  fsType?: string | null;
  nodePublishSecretRef?: LocalObjectReference | null;
  readOnly?: boolean | null;
  volumeAttributes?: Record<string,string> | null;
}
export function toCSIVolumeSource(input: c.JSONValue): CSIVolumeSource {
  const obj = c.checkObj(input);
  return {
    driver: c.checkStr(obj["driver"]),
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    nodePublishSecretRef: c.readOpt(obj["nodePublishSecretRef"], toLocalObjectReference),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    volumeAttributes: c.readOpt(obj["volumeAttributes"], x => c.readMap(x, c.checkStr)),
  }}
export function fromCSIVolumeSource(input: CSIVolumeSource): c.JSONValue {
  return {
    ...input,
    nodePublishSecretRef: input.nodePublishSecretRef != null ? fromLocalObjectReference(input.nodePublishSecretRef) : undefined,
  }}

/** LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace. */
export interface LocalObjectReference {
  name?: string | null;
}
export function toLocalObjectReference(input: c.JSONValue): LocalObjectReference {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
  }}
export function fromLocalObjectReference(input: LocalObjectReference): c.JSONValue {
  return {
    ...input,
  }}

/** Adds and removes POSIX capabilities from running containers. */
export interface Capabilities {
  add?: Array<string> | null;
  drop?: Array<string> | null;
}
export function toCapabilities(input: c.JSONValue): Capabilities {
  const obj = c.checkObj(input);
  return {
    add: c.readOpt(obj["add"], x => c.readList(x, c.checkStr)),
    drop: c.readOpt(obj["drop"], x => c.readList(x, c.checkStr)),
  }}
export function fromCapabilities(input: Capabilities): c.JSONValue {
  return {
    ...input,
  }}

/** Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling. */
export interface CephFSPersistentVolumeSource {
  monitors: Array<string>;
  path?: string | null;
  readOnly?: boolean | null;
  secretFile?: string | null;
  secretRef?: SecretReference | null;
  user?: string | null;
}
export function toCephFSPersistentVolumeSource(input: c.JSONValue): CephFSPersistentVolumeSource {
  const obj = c.checkObj(input);
  return {
    monitors: c.readList(obj["monitors"], c.checkStr),
    path: c.readOpt(obj["path"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretFile: c.readOpt(obj["secretFile"], c.checkStr),
    secretRef: c.readOpt(obj["secretRef"], toSecretReference),
    user: c.readOpt(obj["user"], c.checkStr),
  }}
export function fromCephFSPersistentVolumeSource(input: CephFSPersistentVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromSecretReference(input.secretRef) : undefined,
  }}

/** Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling. */
export interface CephFSVolumeSource {
  monitors: Array<string>;
  path?: string | null;
  readOnly?: boolean | null;
  secretFile?: string | null;
  secretRef?: LocalObjectReference | null;
  user?: string | null;
}
export function toCephFSVolumeSource(input: c.JSONValue): CephFSVolumeSource {
  const obj = c.checkObj(input);
  return {
    monitors: c.readList(obj["monitors"], c.checkStr),
    path: c.readOpt(obj["path"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretFile: c.readOpt(obj["secretFile"], c.checkStr),
    secretRef: c.readOpt(obj["secretRef"], toLocalObjectReference),
    user: c.readOpt(obj["user"], c.checkStr),
  }}
export function fromCephFSVolumeSource(input: CephFSVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromLocalObjectReference(input.secretRef) : undefined,
  }}

/** Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling. */
export interface CinderPersistentVolumeSource {
  fsType?: string | null;
  readOnly?: boolean | null;
  secretRef?: SecretReference | null;
  volumeID: string;
}
export function toCinderPersistentVolumeSource(input: c.JSONValue): CinderPersistentVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: c.readOpt(obj["secretRef"], toSecretReference),
    volumeID: c.checkStr(obj["volumeID"]),
  }}
export function fromCinderPersistentVolumeSource(input: CinderPersistentVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromSecretReference(input.secretRef) : undefined,
  }}

/** Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling. */
export interface CinderVolumeSource {
  fsType?: string | null;
  readOnly?: boolean | null;
  secretRef?: LocalObjectReference | null;
  volumeID: string;
}
export function toCinderVolumeSource(input: c.JSONValue): CinderVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: c.readOpt(obj["secretRef"], toLocalObjectReference),
    volumeID: c.checkStr(obj["volumeID"]),
  }}
export function fromCinderVolumeSource(input: CinderVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromLocalObjectReference(input.secretRef) : undefined,
  }}

/** ClientIPConfig represents the configurations of Client IP based session affinity. */
export interface ClientIPConfig {
  timeoutSeconds?: number | null;
}
export function toClientIPConfig(input: c.JSONValue): ClientIPConfig {
  const obj = c.checkObj(input);
  return {
    timeoutSeconds: c.readOpt(obj["timeoutSeconds"], c.checkNum),
  }}
export function fromClientIPConfig(input: ClientIPConfig): c.JSONValue {
  return {
    ...input,
  }}

/** Information about the condition of a component. */
export interface ComponentCondition {
  error?: string | null;
  message?: string | null;
  status: string;
  type: string;
}
export function toComponentCondition(input: c.JSONValue): ComponentCondition {
  const obj = c.checkObj(input);
  return {
    error: c.readOpt(obj["error"], c.checkStr),
    message: c.readOpt(obj["message"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromComponentCondition(input: ComponentCondition): c.JSONValue {
  return {
    ...input,
  }}

/** ComponentStatus (and ComponentStatusList) holds the cluster validation info. Deprecated: This API is deprecated in v1.19+ */
export interface ComponentStatus {
  apiVersion?: "v1";
  kind?: "ComponentStatus";
  conditions?: Array<ComponentCondition> | null;
  metadata?: MetaV1.ObjectMeta | null;
}
export function toComponentStatus(input: c.JSONValue): ComponentStatus & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "ComponentStatus"),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toComponentCondition)),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
  }}
export function fromComponentStatus(input: ComponentStatus): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "ComponentStatus"),
    ...input,
    conditions: input.conditions?.map(fromComponentCondition),
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
  }}

/** Status of all the conditions for the component as a list of ComponentStatus objects. Deprecated: This API is deprecated in v1.19+ */
export interface ComponentStatusList extends ListOf<ComponentStatus> {
  apiVersion?: "v1";
  kind?: "ComponentStatusList";
};
export function toComponentStatusList(input: c.JSONValue): ComponentStatusList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "ComponentStatusList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toComponentStatus),
  }}

/** ConfigMap holds configuration data for pods to consume. */
export interface ConfigMap {
  apiVersion?: "v1";
  kind?: "ConfigMap";
  binaryData?: Record<string,string> | null;
  data?: Record<string,string> | null;
  immutable?: boolean | null;
  metadata?: MetaV1.ObjectMeta | null;
}
export function toConfigMap(input: c.JSONValue): ConfigMap & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "ConfigMap"),
    binaryData: c.readOpt(obj["binaryData"], x => c.readMap(x, c.checkStr)),
    data: c.readOpt(obj["data"], x => c.readMap(x, c.checkStr)),
    immutable: c.readOpt(obj["immutable"], c.checkBool),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
  }}
export function fromConfigMap(input: ConfigMap): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "ConfigMap"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
  }}

/** ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.

The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables. */
export interface ConfigMapEnvSource {
  name?: string | null;
  optional?: boolean | null;
}
export function toConfigMapEnvSource(input: c.JSONValue): ConfigMapEnvSource {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    optional: c.readOpt(obj["optional"], c.checkBool),
  }}
export function fromConfigMapEnvSource(input: ConfigMapEnvSource): c.JSONValue {
  return {
    ...input,
  }}

/** Selects a key from a ConfigMap. */
export interface ConfigMapKeySelector {
  key: string;
  name?: string | null;
  optional?: boolean | null;
}
export function toConfigMapKeySelector(input: c.JSONValue): ConfigMapKeySelector {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    name: c.readOpt(obj["name"], c.checkStr),
    optional: c.readOpt(obj["optional"], c.checkBool),
  }}
export function fromConfigMapKeySelector(input: ConfigMapKeySelector): c.JSONValue {
  return {
    ...input,
  }}

/** ConfigMapList is a resource containing a list of ConfigMap objects. */
export interface ConfigMapList extends ListOf<ConfigMap> {
  apiVersion?: "v1";
  kind?: "ConfigMapList";
};
export function toConfigMapList(input: c.JSONValue): ConfigMapList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "ConfigMapList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toConfigMap),
  }}

/** ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node. */
export interface ConfigMapNodeConfigSource {
  kubeletConfigKey: string;
  name: string;
  namespace: string;
  resourceVersion?: string | null;
  uid?: string | null;
}
export function toConfigMapNodeConfigSource(input: c.JSONValue): ConfigMapNodeConfigSource {
  const obj = c.checkObj(input);
  return {
    kubeletConfigKey: c.checkStr(obj["kubeletConfigKey"]),
    name: c.checkStr(obj["name"]),
    namespace: c.checkStr(obj["namespace"]),
    resourceVersion: c.readOpt(obj["resourceVersion"], c.checkStr),
    uid: c.readOpt(obj["uid"], c.checkStr),
  }}
export function fromConfigMapNodeConfigSource(input: ConfigMapNodeConfigSource): c.JSONValue {
  return {
    ...input,
  }}

/** Adapts a ConfigMap into a projected volume.

The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode. */
export interface ConfigMapProjection {
  items?: Array<KeyToPath> | null;
  name?: string | null;
  optional?: boolean | null;
}
export function toConfigMapProjection(input: c.JSONValue): ConfigMapProjection {
  const obj = c.checkObj(input);
  return {
    items: c.readOpt(obj["items"], x => c.readList(x, toKeyToPath)),
    name: c.readOpt(obj["name"], c.checkStr),
    optional: c.readOpt(obj["optional"], c.checkBool),
  }}
export function fromConfigMapProjection(input: ConfigMapProjection): c.JSONValue {
  return {
    ...input,
    items: input.items?.map(fromKeyToPath),
  }}

/** Maps a string key to a path within a volume. */
export interface KeyToPath {
  key: string;
  mode?: number | null;
  path: string;
}
export function toKeyToPath(input: c.JSONValue): KeyToPath {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    mode: c.readOpt(obj["mode"], c.checkNum),
    path: c.checkStr(obj["path"]),
  }}
export function fromKeyToPath(input: KeyToPath): c.JSONValue {
  return {
    ...input,
  }}

/** Adapts a ConfigMap into a volume.

The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling. */
export interface ConfigMapVolumeSource {
  defaultMode?: number | null;
  items?: Array<KeyToPath> | null;
  name?: string | null;
  optional?: boolean | null;
}
export function toConfigMapVolumeSource(input: c.JSONValue): ConfigMapVolumeSource {
  const obj = c.checkObj(input);
  return {
    defaultMode: c.readOpt(obj["defaultMode"], c.checkNum),
    items: c.readOpt(obj["items"], x => c.readList(x, toKeyToPath)),
    name: c.readOpt(obj["name"], c.checkStr),
    optional: c.readOpt(obj["optional"], c.checkBool),
  }}
export function fromConfigMapVolumeSource(input: ConfigMapVolumeSource): c.JSONValue {
  return {
    ...input,
    items: input.items?.map(fromKeyToPath),
  }}

/** A single application container that you want to run within a pod. */
export interface Container {
  args?: Array<string> | null;
  command?: Array<string> | null;
  env?: Array<EnvVar> | null;
  envFrom?: Array<EnvFromSource> | null;
  image?: string | null;
  imagePullPolicy?: string | null;
  lifecycle?: Lifecycle | null;
  livenessProbe?: Probe | null;
  name: string;
  ports?: Array<ContainerPort> | null;
  readinessProbe?: Probe | null;
  resources?: ResourceRequirements | null;
  securityContext?: SecurityContext | null;
  startupProbe?: Probe | null;
  stdin?: boolean | null;
  stdinOnce?: boolean | null;
  terminationMessagePath?: string | null;
  terminationMessagePolicy?: string | null;
  tty?: boolean | null;
  volumeDevices?: Array<VolumeDevice> | null;
  volumeMounts?: Array<VolumeMount> | null;
  workingDir?: string | null;
}
export function toContainer(input: c.JSONValue): Container {
  const obj = c.checkObj(input);
  return {
    args: c.readOpt(obj["args"], x => c.readList(x, c.checkStr)),
    command: c.readOpt(obj["command"], x => c.readList(x, c.checkStr)),
    env: c.readOpt(obj["env"], x => c.readList(x, toEnvVar)),
    envFrom: c.readOpt(obj["envFrom"], x => c.readList(x, toEnvFromSource)),
    image: c.readOpt(obj["image"], c.checkStr),
    imagePullPolicy: c.readOpt(obj["imagePullPolicy"], c.checkStr),
    lifecycle: c.readOpt(obj["lifecycle"], toLifecycle),
    livenessProbe: c.readOpt(obj["livenessProbe"], toProbe),
    name: c.checkStr(obj["name"]),
    ports: c.readOpt(obj["ports"], x => c.readList(x, toContainerPort)),
    readinessProbe: c.readOpt(obj["readinessProbe"], toProbe),
    resources: c.readOpt(obj["resources"], toResourceRequirements),
    securityContext: c.readOpt(obj["securityContext"], toSecurityContext),
    startupProbe: c.readOpt(obj["startupProbe"], toProbe),
    stdin: c.readOpt(obj["stdin"], c.checkBool),
    stdinOnce: c.readOpt(obj["stdinOnce"], c.checkBool),
    terminationMessagePath: c.readOpt(obj["terminationMessagePath"], c.checkStr),
    terminationMessagePolicy: c.readOpt(obj["terminationMessagePolicy"], c.checkStr),
    tty: c.readOpt(obj["tty"], c.checkBool),
    volumeDevices: c.readOpt(obj["volumeDevices"], x => c.readList(x, toVolumeDevice)),
    volumeMounts: c.readOpt(obj["volumeMounts"], x => c.readList(x, toVolumeMount)),
    workingDir: c.readOpt(obj["workingDir"], c.checkStr),
  }}
export function fromContainer(input: Container): c.JSONValue {
  return {
    ...input,
    env: input.env?.map(fromEnvVar),
    envFrom: input.envFrom?.map(fromEnvFromSource),
    lifecycle: input.lifecycle != null ? fromLifecycle(input.lifecycle) : undefined,
    livenessProbe: input.livenessProbe != null ? fromProbe(input.livenessProbe) : undefined,
    ports: input.ports?.map(fromContainerPort),
    readinessProbe: input.readinessProbe != null ? fromProbe(input.readinessProbe) : undefined,
    resources: input.resources != null ? fromResourceRequirements(input.resources) : undefined,
    securityContext: input.securityContext != null ? fromSecurityContext(input.securityContext) : undefined,
    startupProbe: input.startupProbe != null ? fromProbe(input.startupProbe) : undefined,
    volumeDevices: input.volumeDevices?.map(fromVolumeDevice),
    volumeMounts: input.volumeMounts?.map(fromVolumeMount),
  }}

/** EnvVar represents an environment variable present in a Container. */
export interface EnvVar {
  name: string;
  value?: string | null;
  valueFrom?: EnvVarSource | null;
}
export function toEnvVar(input: c.JSONValue): EnvVar {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    value: c.readOpt(obj["value"], c.checkStr),
    valueFrom: c.readOpt(obj["valueFrom"], toEnvVarSource),
  }}
export function fromEnvVar(input: EnvVar): c.JSONValue {
  return {
    ...input,
    valueFrom: input.valueFrom != null ? fromEnvVarSource(input.valueFrom) : undefined,
  }}

/** EnvVarSource represents a source for the value of an EnvVar. */
export interface EnvVarSource {
  configMapKeyRef?: ConfigMapKeySelector | null;
  fieldRef?: ObjectFieldSelector | null;
  resourceFieldRef?: ResourceFieldSelector | null;
  secretKeyRef?: SecretKeySelector | null;
}
export function toEnvVarSource(input: c.JSONValue): EnvVarSource {
  const obj = c.checkObj(input);
  return {
    configMapKeyRef: c.readOpt(obj["configMapKeyRef"], toConfigMapKeySelector),
    fieldRef: c.readOpt(obj["fieldRef"], toObjectFieldSelector),
    resourceFieldRef: c.readOpt(obj["resourceFieldRef"], toResourceFieldSelector),
    secretKeyRef: c.readOpt(obj["secretKeyRef"], toSecretKeySelector),
  }}
export function fromEnvVarSource(input: EnvVarSource): c.JSONValue {
  return {
    ...input,
    configMapKeyRef: input.configMapKeyRef != null ? fromConfigMapKeySelector(input.configMapKeyRef) : undefined,
    fieldRef: input.fieldRef != null ? fromObjectFieldSelector(input.fieldRef) : undefined,
    resourceFieldRef: input.resourceFieldRef != null ? fromResourceFieldSelector(input.resourceFieldRef) : undefined,
    secretKeyRef: input.secretKeyRef != null ? fromSecretKeySelector(input.secretKeyRef) : undefined,
  }}

/** ObjectFieldSelector selects an APIVersioned field of an object. */
export interface ObjectFieldSelector {
  apiVersion?: string | null;
  fieldPath: string;
}
export function toObjectFieldSelector(input: c.JSONValue): ObjectFieldSelector {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    fieldPath: c.checkStr(obj["fieldPath"]),
  }}
export function fromObjectFieldSelector(input: ObjectFieldSelector): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceFieldSelector represents container resources (cpu, memory) and their output format */
export interface ResourceFieldSelector {
  containerName?: string | null;
  divisor?: c.Quantity | null;
  resource: string;
}
export function toResourceFieldSelector(input: c.JSONValue): ResourceFieldSelector {
  const obj = c.checkObj(input);
  return {
    containerName: c.readOpt(obj["containerName"], c.checkStr),
    divisor: c.readOpt(obj["divisor"], c.toQuantity),
    resource: c.checkStr(obj["resource"]),
  }}
export function fromResourceFieldSelector(input: ResourceFieldSelector): c.JSONValue {
  return {
    ...input,
    divisor: input.divisor != null ? c.fromQuantity(input.divisor) : undefined,
  }}

/** SecretKeySelector selects a key of a Secret. */
export interface SecretKeySelector {
  key: string;
  name?: string | null;
  optional?: boolean | null;
}
export function toSecretKeySelector(input: c.JSONValue): SecretKeySelector {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    name: c.readOpt(obj["name"], c.checkStr),
    optional: c.readOpt(obj["optional"], c.checkBool),
  }}
export function fromSecretKeySelector(input: SecretKeySelector): c.JSONValue {
  return {
    ...input,
  }}

/** EnvFromSource represents the source of a set of ConfigMaps */
export interface EnvFromSource {
  configMapRef?: ConfigMapEnvSource | null;
  prefix?: string | null;
  secretRef?: SecretEnvSource | null;
}
export function toEnvFromSource(input: c.JSONValue): EnvFromSource {
  const obj = c.checkObj(input);
  return {
    configMapRef: c.readOpt(obj["configMapRef"], toConfigMapEnvSource),
    prefix: c.readOpt(obj["prefix"], c.checkStr),
    secretRef: c.readOpt(obj["secretRef"], toSecretEnvSource),
  }}
export function fromEnvFromSource(input: EnvFromSource): c.JSONValue {
  return {
    ...input,
    configMapRef: input.configMapRef != null ? fromConfigMapEnvSource(input.configMapRef) : undefined,
    secretRef: input.secretRef != null ? fromSecretEnvSource(input.secretRef) : undefined,
  }}

/** SecretEnvSource selects a Secret to populate the environment variables with.

The contents of the target Secret's Data field will represent the key-value pairs as environment variables. */
export interface SecretEnvSource {
  name?: string | null;
  optional?: boolean | null;
}
export function toSecretEnvSource(input: c.JSONValue): SecretEnvSource {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    optional: c.readOpt(obj["optional"], c.checkBool),
  }}
export function fromSecretEnvSource(input: SecretEnvSource): c.JSONValue {
  return {
    ...input,
  }}

/** Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted. */
export interface Lifecycle {
  postStart?: Handler | null;
  preStop?: Handler | null;
}
export function toLifecycle(input: c.JSONValue): Lifecycle {
  const obj = c.checkObj(input);
  return {
    postStart: c.readOpt(obj["postStart"], toHandler),
    preStop: c.readOpt(obj["preStop"], toHandler),
  }}
export function fromLifecycle(input: Lifecycle): c.JSONValue {
  return {
    ...input,
    postStart: input.postStart != null ? fromHandler(input.postStart) : undefined,
    preStop: input.preStop != null ? fromHandler(input.preStop) : undefined,
  }}

/** Handler defines a specific action that should be taken */
export interface Handler {
  exec?: ExecAction | null;
  httpGet?: HTTPGetAction | null;
  tcpSocket?: TCPSocketAction | null;
}
export function toHandler(input: c.JSONValue): Handler {
  const obj = c.checkObj(input);
  return {
    exec: c.readOpt(obj["exec"], toExecAction),
    httpGet: c.readOpt(obj["httpGet"], toHTTPGetAction),
    tcpSocket: c.readOpt(obj["tcpSocket"], toTCPSocketAction),
  }}
export function fromHandler(input: Handler): c.JSONValue {
  return {
    ...input,
    exec: input.exec != null ? fromExecAction(input.exec) : undefined,
    httpGet: input.httpGet != null ? fromHTTPGetAction(input.httpGet) : undefined,
    tcpSocket: input.tcpSocket != null ? fromTCPSocketAction(input.tcpSocket) : undefined,
  }}

/** ExecAction describes a "run in container" action. */
export interface ExecAction {
  command?: Array<string> | null;
}
export function toExecAction(input: c.JSONValue): ExecAction {
  const obj = c.checkObj(input);
  return {
    command: c.readOpt(obj["command"], x => c.readList(x, c.checkStr)),
  }}
export function fromExecAction(input: ExecAction): c.JSONValue {
  return {
    ...input,
  }}

/** HTTPGetAction describes an action based on HTTP Get requests. */
export interface HTTPGetAction {
  host?: string | null;
  httpHeaders?: Array<HTTPHeader> | null;
  path?: string | null;
  port: c.IntOrString;
  scheme?: string | null;
}
export function toHTTPGetAction(input: c.JSONValue): HTTPGetAction {
  const obj = c.checkObj(input);
  return {
    host: c.readOpt(obj["host"], c.checkStr),
    httpHeaders: c.readOpt(obj["httpHeaders"], x => c.readList(x, toHTTPHeader)),
    path: c.readOpt(obj["path"], c.checkStr),
    port: c.toIntOrString(obj["port"]),
    scheme: c.readOpt(obj["scheme"], c.checkStr),
  }}
export function fromHTTPGetAction(input: HTTPGetAction): c.JSONValue {
  return {
    ...input,
    httpHeaders: input.httpHeaders?.map(fromHTTPHeader),
  }}

/** HTTPHeader describes a custom header to be used in HTTP probes */
export interface HTTPHeader {
  name: string;
  value: string;
}
export function toHTTPHeader(input: c.JSONValue): HTTPHeader {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    value: c.checkStr(obj["value"]),
  }}
export function fromHTTPHeader(input: HTTPHeader): c.JSONValue {
  return {
    ...input,
  }}

/** TCPSocketAction describes an action based on opening a socket */
export interface TCPSocketAction {
  host?: string | null;
  port: c.IntOrString;
}
export function toTCPSocketAction(input: c.JSONValue): TCPSocketAction {
  const obj = c.checkObj(input);
  return {
    host: c.readOpt(obj["host"], c.checkStr),
    port: c.toIntOrString(obj["port"]),
  }}
export function fromTCPSocketAction(input: TCPSocketAction): c.JSONValue {
  return {
    ...input,
  }}

/** Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. */
export interface Probe {
  exec?: ExecAction | null;
  failureThreshold?: number | null;
  httpGet?: HTTPGetAction | null;
  initialDelaySeconds?: number | null;
  periodSeconds?: number | null;
  successThreshold?: number | null;
  tcpSocket?: TCPSocketAction | null;
  timeoutSeconds?: number | null;
}
export function toProbe(input: c.JSONValue): Probe {
  const obj = c.checkObj(input);
  return {
    exec: c.readOpt(obj["exec"], toExecAction),
    failureThreshold: c.readOpt(obj["failureThreshold"], c.checkNum),
    httpGet: c.readOpt(obj["httpGet"], toHTTPGetAction),
    initialDelaySeconds: c.readOpt(obj["initialDelaySeconds"], c.checkNum),
    periodSeconds: c.readOpt(obj["periodSeconds"], c.checkNum),
    successThreshold: c.readOpt(obj["successThreshold"], c.checkNum),
    tcpSocket: c.readOpt(obj["tcpSocket"], toTCPSocketAction),
    timeoutSeconds: c.readOpt(obj["timeoutSeconds"], c.checkNum),
  }}
export function fromProbe(input: Probe): c.JSONValue {
  return {
    ...input,
    exec: input.exec != null ? fromExecAction(input.exec) : undefined,
    httpGet: input.httpGet != null ? fromHTTPGetAction(input.httpGet) : undefined,
    tcpSocket: input.tcpSocket != null ? fromTCPSocketAction(input.tcpSocket) : undefined,
  }}

/** ContainerPort represents a network port in a single container. */
export interface ContainerPort {
  containerPort: number;
  hostIP?: string | null;
  hostPort?: number | null;
  name?: string | null;
  protocol?: string | null;
}
export function toContainerPort(input: c.JSONValue): ContainerPort {
  const obj = c.checkObj(input);
  return {
    containerPort: c.checkNum(obj["containerPort"]),
    hostIP: c.readOpt(obj["hostIP"], c.checkStr),
    hostPort: c.readOpt(obj["hostPort"], c.checkNum),
    name: c.readOpt(obj["name"], c.checkStr),
    protocol: c.readOpt(obj["protocol"], c.checkStr),
  }}
export function fromContainerPort(input: ContainerPort): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceRequirements describes the compute resource requirements. */
export interface ResourceRequirements {
  limits?: Record<string,c.Quantity> | null;
  requests?: Record<string,c.Quantity> | null;
}
export function toResourceRequirements(input: c.JSONValue): ResourceRequirements {
  const obj = c.checkObj(input);
  return {
    limits: c.readOpt(obj["limits"], x => c.readMap(x, c.toQuantity)),
    requests: c.readOpt(obj["requests"], x => c.readMap(x, c.toQuantity)),
  }}
export function fromResourceRequirements(input: ResourceRequirements): c.JSONValue {
  return {
    ...input,
    limits: c.writeMap(input.limits, c.fromQuantity),
    requests: c.writeMap(input.requests, c.fromQuantity),
  }}

/** SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence. */
export interface SecurityContext {
  allowPrivilegeEscalation?: boolean | null;
  capabilities?: Capabilities | null;
  privileged?: boolean | null;
  procMount?: string | null;
  readOnlyRootFilesystem?: boolean | null;
  runAsGroup?: number | null;
  runAsNonRoot?: boolean | null;
  runAsUser?: number | null;
  seLinuxOptions?: SELinuxOptions | null;
  seccompProfile?: SeccompProfile | null;
  windowsOptions?: WindowsSecurityContextOptions | null;
}
export function toSecurityContext(input: c.JSONValue): SecurityContext {
  const obj = c.checkObj(input);
  return {
    allowPrivilegeEscalation: c.readOpt(obj["allowPrivilegeEscalation"], c.checkBool),
    capabilities: c.readOpt(obj["capabilities"], toCapabilities),
    privileged: c.readOpt(obj["privileged"], c.checkBool),
    procMount: c.readOpt(obj["procMount"], c.checkStr),
    readOnlyRootFilesystem: c.readOpt(obj["readOnlyRootFilesystem"], c.checkBool),
    runAsGroup: c.readOpt(obj["runAsGroup"], c.checkNum),
    runAsNonRoot: c.readOpt(obj["runAsNonRoot"], c.checkBool),
    runAsUser: c.readOpt(obj["runAsUser"], c.checkNum),
    seLinuxOptions: c.readOpt(obj["seLinuxOptions"], toSELinuxOptions),
    seccompProfile: c.readOpt(obj["seccompProfile"], toSeccompProfile),
    windowsOptions: c.readOpt(obj["windowsOptions"], toWindowsSecurityContextOptions),
  }}
export function fromSecurityContext(input: SecurityContext): c.JSONValue {
  return {
    ...input,
    capabilities: input.capabilities != null ? fromCapabilities(input.capabilities) : undefined,
    seLinuxOptions: input.seLinuxOptions != null ? fromSELinuxOptions(input.seLinuxOptions) : undefined,
    seccompProfile: input.seccompProfile != null ? fromSeccompProfile(input.seccompProfile) : undefined,
    windowsOptions: input.windowsOptions != null ? fromWindowsSecurityContextOptions(input.windowsOptions) : undefined,
  }}

/** SELinuxOptions are the labels to be applied to the container */
export interface SELinuxOptions {
  level?: string | null;
  role?: string | null;
  type?: string | null;
  user?: string | null;
}
export function toSELinuxOptions(input: c.JSONValue): SELinuxOptions {
  const obj = c.checkObj(input);
  return {
    level: c.readOpt(obj["level"], c.checkStr),
    role: c.readOpt(obj["role"], c.checkStr),
    type: c.readOpt(obj["type"], c.checkStr),
    user: c.readOpt(obj["user"], c.checkStr),
  }}
export function fromSELinuxOptions(input: SELinuxOptions): c.JSONValue {
  return {
    ...input,
  }}

/** SeccompProfile defines a pod/container's seccomp profile settings. Only one profile source may be set. */
export interface SeccompProfile {
  localhostProfile?: string | null;
  type: string;
}
export function toSeccompProfile(input: c.JSONValue): SeccompProfile {
  const obj = c.checkObj(input);
  return {
    localhostProfile: c.readOpt(obj["localhostProfile"], c.checkStr),
    type: c.checkStr(obj["type"]),
  }}
export function fromSeccompProfile(input: SeccompProfile): c.JSONValue {
  return {
    ...input,
  }}

/** WindowsSecurityContextOptions contain Windows-specific options and credentials. */
export interface WindowsSecurityContextOptions {
  gmsaCredentialSpec?: string | null;
  gmsaCredentialSpecName?: string | null;
  runAsUserName?: string | null;
}
export function toWindowsSecurityContextOptions(input: c.JSONValue): WindowsSecurityContextOptions {
  const obj = c.checkObj(input);
  return {
    gmsaCredentialSpec: c.readOpt(obj["gmsaCredentialSpec"], c.checkStr),
    gmsaCredentialSpecName: c.readOpt(obj["gmsaCredentialSpecName"], c.checkStr),
    runAsUserName: c.readOpt(obj["runAsUserName"], c.checkStr),
  }}
export function fromWindowsSecurityContextOptions(input: WindowsSecurityContextOptions): c.JSONValue {
  return {
    ...input,
  }}

/** volumeDevice describes a mapping of a raw block device within a container. */
export interface VolumeDevice {
  devicePath: string;
  name: string;
}
export function toVolumeDevice(input: c.JSONValue): VolumeDevice {
  const obj = c.checkObj(input);
  return {
    devicePath: c.checkStr(obj["devicePath"]),
    name: c.checkStr(obj["name"]),
  }}
export function fromVolumeDevice(input: VolumeDevice): c.JSONValue {
  return {
    ...input,
  }}

/** VolumeMount describes a mounting of a Volume within a container. */
export interface VolumeMount {
  mountPath: string;
  mountPropagation?: string | null;
  name: string;
  readOnly?: boolean | null;
  subPath?: string | null;
  subPathExpr?: string | null;
}
export function toVolumeMount(input: c.JSONValue): VolumeMount {
  const obj = c.checkObj(input);
  return {
    mountPath: c.checkStr(obj["mountPath"]),
    mountPropagation: c.readOpt(obj["mountPropagation"], c.checkStr),
    name: c.checkStr(obj["name"]),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    subPath: c.readOpt(obj["subPath"], c.checkStr),
    subPathExpr: c.readOpt(obj["subPathExpr"], c.checkStr),
  }}
export function fromVolumeMount(input: VolumeMount): c.JSONValue {
  return {
    ...input,
  }}

/** Describe a container image */
export interface ContainerImage {
  names: Array<string>;
  sizeBytes?: number | null;
}
export function toContainerImage(input: c.JSONValue): ContainerImage {
  const obj = c.checkObj(input);
  return {
    names: c.readList(obj["names"], c.checkStr),
    sizeBytes: c.readOpt(obj["sizeBytes"], c.checkNum),
  }}
export function fromContainerImage(input: ContainerImage): c.JSONValue {
  return {
    ...input,
  }}

/** ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting. */
export interface ContainerState {
  running?: ContainerStateRunning | null;
  terminated?: ContainerStateTerminated | null;
  waiting?: ContainerStateWaiting | null;
}
export function toContainerState(input: c.JSONValue): ContainerState {
  const obj = c.checkObj(input);
  return {
    running: c.readOpt(obj["running"], toContainerStateRunning),
    terminated: c.readOpt(obj["terminated"], toContainerStateTerminated),
    waiting: c.readOpt(obj["waiting"], toContainerStateWaiting),
  }}
export function fromContainerState(input: ContainerState): c.JSONValue {
  return {
    ...input,
    running: input.running != null ? fromContainerStateRunning(input.running) : undefined,
    terminated: input.terminated != null ? fromContainerStateTerminated(input.terminated) : undefined,
    waiting: input.waiting != null ? fromContainerStateWaiting(input.waiting) : undefined,
  }}

/** ContainerStateRunning is a running state of a container. */
export interface ContainerStateRunning {
  startedAt?: c.Time | null;
}
export function toContainerStateRunning(input: c.JSONValue): ContainerStateRunning {
  const obj = c.checkObj(input);
  return {
    startedAt: c.readOpt(obj["startedAt"], c.toTime),
  }}
export function fromContainerStateRunning(input: ContainerStateRunning): c.JSONValue {
  return {
    ...input,
    startedAt: input.startedAt != null ? c.fromTime(input.startedAt) : undefined,
  }}

/** ContainerStateTerminated is a terminated state of a container. */
export interface ContainerStateTerminated {
  containerID?: string | null;
  exitCode: number;
  finishedAt?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  signal?: number | null;
  startedAt?: c.Time | null;
}
export function toContainerStateTerminated(input: c.JSONValue): ContainerStateTerminated {
  const obj = c.checkObj(input);
  return {
    containerID: c.readOpt(obj["containerID"], c.checkStr),
    exitCode: c.checkNum(obj["exitCode"]),
    finishedAt: c.readOpt(obj["finishedAt"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    signal: c.readOpt(obj["signal"], c.checkNum),
    startedAt: c.readOpt(obj["startedAt"], c.toTime),
  }}
export function fromContainerStateTerminated(input: ContainerStateTerminated): c.JSONValue {
  return {
    ...input,
    finishedAt: input.finishedAt != null ? c.fromTime(input.finishedAt) : undefined,
    startedAt: input.startedAt != null ? c.fromTime(input.startedAt) : undefined,
  }}

/** ContainerStateWaiting is a waiting state of a container. */
export interface ContainerStateWaiting {
  message?: string | null;
  reason?: string | null;
}
export function toContainerStateWaiting(input: c.JSONValue): ContainerStateWaiting {
  const obj = c.checkObj(input);
  return {
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
  }}
export function fromContainerStateWaiting(input: ContainerStateWaiting): c.JSONValue {
  return {
    ...input,
  }}

/** ContainerStatus contains details for the current status of this container. */
export interface ContainerStatus {
  containerID?: string | null;
  image: string;
  imageID: string;
  lastState?: ContainerState | null;
  name: string;
  ready: boolean;
  restartCount: number;
  started?: boolean | null;
  state?: ContainerState | null;
}
export function toContainerStatus(input: c.JSONValue): ContainerStatus {
  const obj = c.checkObj(input);
  return {
    containerID: c.readOpt(obj["containerID"], c.checkStr),
    image: c.checkStr(obj["image"]),
    imageID: c.checkStr(obj["imageID"]),
    lastState: c.readOpt(obj["lastState"], toContainerState),
    name: c.checkStr(obj["name"]),
    ready: c.checkBool(obj["ready"]),
    restartCount: c.checkNum(obj["restartCount"]),
    started: c.readOpt(obj["started"], c.checkBool),
    state: c.readOpt(obj["state"], toContainerState),
  }}
export function fromContainerStatus(input: ContainerStatus): c.JSONValue {
  return {
    ...input,
    lastState: input.lastState != null ? fromContainerState(input.lastState) : undefined,
    state: input.state != null ? fromContainerState(input.state) : undefined,
  }}

/** DaemonEndpoint contains information about a single Daemon endpoint. */
export interface DaemonEndpoint {
  Port: number;
}
export function toDaemonEndpoint(input: c.JSONValue): DaemonEndpoint {
  const obj = c.checkObj(input);
  return {
    Port: c.checkNum(obj["Port"]),
  }}
export function fromDaemonEndpoint(input: DaemonEndpoint): c.JSONValue {
  return {
    ...input,
  }}

/** Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode. */
export interface DownwardAPIProjection {
  items?: Array<DownwardAPIVolumeFile> | null;
}
export function toDownwardAPIProjection(input: c.JSONValue): DownwardAPIProjection {
  const obj = c.checkObj(input);
  return {
    items: c.readOpt(obj["items"], x => c.readList(x, toDownwardAPIVolumeFile)),
  }}
export function fromDownwardAPIProjection(input: DownwardAPIProjection): c.JSONValue {
  return {
    ...input,
    items: input.items?.map(fromDownwardAPIVolumeFile),
  }}

/** DownwardAPIVolumeFile represents information to create the file containing the pod field */
export interface DownwardAPIVolumeFile {
  fieldRef?: ObjectFieldSelector | null;
  mode?: number | null;
  path: string;
  resourceFieldRef?: ResourceFieldSelector | null;
}
export function toDownwardAPIVolumeFile(input: c.JSONValue): DownwardAPIVolumeFile {
  const obj = c.checkObj(input);
  return {
    fieldRef: c.readOpt(obj["fieldRef"], toObjectFieldSelector),
    mode: c.readOpt(obj["mode"], c.checkNum),
    path: c.checkStr(obj["path"]),
    resourceFieldRef: c.readOpt(obj["resourceFieldRef"], toResourceFieldSelector),
  }}
export function fromDownwardAPIVolumeFile(input: DownwardAPIVolumeFile): c.JSONValue {
  return {
    ...input,
    fieldRef: input.fieldRef != null ? fromObjectFieldSelector(input.fieldRef) : undefined,
    resourceFieldRef: input.resourceFieldRef != null ? fromResourceFieldSelector(input.resourceFieldRef) : undefined,
  }}

/** DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling. */
export interface DownwardAPIVolumeSource {
  defaultMode?: number | null;
  items?: Array<DownwardAPIVolumeFile> | null;
}
export function toDownwardAPIVolumeSource(input: c.JSONValue): DownwardAPIVolumeSource {
  const obj = c.checkObj(input);
  return {
    defaultMode: c.readOpt(obj["defaultMode"], c.checkNum),
    items: c.readOpt(obj["items"], x => c.readList(x, toDownwardAPIVolumeFile)),
  }}
export function fromDownwardAPIVolumeSource(input: DownwardAPIVolumeSource): c.JSONValue {
  return {
    ...input,
    items: input.items?.map(fromDownwardAPIVolumeFile),
  }}

/** Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling. */
export interface EmptyDirVolumeSource {
  medium?: string | null;
  sizeLimit?: c.Quantity | null;
}
export function toEmptyDirVolumeSource(input: c.JSONValue): EmptyDirVolumeSource {
  const obj = c.checkObj(input);
  return {
    medium: c.readOpt(obj["medium"], c.checkStr),
    sizeLimit: c.readOpt(obj["sizeLimit"], c.toQuantity),
  }}
export function fromEmptyDirVolumeSource(input: EmptyDirVolumeSource): c.JSONValue {
  return {
    ...input,
    sizeLimit: input.sizeLimit != null ? c.fromQuantity(input.sizeLimit) : undefined,
  }}

/** EndpointAddress is a tuple that describes single IP address. */
export interface EndpointAddress {
  hostname?: string | null;
  ip: string;
  nodeName?: string | null;
  targetRef?: ObjectReference | null;
}
export function toEndpointAddress(input: c.JSONValue): EndpointAddress {
  const obj = c.checkObj(input);
  return {
    hostname: c.readOpt(obj["hostname"], c.checkStr),
    ip: c.checkStr(obj["ip"]),
    nodeName: c.readOpt(obj["nodeName"], c.checkStr),
    targetRef: c.readOpt(obj["targetRef"], toObjectReference),
  }}
export function fromEndpointAddress(input: EndpointAddress): c.JSONValue {
  return {
    ...input,
    targetRef: input.targetRef != null ? fromObjectReference(input.targetRef) : undefined,
  }}

/** EndpointPort is a tuple that describes a single port. */
export interface EndpointPort {
  appProtocol?: string | null;
  name?: string | null;
  port: number;
  protocol?: string | null;
}
export function toEndpointPort(input: c.JSONValue): EndpointPort {
  const obj = c.checkObj(input);
  return {
    appProtocol: c.readOpt(obj["appProtocol"], c.checkStr),
    name: c.readOpt(obj["name"], c.checkStr),
    port: c.checkNum(obj["port"]),
    protocol: c.readOpt(obj["protocol"], c.checkStr),
  }}
export function fromEndpointPort(input: EndpointPort): c.JSONValue {
  return {
    ...input,
  }}

/** EndpointSubset is a group of addresses with a common set of ports. The expanded set of endpoints is the Cartesian product of Addresses x Ports. For example, given:
  {
    Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
    Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
  }
The resulting set of endpoints can be viewed as:
    a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
    b: [ 10.10.1.1:309, 10.10.2.2:309 ] */
export interface EndpointSubset {
  addresses?: Array<EndpointAddress> | null;
  notReadyAddresses?: Array<EndpointAddress> | null;
  ports?: Array<EndpointPort> | null;
}
export function toEndpointSubset(input: c.JSONValue): EndpointSubset {
  const obj = c.checkObj(input);
  return {
    addresses: c.readOpt(obj["addresses"], x => c.readList(x, toEndpointAddress)),
    notReadyAddresses: c.readOpt(obj["notReadyAddresses"], x => c.readList(x, toEndpointAddress)),
    ports: c.readOpt(obj["ports"], x => c.readList(x, toEndpointPort)),
  }}
export function fromEndpointSubset(input: EndpointSubset): c.JSONValue {
  return {
    ...input,
    addresses: input.addresses?.map(fromEndpointAddress),
    notReadyAddresses: input.notReadyAddresses?.map(fromEndpointAddress),
    ports: input.ports?.map(fromEndpointPort),
  }}

/** Endpoints is a collection of endpoints that implement the actual service. Example:
  Name: "mysvc",
  Subsets: [
    {
      Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
      Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
    },
    {
      Addresses: [{"ip": "10.10.3.3"}],
      Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
    },
 ] */
export interface Endpoints {
  apiVersion?: "v1";
  kind?: "Endpoints";
  metadata?: MetaV1.ObjectMeta | null;
  subsets?: Array<EndpointSubset> | null;
}
export function toEndpoints(input: c.JSONValue): Endpoints & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "Endpoints"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    subsets: c.readOpt(obj["subsets"], x => c.readList(x, toEndpointSubset)),
  }}
export function fromEndpoints(input: Endpoints): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "Endpoints"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    subsets: input.subsets?.map(fromEndpointSubset),
  }}

/** EndpointsList is a list of endpoints. */
export interface EndpointsList extends ListOf<Endpoints> {
  apiVersion?: "v1";
  kind?: "EndpointsList";
};
export function toEndpointsList(input: c.JSONValue): EndpointsList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "EndpointsList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toEndpoints),
  }}

/** An EphemeralContainer is a container that may be added temporarily to an existing pod for user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and they will not be restarted when they exit or when a pod is removed or restarted. If an ephemeral container causes a pod to exceed its resource allocation, the pod may be evicted. Ephemeral containers may not be added by directly updating the pod spec. They must be added via the pod's ephemeralcontainers subresource, and they will appear in the pod spec once added. This is an alpha feature enabled by the EphemeralContainers feature flag. */
export interface EphemeralContainer {
  args?: Array<string> | null;
  command?: Array<string> | null;
  env?: Array<EnvVar> | null;
  envFrom?: Array<EnvFromSource> | null;
  image?: string | null;
  imagePullPolicy?: string | null;
  lifecycle?: Lifecycle | null;
  livenessProbe?: Probe | null;
  name: string;
  ports?: Array<ContainerPort> | null;
  readinessProbe?: Probe | null;
  resources?: ResourceRequirements | null;
  securityContext?: SecurityContext | null;
  startupProbe?: Probe | null;
  stdin?: boolean | null;
  stdinOnce?: boolean | null;
  targetContainerName?: string | null;
  terminationMessagePath?: string | null;
  terminationMessagePolicy?: string | null;
  tty?: boolean | null;
  volumeDevices?: Array<VolumeDevice> | null;
  volumeMounts?: Array<VolumeMount> | null;
  workingDir?: string | null;
}
export function toEphemeralContainer(input: c.JSONValue): EphemeralContainer {
  const obj = c.checkObj(input);
  return {
    args: c.readOpt(obj["args"], x => c.readList(x, c.checkStr)),
    command: c.readOpt(obj["command"], x => c.readList(x, c.checkStr)),
    env: c.readOpt(obj["env"], x => c.readList(x, toEnvVar)),
    envFrom: c.readOpt(obj["envFrom"], x => c.readList(x, toEnvFromSource)),
    image: c.readOpt(obj["image"], c.checkStr),
    imagePullPolicy: c.readOpt(obj["imagePullPolicy"], c.checkStr),
    lifecycle: c.readOpt(obj["lifecycle"], toLifecycle),
    livenessProbe: c.readOpt(obj["livenessProbe"], toProbe),
    name: c.checkStr(obj["name"]),
    ports: c.readOpt(obj["ports"], x => c.readList(x, toContainerPort)),
    readinessProbe: c.readOpt(obj["readinessProbe"], toProbe),
    resources: c.readOpt(obj["resources"], toResourceRequirements),
    securityContext: c.readOpt(obj["securityContext"], toSecurityContext),
    startupProbe: c.readOpt(obj["startupProbe"], toProbe),
    stdin: c.readOpt(obj["stdin"], c.checkBool),
    stdinOnce: c.readOpt(obj["stdinOnce"], c.checkBool),
    targetContainerName: c.readOpt(obj["targetContainerName"], c.checkStr),
    terminationMessagePath: c.readOpt(obj["terminationMessagePath"], c.checkStr),
    terminationMessagePolicy: c.readOpt(obj["terminationMessagePolicy"], c.checkStr),
    tty: c.readOpt(obj["tty"], c.checkBool),
    volumeDevices: c.readOpt(obj["volumeDevices"], x => c.readList(x, toVolumeDevice)),
    volumeMounts: c.readOpt(obj["volumeMounts"], x => c.readList(x, toVolumeMount)),
    workingDir: c.readOpt(obj["workingDir"], c.checkStr),
  }}
export function fromEphemeralContainer(input: EphemeralContainer): c.JSONValue {
  return {
    ...input,
    env: input.env?.map(fromEnvVar),
    envFrom: input.envFrom?.map(fromEnvFromSource),
    lifecycle: input.lifecycle != null ? fromLifecycle(input.lifecycle) : undefined,
    livenessProbe: input.livenessProbe != null ? fromProbe(input.livenessProbe) : undefined,
    ports: input.ports?.map(fromContainerPort),
    readinessProbe: input.readinessProbe != null ? fromProbe(input.readinessProbe) : undefined,
    resources: input.resources != null ? fromResourceRequirements(input.resources) : undefined,
    securityContext: input.securityContext != null ? fromSecurityContext(input.securityContext) : undefined,
    startupProbe: input.startupProbe != null ? fromProbe(input.startupProbe) : undefined,
    volumeDevices: input.volumeDevices?.map(fromVolumeDevice),
    volumeMounts: input.volumeMounts?.map(fromVolumeMount),
  }}

/** Represents an ephemeral volume that is handled by a normal storage driver. */
export interface EphemeralVolumeSource {
  readOnly?: boolean | null;
  volumeClaimTemplate?: PersistentVolumeClaimTemplate | null;
}
export function toEphemeralVolumeSource(input: c.JSONValue): EphemeralVolumeSource {
  const obj = c.checkObj(input);
  return {
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    volumeClaimTemplate: c.readOpt(obj["volumeClaimTemplate"], toPersistentVolumeClaimTemplate),
  }}
export function fromEphemeralVolumeSource(input: EphemeralVolumeSource): c.JSONValue {
  return {
    ...input,
    volumeClaimTemplate: input.volumeClaimTemplate != null ? fromPersistentVolumeClaimTemplate(input.volumeClaimTemplate) : undefined,
  }}

/** PersistentVolumeClaimTemplate is used to produce PersistentVolumeClaim objects as part of an EphemeralVolumeSource. */
export interface PersistentVolumeClaimTemplate {
  metadata?: MetaV1.ObjectMeta | null;
  spec: PersistentVolumeClaimSpec;
}
export function toPersistentVolumeClaimTemplate(input: c.JSONValue): PersistentVolumeClaimTemplate {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toPersistentVolumeClaimSpec(obj["spec"]),
  }}
export function fromPersistentVolumeClaimTemplate(input: PersistentVolumeClaimTemplate): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromPersistentVolumeClaimSpec(input.spec) : undefined,
  }}

/** PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes */
export interface PersistentVolumeClaimSpec {
  accessModes?: Array<string> | null;
  dataSource?: TypedLocalObjectReference | null;
  resources?: ResourceRequirements | null;
  selector?: MetaV1.LabelSelector | null;
  storageClassName?: string | null;
  volumeMode?: string | null;
  volumeName?: string | null;
}
export function toPersistentVolumeClaimSpec(input: c.JSONValue): PersistentVolumeClaimSpec {
  const obj = c.checkObj(input);
  return {
    accessModes: c.readOpt(obj["accessModes"], x => c.readList(x, c.checkStr)),
    dataSource: c.readOpt(obj["dataSource"], toTypedLocalObjectReference),
    resources: c.readOpt(obj["resources"], toResourceRequirements),
    selector: c.readOpt(obj["selector"], MetaV1.toLabelSelector),
    storageClassName: c.readOpt(obj["storageClassName"], c.checkStr),
    volumeMode: c.readOpt(obj["volumeMode"], c.checkStr),
    volumeName: c.readOpt(obj["volumeName"], c.checkStr),
  }}
export function fromPersistentVolumeClaimSpec(input: PersistentVolumeClaimSpec): c.JSONValue {
  return {
    ...input,
    dataSource: input.dataSource != null ? fromTypedLocalObjectReference(input.dataSource) : undefined,
    resources: input.resources != null ? fromResourceRequirements(input.resources) : undefined,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
  }}

/** TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace. */
export interface TypedLocalObjectReference {
  apiGroup?: string | null;
  kind: string;
  name: string;
}
export function toTypedLocalObjectReference(input: c.JSONValue): TypedLocalObjectReference {
  const obj = c.checkObj(input);
  return {
    apiGroup: c.readOpt(obj["apiGroup"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
  }}
export function fromTypedLocalObjectReference(input: TypedLocalObjectReference): c.JSONValue {
  return {
    ...input,
  }}

/** Event is a report of an event somewhere in the cluster. */
export interface Event {
  apiVersion?: "v1";
  kind?: "Event";
  action?: string | null;
  count?: number | null;
  eventTime?: c.MicroTime | null;
  firstTimestamp?: c.Time | null;
  involvedObject: ObjectReference;
  lastTimestamp?: c.Time | null;
  message?: string | null;
  metadata: MetaV1.ObjectMeta;
  reason?: string | null;
  related?: ObjectReference | null;
  reportingComponent?: string | null;
  reportingInstance?: string | null;
  series?: EventSeries | null;
  source?: EventSource | null;
  type?: string | null;
}
export function toEvent(input: c.JSONValue): Event & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "Event"),
    action: c.readOpt(obj["action"], c.checkStr),
    count: c.readOpt(obj["count"], c.checkNum),
    eventTime: c.readOpt(obj["eventTime"], c.toMicroTime),
    firstTimestamp: c.readOpt(obj["firstTimestamp"], c.toTime),
    involvedObject: toObjectReference(obj["involvedObject"]),
    lastTimestamp: c.readOpt(obj["lastTimestamp"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    metadata: MetaV1.toObjectMeta(obj["metadata"]),
    reason: c.readOpt(obj["reason"], c.checkStr),
    related: c.readOpt(obj["related"], toObjectReference),
    reportingComponent: c.readOpt(obj["reportingComponent"], c.checkStr),
    reportingInstance: c.readOpt(obj["reportingInstance"], c.checkStr),
    series: c.readOpt(obj["series"], toEventSeries),
    source: c.readOpt(obj["source"], toEventSource),
    type: c.readOpt(obj["type"], c.checkStr),
  }}
export function fromEvent(input: Event): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "Event"),
    ...input,
    eventTime: input.eventTime != null ? c.fromMicroTime(input.eventTime) : undefined,
    firstTimestamp: input.firstTimestamp != null ? c.fromTime(input.firstTimestamp) : undefined,
    involvedObject: input.involvedObject != null ? fromObjectReference(input.involvedObject) : undefined,
    lastTimestamp: input.lastTimestamp != null ? c.fromTime(input.lastTimestamp) : undefined,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    related: input.related != null ? fromObjectReference(input.related) : undefined,
    series: input.series != null ? fromEventSeries(input.series) : undefined,
    source: input.source != null ? fromEventSource(input.source) : undefined,
  }}

/** EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time. */
export interface EventSeries {
  count?: number | null;
  lastObservedTime?: c.MicroTime | null;
}
export function toEventSeries(input: c.JSONValue): EventSeries {
  const obj = c.checkObj(input);
  return {
    count: c.readOpt(obj["count"], c.checkNum),
    lastObservedTime: c.readOpt(obj["lastObservedTime"], c.toMicroTime),
  }}
export function fromEventSeries(input: EventSeries): c.JSONValue {
  return {
    ...input,
    lastObservedTime: input.lastObservedTime != null ? c.fromMicroTime(input.lastObservedTime) : undefined,
  }}

/** EventSource contains information for an event. */
export interface EventSource {
  component?: string | null;
  host?: string | null;
}
export function toEventSource(input: c.JSONValue): EventSource {
  const obj = c.checkObj(input);
  return {
    component: c.readOpt(obj["component"], c.checkStr),
    host: c.readOpt(obj["host"], c.checkStr),
  }}
export function fromEventSource(input: EventSource): c.JSONValue {
  return {
    ...input,
  }}

/** EventList is a list of events. */
export interface EventList extends ListOf<Event> {
  apiVersion?: "v1";
  kind?: "EventList";
};
export function toEventList(input: c.JSONValue): EventList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "EventList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toEvent),
  }}

/** Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling. */
export interface FCVolumeSource {
  fsType?: string | null;
  lun?: number | null;
  readOnly?: boolean | null;
  targetWWNs?: Array<string> | null;
  wwids?: Array<string> | null;
}
export function toFCVolumeSource(input: c.JSONValue): FCVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    lun: c.readOpt(obj["lun"], c.checkNum),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    targetWWNs: c.readOpt(obj["targetWWNs"], x => c.readList(x, c.checkStr)),
    wwids: c.readOpt(obj["wwids"], x => c.readList(x, c.checkStr)),
  }}
export function fromFCVolumeSource(input: FCVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** FlexPersistentVolumeSource represents a generic persistent volume resource that is provisioned/attached using an exec based plugin. */
export interface FlexPersistentVolumeSource {
  driver: string;
  fsType?: string | null;
  options?: Record<string,string> | null;
  readOnly?: boolean | null;
  secretRef?: SecretReference | null;
}
export function toFlexPersistentVolumeSource(input: c.JSONValue): FlexPersistentVolumeSource {
  const obj = c.checkObj(input);
  return {
    driver: c.checkStr(obj["driver"]),
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    options: c.readOpt(obj["options"], x => c.readMap(x, c.checkStr)),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: c.readOpt(obj["secretRef"], toSecretReference),
  }}
export function fromFlexPersistentVolumeSource(input: FlexPersistentVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromSecretReference(input.secretRef) : undefined,
  }}

/** FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. */
export interface FlexVolumeSource {
  driver: string;
  fsType?: string | null;
  options?: Record<string,string> | null;
  readOnly?: boolean | null;
  secretRef?: LocalObjectReference | null;
}
export function toFlexVolumeSource(input: c.JSONValue): FlexVolumeSource {
  const obj = c.checkObj(input);
  return {
    driver: c.checkStr(obj["driver"]),
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    options: c.readOpt(obj["options"], x => c.readMap(x, c.checkStr)),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: c.readOpt(obj["secretRef"], toLocalObjectReference),
  }}
export function fromFlexVolumeSource(input: FlexVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromLocalObjectReference(input.secretRef) : undefined,
  }}

/** Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling. */
export interface FlockerVolumeSource {
  datasetName?: string | null;
  datasetUUID?: string | null;
}
export function toFlockerVolumeSource(input: c.JSONValue): FlockerVolumeSource {
  const obj = c.checkObj(input);
  return {
    datasetName: c.readOpt(obj["datasetName"], c.checkStr),
    datasetUUID: c.readOpt(obj["datasetUUID"], c.checkStr),
  }}
export function fromFlockerVolumeSource(input: FlockerVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** Represents a Persistent Disk resource in Google Compute Engine.

A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling. */
export interface GCEPersistentDiskVolumeSource {
  fsType?: string | null;
  partition?: number | null;
  pdName: string;
  readOnly?: boolean | null;
}
export function toGCEPersistentDiskVolumeSource(input: c.JSONValue): GCEPersistentDiskVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    partition: c.readOpt(obj["partition"], c.checkNum),
    pdName: c.checkStr(obj["pdName"]),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
  }}
export function fromGCEPersistentDiskVolumeSource(input: GCEPersistentDiskVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.

DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container. */
export interface GitRepoVolumeSource {
  directory?: string | null;
  repository: string;
  revision?: string | null;
}
export function toGitRepoVolumeSource(input: c.JSONValue): GitRepoVolumeSource {
  const obj = c.checkObj(input);
  return {
    directory: c.readOpt(obj["directory"], c.checkStr),
    repository: c.checkStr(obj["repository"]),
    revision: c.readOpt(obj["revision"], c.checkStr),
  }}
export function fromGitRepoVolumeSource(input: GitRepoVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling. */
export interface GlusterfsPersistentVolumeSource {
  endpoints: string;
  endpointsNamespace?: string | null;
  path: string;
  readOnly?: boolean | null;
}
export function toGlusterfsPersistentVolumeSource(input: c.JSONValue): GlusterfsPersistentVolumeSource {
  const obj = c.checkObj(input);
  return {
    endpoints: c.checkStr(obj["endpoints"]),
    endpointsNamespace: c.readOpt(obj["endpointsNamespace"], c.checkStr),
    path: c.checkStr(obj["path"]),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
  }}
export function fromGlusterfsPersistentVolumeSource(input: GlusterfsPersistentVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling. */
export interface GlusterfsVolumeSource {
  endpoints: string;
  path: string;
  readOnly?: boolean | null;
}
export function toGlusterfsVolumeSource(input: c.JSONValue): GlusterfsVolumeSource {
  const obj = c.checkObj(input);
  return {
    endpoints: c.checkStr(obj["endpoints"]),
    path: c.checkStr(obj["path"]),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
  }}
export function fromGlusterfsVolumeSource(input: GlusterfsVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file. */
export interface HostAlias {
  hostnames?: Array<string> | null;
  ip?: string | null;
}
export function toHostAlias(input: c.JSONValue): HostAlias {
  const obj = c.checkObj(input);
  return {
    hostnames: c.readOpt(obj["hostnames"], x => c.readList(x, c.checkStr)),
    ip: c.readOpt(obj["ip"], c.checkStr),
  }}
export function fromHostAlias(input: HostAlias): c.JSONValue {
  return {
    ...input,
  }}

/** Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling. */
export interface HostPathVolumeSource {
  path: string;
  type?: string | null;
}
export function toHostPathVolumeSource(input: c.JSONValue): HostPathVolumeSource {
  const obj = c.checkObj(input);
  return {
    path: c.checkStr(obj["path"]),
    type: c.readOpt(obj["type"], c.checkStr),
  }}
export function fromHostPathVolumeSource(input: HostPathVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** ISCSIPersistentVolumeSource represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling. */
export interface ISCSIPersistentVolumeSource {
  chapAuthDiscovery?: boolean | null;
  chapAuthSession?: boolean | null;
  fsType?: string | null;
  initiatorName?: string | null;
  iqn: string;
  iscsiInterface?: string | null;
  lun: number;
  portals?: Array<string> | null;
  readOnly?: boolean | null;
  secretRef?: SecretReference | null;
  targetPortal: string;
}
export function toISCSIPersistentVolumeSource(input: c.JSONValue): ISCSIPersistentVolumeSource {
  const obj = c.checkObj(input);
  return {
    chapAuthDiscovery: c.readOpt(obj["chapAuthDiscovery"], c.checkBool),
    chapAuthSession: c.readOpt(obj["chapAuthSession"], c.checkBool),
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    initiatorName: c.readOpt(obj["initiatorName"], c.checkStr),
    iqn: c.checkStr(obj["iqn"]),
    iscsiInterface: c.readOpt(obj["iscsiInterface"], c.checkStr),
    lun: c.checkNum(obj["lun"]),
    portals: c.readOpt(obj["portals"], x => c.readList(x, c.checkStr)),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: c.readOpt(obj["secretRef"], toSecretReference),
    targetPortal: c.checkStr(obj["targetPortal"]),
  }}
export function fromISCSIPersistentVolumeSource(input: ISCSIPersistentVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromSecretReference(input.secretRef) : undefined,
  }}

/** Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling. */
export interface ISCSIVolumeSource {
  chapAuthDiscovery?: boolean | null;
  chapAuthSession?: boolean | null;
  fsType?: string | null;
  initiatorName?: string | null;
  iqn: string;
  iscsiInterface?: string | null;
  lun: number;
  portals?: Array<string> | null;
  readOnly?: boolean | null;
  secretRef?: LocalObjectReference | null;
  targetPortal: string;
}
export function toISCSIVolumeSource(input: c.JSONValue): ISCSIVolumeSource {
  const obj = c.checkObj(input);
  return {
    chapAuthDiscovery: c.readOpt(obj["chapAuthDiscovery"], c.checkBool),
    chapAuthSession: c.readOpt(obj["chapAuthSession"], c.checkBool),
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    initiatorName: c.readOpt(obj["initiatorName"], c.checkStr),
    iqn: c.checkStr(obj["iqn"]),
    iscsiInterface: c.readOpt(obj["iscsiInterface"], c.checkStr),
    lun: c.checkNum(obj["lun"]),
    portals: c.readOpt(obj["portals"], x => c.readList(x, c.checkStr)),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: c.readOpt(obj["secretRef"], toLocalObjectReference),
    targetPortal: c.checkStr(obj["targetPortal"]),
  }}
export function fromISCSIVolumeSource(input: ISCSIVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromLocalObjectReference(input.secretRef) : undefined,
  }}

/** LimitRange sets resource usage limits for each kind of resource in a Namespace. */
export interface LimitRange {
  apiVersion?: "v1";
  kind?: "LimitRange";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: LimitRangeSpec | null;
}
export function toLimitRange(input: c.JSONValue): LimitRange & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "LimitRange"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toLimitRangeSpec),
  }}
export function fromLimitRange(input: LimitRange): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "LimitRange"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromLimitRangeSpec(input.spec) : undefined,
  }}

/** LimitRangeSpec defines a min/max usage limit for resources that match on kind. */
export interface LimitRangeSpec {
  limits: Array<LimitRangeItem>;
}
export function toLimitRangeSpec(input: c.JSONValue): LimitRangeSpec {
  const obj = c.checkObj(input);
  return {
    limits: c.readList(obj["limits"], toLimitRangeItem),
  }}
export function fromLimitRangeSpec(input: LimitRangeSpec): c.JSONValue {
  return {
    ...input,
    limits: input.limits?.map(fromLimitRangeItem),
  }}

/** LimitRangeItem defines a min/max usage limit for any resource that matches on kind. */
export interface LimitRangeItem {
  default?: Record<string,c.Quantity> | null;
  defaultRequest?: Record<string,c.Quantity> | null;
  max?: Record<string,c.Quantity> | null;
  maxLimitRequestRatio?: Record<string,c.Quantity> | null;
  min?: Record<string,c.Quantity> | null;
  type: string;
}
export function toLimitRangeItem(input: c.JSONValue): LimitRangeItem {
  const obj = c.checkObj(input);
  return {
    default: c.readOpt(obj["default"], x => c.readMap(x, c.toQuantity)),
    defaultRequest: c.readOpt(obj["defaultRequest"], x => c.readMap(x, c.toQuantity)),
    max: c.readOpt(obj["max"], x => c.readMap(x, c.toQuantity)),
    maxLimitRequestRatio: c.readOpt(obj["maxLimitRequestRatio"], x => c.readMap(x, c.toQuantity)),
    min: c.readOpt(obj["min"], x => c.readMap(x, c.toQuantity)),
    type: c.checkStr(obj["type"]),
  }}
export function fromLimitRangeItem(input: LimitRangeItem): c.JSONValue {
  return {
    ...input,
    default: c.writeMap(input.default, c.fromQuantity),
    defaultRequest: c.writeMap(input.defaultRequest, c.fromQuantity),
    max: c.writeMap(input.max, c.fromQuantity),
    maxLimitRequestRatio: c.writeMap(input.maxLimitRequestRatio, c.fromQuantity),
    min: c.writeMap(input.min, c.fromQuantity),
  }}

/** LimitRangeList is a list of LimitRange items. */
export interface LimitRangeList extends ListOf<LimitRange> {
  apiVersion?: "v1";
  kind?: "LimitRangeList";
};
export function toLimitRangeList(input: c.JSONValue): LimitRangeList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "LimitRangeList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toLimitRange),
  }}

/** LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point. */
export interface LoadBalancerIngress {
  hostname?: string | null;
  ip?: string | null;
}
export function toLoadBalancerIngress(input: c.JSONValue): LoadBalancerIngress {
  const obj = c.checkObj(input);
  return {
    hostname: c.readOpt(obj["hostname"], c.checkStr),
    ip: c.readOpt(obj["ip"], c.checkStr),
  }}
export function fromLoadBalancerIngress(input: LoadBalancerIngress): c.JSONValue {
  return {
    ...input,
  }}

/** LoadBalancerStatus represents the status of a load-balancer. */
export interface LoadBalancerStatus {
  ingress?: Array<LoadBalancerIngress> | null;
}
export function toLoadBalancerStatus(input: c.JSONValue): LoadBalancerStatus {
  const obj = c.checkObj(input);
  return {
    ingress: c.readOpt(obj["ingress"], x => c.readList(x, toLoadBalancerIngress)),
  }}
export function fromLoadBalancerStatus(input: LoadBalancerStatus): c.JSONValue {
  return {
    ...input,
    ingress: input.ingress?.map(fromLoadBalancerIngress),
  }}

/** Local represents directly-attached storage with node affinity (Beta feature) */
export interface LocalVolumeSource {
  fsType?: string | null;
  path: string;
}
export function toLocalVolumeSource(input: c.JSONValue): LocalVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    path: c.checkStr(obj["path"]),
  }}
export function fromLocalVolumeSource(input: LocalVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling. */
export interface NFSVolumeSource {
  path: string;
  readOnly?: boolean | null;
  server: string;
}
export function toNFSVolumeSource(input: c.JSONValue): NFSVolumeSource {
  const obj = c.checkObj(input);
  return {
    path: c.checkStr(obj["path"]),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    server: c.checkStr(obj["server"]),
  }}
export function fromNFSVolumeSource(input: NFSVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** Namespace provides a scope for Names. Use of multiple namespaces is optional. */
export interface Namespace {
  apiVersion?: "v1";
  kind?: "Namespace";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: NamespaceSpec | null;
  status?: NamespaceStatus | null;
}
export function toNamespace(input: c.JSONValue): Namespace & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "Namespace"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toNamespaceSpec),
    status: c.readOpt(obj["status"], toNamespaceStatus),
  }}
export function fromNamespace(input: Namespace): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "Namespace"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromNamespaceSpec(input.spec) : undefined,
    status: input.status != null ? fromNamespaceStatus(input.status) : undefined,
  }}

/** NamespaceSpec describes the attributes on a Namespace. */
export interface NamespaceSpec {
  finalizers?: Array<string> | null;
}
export function toNamespaceSpec(input: c.JSONValue): NamespaceSpec {
  const obj = c.checkObj(input);
  return {
    finalizers: c.readOpt(obj["finalizers"], x => c.readList(x, c.checkStr)),
  }}
export function fromNamespaceSpec(input: NamespaceSpec): c.JSONValue {
  return {
    ...input,
  }}

/** NamespaceStatus is information about the current status of a Namespace. */
export interface NamespaceStatus {
  conditions?: Array<NamespaceCondition> | null;
  phase?: string | null;
}
export function toNamespaceStatus(input: c.JSONValue): NamespaceStatus {
  const obj = c.checkObj(input);
  return {
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toNamespaceCondition)),
    phase: c.readOpt(obj["phase"], c.checkStr),
  }}
export function fromNamespaceStatus(input: NamespaceStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromNamespaceCondition),
  }}

/** NamespaceCondition contains details about state of namespace. */
export interface NamespaceCondition {
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toNamespaceCondition(input: c.JSONValue): NamespaceCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromNamespaceCondition(input: NamespaceCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** NamespaceList is a list of Namespaces. */
export interface NamespaceList extends ListOf<Namespace> {
  apiVersion?: "v1";
  kind?: "NamespaceList";
};
export function toNamespaceList(input: c.JSONValue): NamespaceList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "NamespaceList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toNamespace),
  }}

/** Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd). */
export interface Node {
  apiVersion?: "v1";
  kind?: "Node";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: NodeSpec | null;
  status?: NodeStatus | null;
}
export function toNode(input: c.JSONValue): Node & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "Node"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toNodeSpec),
    status: c.readOpt(obj["status"], toNodeStatus),
  }}
export function fromNode(input: Node): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "Node"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromNodeSpec(input.spec) : undefined,
    status: input.status != null ? fromNodeStatus(input.status) : undefined,
  }}

/** NodeSpec describes the attributes that a node is created with. */
export interface NodeSpec {
  configSource?: NodeConfigSource | null;
  externalID?: string | null;
  podCIDR?: string | null;
  podCIDRs?: Array<string> | null;
  providerID?: string | null;
  taints?: Array<Taint> | null;
  unschedulable?: boolean | null;
}
export function toNodeSpec(input: c.JSONValue): NodeSpec {
  const obj = c.checkObj(input);
  return {
    configSource: c.readOpt(obj["configSource"], toNodeConfigSource),
    externalID: c.readOpt(obj["externalID"], c.checkStr),
    podCIDR: c.readOpt(obj["podCIDR"], c.checkStr),
    podCIDRs: c.readOpt(obj["podCIDRs"], x => c.readList(x, c.checkStr)),
    providerID: c.readOpt(obj["providerID"], c.checkStr),
    taints: c.readOpt(obj["taints"], x => c.readList(x, toTaint)),
    unschedulable: c.readOpt(obj["unschedulable"], c.checkBool),
  }}
export function fromNodeSpec(input: NodeSpec): c.JSONValue {
  return {
    ...input,
    configSource: input.configSource != null ? fromNodeConfigSource(input.configSource) : undefined,
    taints: input.taints?.map(fromTaint),
  }}

/** NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil. */
export interface NodeConfigSource {
  configMap?: ConfigMapNodeConfigSource | null;
}
export function toNodeConfigSource(input: c.JSONValue): NodeConfigSource {
  const obj = c.checkObj(input);
  return {
    configMap: c.readOpt(obj["configMap"], toConfigMapNodeConfigSource),
  }}
export function fromNodeConfigSource(input: NodeConfigSource): c.JSONValue {
  return {
    ...input,
    configMap: input.configMap != null ? fromConfigMapNodeConfigSource(input.configMap) : undefined,
  }}

/** The node this Taint is attached to has the "effect" on any pod that does not tolerate the Taint. */
export interface Taint {
  effect: string;
  key: string;
  timeAdded?: c.Time | null;
  value?: string | null;
}
export function toTaint(input: c.JSONValue): Taint {
  const obj = c.checkObj(input);
  return {
    effect: c.checkStr(obj["effect"]),
    key: c.checkStr(obj["key"]),
    timeAdded: c.readOpt(obj["timeAdded"], c.toTime),
    value: c.readOpt(obj["value"], c.checkStr),
  }}
export function fromTaint(input: Taint): c.JSONValue {
  return {
    ...input,
    timeAdded: input.timeAdded != null ? c.fromTime(input.timeAdded) : undefined,
  }}

/** NodeStatus is information about the current status of a node. */
export interface NodeStatus {
  addresses?: Array<NodeAddress> | null;
  allocatable?: Record<string,c.Quantity> | null;
  capacity?: Record<string,c.Quantity> | null;
  conditions?: Array<NodeCondition> | null;
  config?: NodeConfigStatus | null;
  daemonEndpoints?: NodeDaemonEndpoints | null;
  images?: Array<ContainerImage> | null;
  nodeInfo?: NodeSystemInfo | null;
  phase?: string | null;
  volumesAttached?: Array<AttachedVolume> | null;
  volumesInUse?: Array<string> | null;
}
export function toNodeStatus(input: c.JSONValue): NodeStatus {
  const obj = c.checkObj(input);
  return {
    addresses: c.readOpt(obj["addresses"], x => c.readList(x, toNodeAddress)),
    allocatable: c.readOpt(obj["allocatable"], x => c.readMap(x, c.toQuantity)),
    capacity: c.readOpt(obj["capacity"], x => c.readMap(x, c.toQuantity)),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toNodeCondition)),
    config: c.readOpt(obj["config"], toNodeConfigStatus),
    daemonEndpoints: c.readOpt(obj["daemonEndpoints"], toNodeDaemonEndpoints),
    images: c.readOpt(obj["images"], x => c.readList(x, toContainerImage)),
    nodeInfo: c.readOpt(obj["nodeInfo"], toNodeSystemInfo),
    phase: c.readOpt(obj["phase"], c.checkStr),
    volumesAttached: c.readOpt(obj["volumesAttached"], x => c.readList(x, toAttachedVolume)),
    volumesInUse: c.readOpt(obj["volumesInUse"], x => c.readList(x, c.checkStr)),
  }}
export function fromNodeStatus(input: NodeStatus): c.JSONValue {
  return {
    ...input,
    addresses: input.addresses?.map(fromNodeAddress),
    allocatable: c.writeMap(input.allocatable, c.fromQuantity),
    capacity: c.writeMap(input.capacity, c.fromQuantity),
    conditions: input.conditions?.map(fromNodeCondition),
    config: input.config != null ? fromNodeConfigStatus(input.config) : undefined,
    daemonEndpoints: input.daemonEndpoints != null ? fromNodeDaemonEndpoints(input.daemonEndpoints) : undefined,
    images: input.images?.map(fromContainerImage),
    nodeInfo: input.nodeInfo != null ? fromNodeSystemInfo(input.nodeInfo) : undefined,
    volumesAttached: input.volumesAttached?.map(fromAttachedVolume),
  }}

/** NodeAddress contains information for the node's address. */
export interface NodeAddress {
  address: string;
  type: string;
}
export function toNodeAddress(input: c.JSONValue): NodeAddress {
  const obj = c.checkObj(input);
  return {
    address: c.checkStr(obj["address"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromNodeAddress(input: NodeAddress): c.JSONValue {
  return {
    ...input,
  }}

/** NodeCondition contains condition information for a node. */
export interface NodeCondition {
  lastHeartbeatTime?: c.Time | null;
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toNodeCondition(input: c.JSONValue): NodeCondition {
  const obj = c.checkObj(input);
  return {
    lastHeartbeatTime: c.readOpt(obj["lastHeartbeatTime"], c.toTime),
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromNodeCondition(input: NodeCondition): c.JSONValue {
  return {
    ...input,
    lastHeartbeatTime: input.lastHeartbeatTime != null ? c.fromTime(input.lastHeartbeatTime) : undefined,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource. */
export interface NodeConfigStatus {
  active?: NodeConfigSource | null;
  assigned?: NodeConfigSource | null;
  error?: string | null;
  lastKnownGood?: NodeConfigSource | null;
}
export function toNodeConfigStatus(input: c.JSONValue): NodeConfigStatus {
  const obj = c.checkObj(input);
  return {
    active: c.readOpt(obj["active"], toNodeConfigSource),
    assigned: c.readOpt(obj["assigned"], toNodeConfigSource),
    error: c.readOpt(obj["error"], c.checkStr),
    lastKnownGood: c.readOpt(obj["lastKnownGood"], toNodeConfigSource),
  }}
export function fromNodeConfigStatus(input: NodeConfigStatus): c.JSONValue {
  return {
    ...input,
    active: input.active != null ? fromNodeConfigSource(input.active) : undefined,
    assigned: input.assigned != null ? fromNodeConfigSource(input.assigned) : undefined,
    lastKnownGood: input.lastKnownGood != null ? fromNodeConfigSource(input.lastKnownGood) : undefined,
  }}

/** NodeDaemonEndpoints lists ports opened by daemons running on the Node. */
export interface NodeDaemonEndpoints {
  kubeletEndpoint?: DaemonEndpoint | null;
}
export function toNodeDaemonEndpoints(input: c.JSONValue): NodeDaemonEndpoints {
  const obj = c.checkObj(input);
  return {
    kubeletEndpoint: c.readOpt(obj["kubeletEndpoint"], toDaemonEndpoint),
  }}
export function fromNodeDaemonEndpoints(input: NodeDaemonEndpoints): c.JSONValue {
  return {
    ...input,
    kubeletEndpoint: input.kubeletEndpoint != null ? fromDaemonEndpoint(input.kubeletEndpoint) : undefined,
  }}

/** NodeSystemInfo is a set of ids/uuids to uniquely identify the node. */
export interface NodeSystemInfo {
  architecture: string;
  bootID: string;
  containerRuntimeVersion: string;
  kernelVersion: string;
  kubeProxyVersion: string;
  kubeletVersion: string;
  machineID: string;
  operatingSystem: string;
  osImage: string;
  systemUUID: string;
}
export function toNodeSystemInfo(input: c.JSONValue): NodeSystemInfo {
  const obj = c.checkObj(input);
  return {
    architecture: c.checkStr(obj["architecture"]),
    bootID: c.checkStr(obj["bootID"]),
    containerRuntimeVersion: c.checkStr(obj["containerRuntimeVersion"]),
    kernelVersion: c.checkStr(obj["kernelVersion"]),
    kubeProxyVersion: c.checkStr(obj["kubeProxyVersion"]),
    kubeletVersion: c.checkStr(obj["kubeletVersion"]),
    machineID: c.checkStr(obj["machineID"]),
    operatingSystem: c.checkStr(obj["operatingSystem"]),
    osImage: c.checkStr(obj["osImage"]),
    systemUUID: c.checkStr(obj["systemUUID"]),
  }}
export function fromNodeSystemInfo(input: NodeSystemInfo): c.JSONValue {
  return {
    ...input,
  }}

/** NodeList is the whole list of all Nodes which have been registered with master. */
export interface NodeList extends ListOf<Node> {
  apiVersion?: "v1";
  kind?: "NodeList";
};
export function toNodeList(input: c.JSONValue): NodeList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "NodeList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toNode),
  }}

/** PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes */
export interface PersistentVolume {
  apiVersion?: "v1";
  kind?: "PersistentVolume";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: PersistentVolumeSpec | null;
  status?: PersistentVolumeStatus | null;
}
export function toPersistentVolume(input: c.JSONValue): PersistentVolume & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "PersistentVolume"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toPersistentVolumeSpec),
    status: c.readOpt(obj["status"], toPersistentVolumeStatus),
  }}
export function fromPersistentVolume(input: PersistentVolume): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "PersistentVolume"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromPersistentVolumeSpec(input.spec) : undefined,
    status: input.status != null ? fromPersistentVolumeStatus(input.status) : undefined,
  }}

/** PersistentVolumeSpec is the specification of a persistent volume. */
export interface PersistentVolumeSpec {
  accessModes?: Array<string> | null;
  awsElasticBlockStore?: AWSElasticBlockStoreVolumeSource | null;
  azureDisk?: AzureDiskVolumeSource | null;
  azureFile?: AzureFilePersistentVolumeSource | null;
  capacity?: Record<string,c.Quantity> | null;
  cephfs?: CephFSPersistentVolumeSource | null;
  cinder?: CinderPersistentVolumeSource | null;
  claimRef?: ObjectReference | null;
  csi?: CSIPersistentVolumeSource | null;
  fc?: FCVolumeSource | null;
  flexVolume?: FlexPersistentVolumeSource | null;
  flocker?: FlockerVolumeSource | null;
  gcePersistentDisk?: GCEPersistentDiskVolumeSource | null;
  glusterfs?: GlusterfsPersistentVolumeSource | null;
  hostPath?: HostPathVolumeSource | null;
  iscsi?: ISCSIPersistentVolumeSource | null;
  local?: LocalVolumeSource | null;
  mountOptions?: Array<string> | null;
  nfs?: NFSVolumeSource | null;
  nodeAffinity?: VolumeNodeAffinity | null;
  persistentVolumeReclaimPolicy?: string | null;
  photonPersistentDisk?: PhotonPersistentDiskVolumeSource | null;
  portworxVolume?: PortworxVolumeSource | null;
  quobyte?: QuobyteVolumeSource | null;
  rbd?: RBDPersistentVolumeSource | null;
  scaleIO?: ScaleIOPersistentVolumeSource | null;
  storageClassName?: string | null;
  storageos?: StorageOSPersistentVolumeSource | null;
  volumeMode?: string | null;
  vsphereVolume?: VsphereVirtualDiskVolumeSource | null;
}
export function toPersistentVolumeSpec(input: c.JSONValue): PersistentVolumeSpec {
  const obj = c.checkObj(input);
  return {
    accessModes: c.readOpt(obj["accessModes"], x => c.readList(x, c.checkStr)),
    awsElasticBlockStore: c.readOpt(obj["awsElasticBlockStore"], toAWSElasticBlockStoreVolumeSource),
    azureDisk: c.readOpt(obj["azureDisk"], toAzureDiskVolumeSource),
    azureFile: c.readOpt(obj["azureFile"], toAzureFilePersistentVolumeSource),
    capacity: c.readOpt(obj["capacity"], x => c.readMap(x, c.toQuantity)),
    cephfs: c.readOpt(obj["cephfs"], toCephFSPersistentVolumeSource),
    cinder: c.readOpt(obj["cinder"], toCinderPersistentVolumeSource),
    claimRef: c.readOpt(obj["claimRef"], toObjectReference),
    csi: c.readOpt(obj["csi"], toCSIPersistentVolumeSource),
    fc: c.readOpt(obj["fc"], toFCVolumeSource),
    flexVolume: c.readOpt(obj["flexVolume"], toFlexPersistentVolumeSource),
    flocker: c.readOpt(obj["flocker"], toFlockerVolumeSource),
    gcePersistentDisk: c.readOpt(obj["gcePersistentDisk"], toGCEPersistentDiskVolumeSource),
    glusterfs: c.readOpt(obj["glusterfs"], toGlusterfsPersistentVolumeSource),
    hostPath: c.readOpt(obj["hostPath"], toHostPathVolumeSource),
    iscsi: c.readOpt(obj["iscsi"], toISCSIPersistentVolumeSource),
    local: c.readOpt(obj["local"], toLocalVolumeSource),
    mountOptions: c.readOpt(obj["mountOptions"], x => c.readList(x, c.checkStr)),
    nfs: c.readOpt(obj["nfs"], toNFSVolumeSource),
    nodeAffinity: c.readOpt(obj["nodeAffinity"], toVolumeNodeAffinity),
    persistentVolumeReclaimPolicy: c.readOpt(obj["persistentVolumeReclaimPolicy"], c.checkStr),
    photonPersistentDisk: c.readOpt(obj["photonPersistentDisk"], toPhotonPersistentDiskVolumeSource),
    portworxVolume: c.readOpt(obj["portworxVolume"], toPortworxVolumeSource),
    quobyte: c.readOpt(obj["quobyte"], toQuobyteVolumeSource),
    rbd: c.readOpt(obj["rbd"], toRBDPersistentVolumeSource),
    scaleIO: c.readOpt(obj["scaleIO"], toScaleIOPersistentVolumeSource),
    storageClassName: c.readOpt(obj["storageClassName"], c.checkStr),
    storageos: c.readOpt(obj["storageos"], toStorageOSPersistentVolumeSource),
    volumeMode: c.readOpt(obj["volumeMode"], c.checkStr),
    vsphereVolume: c.readOpt(obj["vsphereVolume"], toVsphereVirtualDiskVolumeSource),
  }}
export function fromPersistentVolumeSpec(input: PersistentVolumeSpec): c.JSONValue {
  return {
    ...input,
    awsElasticBlockStore: input.awsElasticBlockStore != null ? fromAWSElasticBlockStoreVolumeSource(input.awsElasticBlockStore) : undefined,
    azureDisk: input.azureDisk != null ? fromAzureDiskVolumeSource(input.azureDisk) : undefined,
    azureFile: input.azureFile != null ? fromAzureFilePersistentVolumeSource(input.azureFile) : undefined,
    capacity: c.writeMap(input.capacity, c.fromQuantity),
    cephfs: input.cephfs != null ? fromCephFSPersistentVolumeSource(input.cephfs) : undefined,
    cinder: input.cinder != null ? fromCinderPersistentVolumeSource(input.cinder) : undefined,
    claimRef: input.claimRef != null ? fromObjectReference(input.claimRef) : undefined,
    csi: input.csi != null ? fromCSIPersistentVolumeSource(input.csi) : undefined,
    fc: input.fc != null ? fromFCVolumeSource(input.fc) : undefined,
    flexVolume: input.flexVolume != null ? fromFlexPersistentVolumeSource(input.flexVolume) : undefined,
    flocker: input.flocker != null ? fromFlockerVolumeSource(input.flocker) : undefined,
    gcePersistentDisk: input.gcePersistentDisk != null ? fromGCEPersistentDiskVolumeSource(input.gcePersistentDisk) : undefined,
    glusterfs: input.glusterfs != null ? fromGlusterfsPersistentVolumeSource(input.glusterfs) : undefined,
    hostPath: input.hostPath != null ? fromHostPathVolumeSource(input.hostPath) : undefined,
    iscsi: input.iscsi != null ? fromISCSIPersistentVolumeSource(input.iscsi) : undefined,
    local: input.local != null ? fromLocalVolumeSource(input.local) : undefined,
    nfs: input.nfs != null ? fromNFSVolumeSource(input.nfs) : undefined,
    nodeAffinity: input.nodeAffinity != null ? fromVolumeNodeAffinity(input.nodeAffinity) : undefined,
    photonPersistentDisk: input.photonPersistentDisk != null ? fromPhotonPersistentDiskVolumeSource(input.photonPersistentDisk) : undefined,
    portworxVolume: input.portworxVolume != null ? fromPortworxVolumeSource(input.portworxVolume) : undefined,
    quobyte: input.quobyte != null ? fromQuobyteVolumeSource(input.quobyte) : undefined,
    rbd: input.rbd != null ? fromRBDPersistentVolumeSource(input.rbd) : undefined,
    scaleIO: input.scaleIO != null ? fromScaleIOPersistentVolumeSource(input.scaleIO) : undefined,
    storageos: input.storageos != null ? fromStorageOSPersistentVolumeSource(input.storageos) : undefined,
    vsphereVolume: input.vsphereVolume != null ? fromVsphereVirtualDiskVolumeSource(input.vsphereVolume) : undefined,
  }}

/** VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed from. */
export interface VolumeNodeAffinity {
  required?: NodeSelector | null;
}
export function toVolumeNodeAffinity(input: c.JSONValue): VolumeNodeAffinity {
  const obj = c.checkObj(input);
  return {
    required: c.readOpt(obj["required"], toNodeSelector),
  }}
export function fromVolumeNodeAffinity(input: VolumeNodeAffinity): c.JSONValue {
  return {
    ...input,
    required: input.required != null ? fromNodeSelector(input.required) : undefined,
  }}

/** Represents a Photon Controller persistent disk resource. */
export interface PhotonPersistentDiskVolumeSource {
  fsType?: string | null;
  pdID: string;
}
export function toPhotonPersistentDiskVolumeSource(input: c.JSONValue): PhotonPersistentDiskVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    pdID: c.checkStr(obj["pdID"]),
  }}
export function fromPhotonPersistentDiskVolumeSource(input: PhotonPersistentDiskVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** PortworxVolumeSource represents a Portworx volume resource. */
export interface PortworxVolumeSource {
  fsType?: string | null;
  readOnly?: boolean | null;
  volumeID: string;
}
export function toPortworxVolumeSource(input: c.JSONValue): PortworxVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    volumeID: c.checkStr(obj["volumeID"]),
  }}
export function fromPortworxVolumeSource(input: PortworxVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling. */
export interface QuobyteVolumeSource {
  group?: string | null;
  readOnly?: boolean | null;
  registry: string;
  tenant?: string | null;
  user?: string | null;
  volume: string;
}
export function toQuobyteVolumeSource(input: c.JSONValue): QuobyteVolumeSource {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    registry: c.checkStr(obj["registry"]),
    tenant: c.readOpt(obj["tenant"], c.checkStr),
    user: c.readOpt(obj["user"], c.checkStr),
    volume: c.checkStr(obj["volume"]),
  }}
export function fromQuobyteVolumeSource(input: QuobyteVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling. */
export interface RBDPersistentVolumeSource {
  fsType?: string | null;
  image: string;
  keyring?: string | null;
  monitors: Array<string>;
  pool?: string | null;
  readOnly?: boolean | null;
  secretRef?: SecretReference | null;
  user?: string | null;
}
export function toRBDPersistentVolumeSource(input: c.JSONValue): RBDPersistentVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    image: c.checkStr(obj["image"]),
    keyring: c.readOpt(obj["keyring"], c.checkStr),
    monitors: c.readList(obj["monitors"], c.checkStr),
    pool: c.readOpt(obj["pool"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: c.readOpt(obj["secretRef"], toSecretReference),
    user: c.readOpt(obj["user"], c.checkStr),
  }}
export function fromRBDPersistentVolumeSource(input: RBDPersistentVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromSecretReference(input.secretRef) : undefined,
  }}

/** ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume */
export interface ScaleIOPersistentVolumeSource {
  fsType?: string | null;
  gateway: string;
  protectionDomain?: string | null;
  readOnly?: boolean | null;
  secretRef: SecretReference;
  sslEnabled?: boolean | null;
  storageMode?: string | null;
  storagePool?: string | null;
  system: string;
  volumeName?: string | null;
}
export function toScaleIOPersistentVolumeSource(input: c.JSONValue): ScaleIOPersistentVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    gateway: c.checkStr(obj["gateway"]),
    protectionDomain: c.readOpt(obj["protectionDomain"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: toSecretReference(obj["secretRef"]),
    sslEnabled: c.readOpt(obj["sslEnabled"], c.checkBool),
    storageMode: c.readOpt(obj["storageMode"], c.checkStr),
    storagePool: c.readOpt(obj["storagePool"], c.checkStr),
    system: c.checkStr(obj["system"]),
    volumeName: c.readOpt(obj["volumeName"], c.checkStr),
  }}
export function fromScaleIOPersistentVolumeSource(input: ScaleIOPersistentVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromSecretReference(input.secretRef) : undefined,
  }}

/** Represents a StorageOS persistent volume resource. */
export interface StorageOSPersistentVolumeSource {
  fsType?: string | null;
  readOnly?: boolean | null;
  secretRef?: ObjectReference | null;
  volumeName?: string | null;
  volumeNamespace?: string | null;
}
export function toStorageOSPersistentVolumeSource(input: c.JSONValue): StorageOSPersistentVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: c.readOpt(obj["secretRef"], toObjectReference),
    volumeName: c.readOpt(obj["volumeName"], c.checkStr),
    volumeNamespace: c.readOpt(obj["volumeNamespace"], c.checkStr),
  }}
export function fromStorageOSPersistentVolumeSource(input: StorageOSPersistentVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromObjectReference(input.secretRef) : undefined,
  }}

/** Represents a vSphere volume resource. */
export interface VsphereVirtualDiskVolumeSource {
  fsType?: string | null;
  storagePolicyID?: string | null;
  storagePolicyName?: string | null;
  volumePath: string;
}
export function toVsphereVirtualDiskVolumeSource(input: c.JSONValue): VsphereVirtualDiskVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    storagePolicyID: c.readOpt(obj["storagePolicyID"], c.checkStr),
    storagePolicyName: c.readOpt(obj["storagePolicyName"], c.checkStr),
    volumePath: c.checkStr(obj["volumePath"]),
  }}
export function fromVsphereVirtualDiskVolumeSource(input: VsphereVirtualDiskVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** PersistentVolumeStatus is the current status of a persistent volume. */
export interface PersistentVolumeStatus {
  message?: string | null;
  phase?: string | null;
  reason?: string | null;
}
export function toPersistentVolumeStatus(input: c.JSONValue): PersistentVolumeStatus {
  const obj = c.checkObj(input);
  return {
    message: c.readOpt(obj["message"], c.checkStr),
    phase: c.readOpt(obj["phase"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
  }}
export function fromPersistentVolumeStatus(input: PersistentVolumeStatus): c.JSONValue {
  return {
    ...input,
  }}

/** PersistentVolumeClaim is a user's request for and claim to a persistent volume */
export interface PersistentVolumeClaim {
  apiVersion?: "v1";
  kind?: "PersistentVolumeClaim";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: PersistentVolumeClaimSpec | null;
  status?: PersistentVolumeClaimStatus | null;
}
export function toPersistentVolumeClaim(input: c.JSONValue): PersistentVolumeClaim & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "PersistentVolumeClaim"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toPersistentVolumeClaimSpec),
    status: c.readOpt(obj["status"], toPersistentVolumeClaimStatus),
  }}
export function fromPersistentVolumeClaim(input: PersistentVolumeClaim): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "PersistentVolumeClaim"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromPersistentVolumeClaimSpec(input.spec) : undefined,
    status: input.status != null ? fromPersistentVolumeClaimStatus(input.status) : undefined,
  }}

/** PersistentVolumeClaimStatus is the current status of a persistent volume claim. */
export interface PersistentVolumeClaimStatus {
  accessModes?: Array<string> | null;
  capacity?: Record<string,c.Quantity> | null;
  conditions?: Array<PersistentVolumeClaimCondition> | null;
  phase?: string | null;
}
export function toPersistentVolumeClaimStatus(input: c.JSONValue): PersistentVolumeClaimStatus {
  const obj = c.checkObj(input);
  return {
    accessModes: c.readOpt(obj["accessModes"], x => c.readList(x, c.checkStr)),
    capacity: c.readOpt(obj["capacity"], x => c.readMap(x, c.toQuantity)),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toPersistentVolumeClaimCondition)),
    phase: c.readOpt(obj["phase"], c.checkStr),
  }}
export function fromPersistentVolumeClaimStatus(input: PersistentVolumeClaimStatus): c.JSONValue {
  return {
    ...input,
    capacity: c.writeMap(input.capacity, c.fromQuantity),
    conditions: input.conditions?.map(fromPersistentVolumeClaimCondition),
  }}

/** PersistentVolumeClaimCondition contails details about state of pvc */
export interface PersistentVolumeClaimCondition {
  lastProbeTime?: c.Time | null;
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toPersistentVolumeClaimCondition(input: c.JSONValue): PersistentVolumeClaimCondition {
  const obj = c.checkObj(input);
  return {
    lastProbeTime: c.readOpt(obj["lastProbeTime"], c.toTime),
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromPersistentVolumeClaimCondition(input: PersistentVolumeClaimCondition): c.JSONValue {
  return {
    ...input,
    lastProbeTime: input.lastProbeTime != null ? c.fromTime(input.lastProbeTime) : undefined,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** PersistentVolumeClaimList is a list of PersistentVolumeClaim items. */
export interface PersistentVolumeClaimList extends ListOf<PersistentVolumeClaim> {
  apiVersion?: "v1";
  kind?: "PersistentVolumeClaimList";
};
export function toPersistentVolumeClaimList(input: c.JSONValue): PersistentVolumeClaimList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "PersistentVolumeClaimList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toPersistentVolumeClaim),
  }}

/** PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system). */
export interface PersistentVolumeClaimVolumeSource {
  claimName: string;
  readOnly?: boolean | null;
}
export function toPersistentVolumeClaimVolumeSource(input: c.JSONValue): PersistentVolumeClaimVolumeSource {
  const obj = c.checkObj(input);
  return {
    claimName: c.checkStr(obj["claimName"]),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
  }}
export function fromPersistentVolumeClaimVolumeSource(input: PersistentVolumeClaimVolumeSource): c.JSONValue {
  return {
    ...input,
  }}

/** PersistentVolumeList is a list of PersistentVolume items. */
export interface PersistentVolumeList extends ListOf<PersistentVolume> {
  apiVersion?: "v1";
  kind?: "PersistentVolumeList";
};
export function toPersistentVolumeList(input: c.JSONValue): PersistentVolumeList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "PersistentVolumeList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toPersistentVolume),
  }}

/** Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. */
export interface Pod {
  apiVersion?: "v1";
  kind?: "Pod";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: PodSpec | null;
  status?: PodStatus | null;
}
export function toPod(input: c.JSONValue): Pod & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "Pod"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toPodSpec),
    status: c.readOpt(obj["status"], toPodStatus),
  }}
export function fromPod(input: Pod): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "Pod"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromPodSpec(input.spec) : undefined,
    status: input.status != null ? fromPodStatus(input.status) : undefined,
  }}

/** PodSpec is a description of a pod. */
export interface PodSpec {
  activeDeadlineSeconds?: number | null;
  affinity?: Affinity | null;
  automountServiceAccountToken?: boolean | null;
  containers: Array<Container>;
  dnsConfig?: PodDNSConfig | null;
  dnsPolicy?: string | null;
  enableServiceLinks?: boolean | null;
  ephemeralContainers?: Array<EphemeralContainer> | null;
  hostAliases?: Array<HostAlias> | null;
  hostIPC?: boolean | null;
  hostNetwork?: boolean | null;
  hostPID?: boolean | null;
  hostname?: string | null;
  imagePullSecrets?: Array<LocalObjectReference> | null;
  initContainers?: Array<Container> | null;
  nodeName?: string | null;
  nodeSelector?: Record<string,string> | null;
  overhead?: Record<string,c.Quantity> | null;
  preemptionPolicy?: string | null;
  priority?: number | null;
  priorityClassName?: string | null;
  readinessGates?: Array<PodReadinessGate> | null;
  restartPolicy?: string | null;
  runtimeClassName?: string | null;
  schedulerName?: string | null;
  securityContext?: PodSecurityContext | null;
  serviceAccount?: string | null;
  serviceAccountName?: string | null;
  setHostnameAsFQDN?: boolean | null;
  shareProcessNamespace?: boolean | null;
  subdomain?: string | null;
  terminationGracePeriodSeconds?: number | null;
  tolerations?: Array<Toleration> | null;
  topologySpreadConstraints?: Array<TopologySpreadConstraint> | null;
  volumes?: Array<Volume> | null;
}
export function toPodSpec(input: c.JSONValue): PodSpec {
  const obj = c.checkObj(input);
  return {
    activeDeadlineSeconds: c.readOpt(obj["activeDeadlineSeconds"], c.checkNum),
    affinity: c.readOpt(obj["affinity"], toAffinity),
    automountServiceAccountToken: c.readOpt(obj["automountServiceAccountToken"], c.checkBool),
    containers: c.readList(obj["containers"], toContainer),
    dnsConfig: c.readOpt(obj["dnsConfig"], toPodDNSConfig),
    dnsPolicy: c.readOpt(obj["dnsPolicy"], c.checkStr),
    enableServiceLinks: c.readOpt(obj["enableServiceLinks"], c.checkBool),
    ephemeralContainers: c.readOpt(obj["ephemeralContainers"], x => c.readList(x, toEphemeralContainer)),
    hostAliases: c.readOpt(obj["hostAliases"], x => c.readList(x, toHostAlias)),
    hostIPC: c.readOpt(obj["hostIPC"], c.checkBool),
    hostNetwork: c.readOpt(obj["hostNetwork"], c.checkBool),
    hostPID: c.readOpt(obj["hostPID"], c.checkBool),
    hostname: c.readOpt(obj["hostname"], c.checkStr),
    imagePullSecrets: c.readOpt(obj["imagePullSecrets"], x => c.readList(x, toLocalObjectReference)),
    initContainers: c.readOpt(obj["initContainers"], x => c.readList(x, toContainer)),
    nodeName: c.readOpt(obj["nodeName"], c.checkStr),
    nodeSelector: c.readOpt(obj["nodeSelector"], x => c.readMap(x, c.checkStr)),
    overhead: c.readOpt(obj["overhead"], x => c.readMap(x, c.toQuantity)),
    preemptionPolicy: c.readOpt(obj["preemptionPolicy"], c.checkStr),
    priority: c.readOpt(obj["priority"], c.checkNum),
    priorityClassName: c.readOpt(obj["priorityClassName"], c.checkStr),
    readinessGates: c.readOpt(obj["readinessGates"], x => c.readList(x, toPodReadinessGate)),
    restartPolicy: c.readOpt(obj["restartPolicy"], c.checkStr),
    runtimeClassName: c.readOpt(obj["runtimeClassName"], c.checkStr),
    schedulerName: c.readOpt(obj["schedulerName"], c.checkStr),
    securityContext: c.readOpt(obj["securityContext"], toPodSecurityContext),
    serviceAccount: c.readOpt(obj["serviceAccount"], c.checkStr),
    serviceAccountName: c.readOpt(obj["serviceAccountName"], c.checkStr),
    setHostnameAsFQDN: c.readOpt(obj["setHostnameAsFQDN"], c.checkBool),
    shareProcessNamespace: c.readOpt(obj["shareProcessNamespace"], c.checkBool),
    subdomain: c.readOpt(obj["subdomain"], c.checkStr),
    terminationGracePeriodSeconds: c.readOpt(obj["terminationGracePeriodSeconds"], c.checkNum),
    tolerations: c.readOpt(obj["tolerations"], x => c.readList(x, toToleration)),
    topologySpreadConstraints: c.readOpt(obj["topologySpreadConstraints"], x => c.readList(x, toTopologySpreadConstraint)),
    volumes: c.readOpt(obj["volumes"], x => c.readList(x, toVolume)),
  }}
export function fromPodSpec(input: PodSpec): c.JSONValue {
  return {
    ...input,
    affinity: input.affinity != null ? fromAffinity(input.affinity) : undefined,
    containers: input.containers?.map(fromContainer),
    dnsConfig: input.dnsConfig != null ? fromPodDNSConfig(input.dnsConfig) : undefined,
    ephemeralContainers: input.ephemeralContainers?.map(fromEphemeralContainer),
    hostAliases: input.hostAliases?.map(fromHostAlias),
    imagePullSecrets: input.imagePullSecrets?.map(fromLocalObjectReference),
    initContainers: input.initContainers?.map(fromContainer),
    overhead: c.writeMap(input.overhead, c.fromQuantity),
    readinessGates: input.readinessGates?.map(fromPodReadinessGate),
    securityContext: input.securityContext != null ? fromPodSecurityContext(input.securityContext) : undefined,
    tolerations: input.tolerations?.map(fromToleration),
    topologySpreadConstraints: input.topologySpreadConstraints?.map(fromTopologySpreadConstraint),
    volumes: input.volumes?.map(fromVolume),
  }}

/** PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy. */
export interface PodDNSConfig {
  nameservers?: Array<string> | null;
  options?: Array<PodDNSConfigOption> | null;
  searches?: Array<string> | null;
}
export function toPodDNSConfig(input: c.JSONValue): PodDNSConfig {
  const obj = c.checkObj(input);
  return {
    nameservers: c.readOpt(obj["nameservers"], x => c.readList(x, c.checkStr)),
    options: c.readOpt(obj["options"], x => c.readList(x, toPodDNSConfigOption)),
    searches: c.readOpt(obj["searches"], x => c.readList(x, c.checkStr)),
  }}
export function fromPodDNSConfig(input: PodDNSConfig): c.JSONValue {
  return {
    ...input,
    options: input.options?.map(fromPodDNSConfigOption),
  }}

/** PodDNSConfigOption defines DNS resolver options of a pod. */
export interface PodDNSConfigOption {
  name?: string | null;
  value?: string | null;
}
export function toPodDNSConfigOption(input: c.JSONValue): PodDNSConfigOption {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    value: c.readOpt(obj["value"], c.checkStr),
  }}
export function fromPodDNSConfigOption(input: PodDNSConfigOption): c.JSONValue {
  return {
    ...input,
  }}

/** PodReadinessGate contains the reference to a pod condition */
export interface PodReadinessGate {
  conditionType: string;
}
export function toPodReadinessGate(input: c.JSONValue): PodReadinessGate {
  const obj = c.checkObj(input);
  return {
    conditionType: c.checkStr(obj["conditionType"]),
  }}
export function fromPodReadinessGate(input: PodReadinessGate): c.JSONValue {
  return {
    ...input,
  }}

/** PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext. */
export interface PodSecurityContext {
  fsGroup?: number | null;
  fsGroupChangePolicy?: string | null;
  runAsGroup?: number | null;
  runAsNonRoot?: boolean | null;
  runAsUser?: number | null;
  seLinuxOptions?: SELinuxOptions | null;
  seccompProfile?: SeccompProfile | null;
  supplementalGroups?: Array<number> | null;
  sysctls?: Array<Sysctl> | null;
  windowsOptions?: WindowsSecurityContextOptions | null;
}
export function toPodSecurityContext(input: c.JSONValue): PodSecurityContext {
  const obj = c.checkObj(input);
  return {
    fsGroup: c.readOpt(obj["fsGroup"], c.checkNum),
    fsGroupChangePolicy: c.readOpt(obj["fsGroupChangePolicy"], c.checkStr),
    runAsGroup: c.readOpt(obj["runAsGroup"], c.checkNum),
    runAsNonRoot: c.readOpt(obj["runAsNonRoot"], c.checkBool),
    runAsUser: c.readOpt(obj["runAsUser"], c.checkNum),
    seLinuxOptions: c.readOpt(obj["seLinuxOptions"], toSELinuxOptions),
    seccompProfile: c.readOpt(obj["seccompProfile"], toSeccompProfile),
    supplementalGroups: c.readOpt(obj["supplementalGroups"], x => c.readList(x, c.checkNum)),
    sysctls: c.readOpt(obj["sysctls"], x => c.readList(x, toSysctl)),
    windowsOptions: c.readOpt(obj["windowsOptions"], toWindowsSecurityContextOptions),
  }}
export function fromPodSecurityContext(input: PodSecurityContext): c.JSONValue {
  return {
    ...input,
    seLinuxOptions: input.seLinuxOptions != null ? fromSELinuxOptions(input.seLinuxOptions) : undefined,
    seccompProfile: input.seccompProfile != null ? fromSeccompProfile(input.seccompProfile) : undefined,
    sysctls: input.sysctls?.map(fromSysctl),
    windowsOptions: input.windowsOptions != null ? fromWindowsSecurityContextOptions(input.windowsOptions) : undefined,
  }}

/** Sysctl defines a kernel parameter to be set */
export interface Sysctl {
  name: string;
  value: string;
}
export function toSysctl(input: c.JSONValue): Sysctl {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    value: c.checkStr(obj["value"]),
  }}
export function fromSysctl(input: Sysctl): c.JSONValue {
  return {
    ...input,
  }}

/** The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>. */
export interface Toleration {
  effect?: string | null;
  key?: string | null;
  operator?: string | null;
  tolerationSeconds?: number | null;
  value?: string | null;
}
export function toToleration(input: c.JSONValue): Toleration {
  const obj = c.checkObj(input);
  return {
    effect: c.readOpt(obj["effect"], c.checkStr),
    key: c.readOpt(obj["key"], c.checkStr),
    operator: c.readOpt(obj["operator"], c.checkStr),
    tolerationSeconds: c.readOpt(obj["tolerationSeconds"], c.checkNum),
    value: c.readOpt(obj["value"], c.checkStr),
  }}
export function fromToleration(input: Toleration): c.JSONValue {
  return {
    ...input,
  }}

/** TopologySpreadConstraint specifies how to spread matching pods among the given topology. */
export interface TopologySpreadConstraint {
  labelSelector?: MetaV1.LabelSelector | null;
  maxSkew: number;
  topologyKey: string;
  whenUnsatisfiable: string;
}
export function toTopologySpreadConstraint(input: c.JSONValue): TopologySpreadConstraint {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], MetaV1.toLabelSelector),
    maxSkew: c.checkNum(obj["maxSkew"]),
    topologyKey: c.checkStr(obj["topologyKey"]),
    whenUnsatisfiable: c.checkStr(obj["whenUnsatisfiable"]),
  }}
export function fromTopologySpreadConstraint(input: TopologySpreadConstraint): c.JSONValue {
  return {
    ...input,
    labelSelector: input.labelSelector != null ? MetaV1.fromLabelSelector(input.labelSelector) : undefined,
  }}

/** Volume represents a named volume in a pod that may be accessed by any container in the pod. */
export interface Volume {
  awsElasticBlockStore?: AWSElasticBlockStoreVolumeSource | null;
  azureDisk?: AzureDiskVolumeSource | null;
  azureFile?: AzureFileVolumeSource | null;
  cephfs?: CephFSVolumeSource | null;
  cinder?: CinderVolumeSource | null;
  configMap?: ConfigMapVolumeSource | null;
  csi?: CSIVolumeSource | null;
  downwardAPI?: DownwardAPIVolumeSource | null;
  emptyDir?: EmptyDirVolumeSource | null;
  ephemeral?: EphemeralVolumeSource | null;
  fc?: FCVolumeSource | null;
  flexVolume?: FlexVolumeSource | null;
  flocker?: FlockerVolumeSource | null;
  gcePersistentDisk?: GCEPersistentDiskVolumeSource | null;
  gitRepo?: GitRepoVolumeSource | null;
  glusterfs?: GlusterfsVolumeSource | null;
  hostPath?: HostPathVolumeSource | null;
  iscsi?: ISCSIVolumeSource | null;
  name: string;
  nfs?: NFSVolumeSource | null;
  persistentVolumeClaim?: PersistentVolumeClaimVolumeSource | null;
  photonPersistentDisk?: PhotonPersistentDiskVolumeSource | null;
  portworxVolume?: PortworxVolumeSource | null;
  projected?: ProjectedVolumeSource | null;
  quobyte?: QuobyteVolumeSource | null;
  rbd?: RBDVolumeSource | null;
  scaleIO?: ScaleIOVolumeSource | null;
  secret?: SecretVolumeSource | null;
  storageos?: StorageOSVolumeSource | null;
  vsphereVolume?: VsphereVirtualDiskVolumeSource | null;
}
export function toVolume(input: c.JSONValue): Volume {
  const obj = c.checkObj(input);
  return {
    awsElasticBlockStore: c.readOpt(obj["awsElasticBlockStore"], toAWSElasticBlockStoreVolumeSource),
    azureDisk: c.readOpt(obj["azureDisk"], toAzureDiskVolumeSource),
    azureFile: c.readOpt(obj["azureFile"], toAzureFileVolumeSource),
    cephfs: c.readOpt(obj["cephfs"], toCephFSVolumeSource),
    cinder: c.readOpt(obj["cinder"], toCinderVolumeSource),
    configMap: c.readOpt(obj["configMap"], toConfigMapVolumeSource),
    csi: c.readOpt(obj["csi"], toCSIVolumeSource),
    downwardAPI: c.readOpt(obj["downwardAPI"], toDownwardAPIVolumeSource),
    emptyDir: c.readOpt(obj["emptyDir"], toEmptyDirVolumeSource),
    ephemeral: c.readOpt(obj["ephemeral"], toEphemeralVolumeSource),
    fc: c.readOpt(obj["fc"], toFCVolumeSource),
    flexVolume: c.readOpt(obj["flexVolume"], toFlexVolumeSource),
    flocker: c.readOpt(obj["flocker"], toFlockerVolumeSource),
    gcePersistentDisk: c.readOpt(obj["gcePersistentDisk"], toGCEPersistentDiskVolumeSource),
    gitRepo: c.readOpt(obj["gitRepo"], toGitRepoVolumeSource),
    glusterfs: c.readOpt(obj["glusterfs"], toGlusterfsVolumeSource),
    hostPath: c.readOpt(obj["hostPath"], toHostPathVolumeSource),
    iscsi: c.readOpt(obj["iscsi"], toISCSIVolumeSource),
    name: c.checkStr(obj["name"]),
    nfs: c.readOpt(obj["nfs"], toNFSVolumeSource),
    persistentVolumeClaim: c.readOpt(obj["persistentVolumeClaim"], toPersistentVolumeClaimVolumeSource),
    photonPersistentDisk: c.readOpt(obj["photonPersistentDisk"], toPhotonPersistentDiskVolumeSource),
    portworxVolume: c.readOpt(obj["portworxVolume"], toPortworxVolumeSource),
    projected: c.readOpt(obj["projected"], toProjectedVolumeSource),
    quobyte: c.readOpt(obj["quobyte"], toQuobyteVolumeSource),
    rbd: c.readOpt(obj["rbd"], toRBDVolumeSource),
    scaleIO: c.readOpt(obj["scaleIO"], toScaleIOVolumeSource),
    secret: c.readOpt(obj["secret"], toSecretVolumeSource),
    storageos: c.readOpt(obj["storageos"], toStorageOSVolumeSource),
    vsphereVolume: c.readOpt(obj["vsphereVolume"], toVsphereVirtualDiskVolumeSource),
  }}
export function fromVolume(input: Volume): c.JSONValue {
  return {
    ...input,
    awsElasticBlockStore: input.awsElasticBlockStore != null ? fromAWSElasticBlockStoreVolumeSource(input.awsElasticBlockStore) : undefined,
    azureDisk: input.azureDisk != null ? fromAzureDiskVolumeSource(input.azureDisk) : undefined,
    azureFile: input.azureFile != null ? fromAzureFileVolumeSource(input.azureFile) : undefined,
    cephfs: input.cephfs != null ? fromCephFSVolumeSource(input.cephfs) : undefined,
    cinder: input.cinder != null ? fromCinderVolumeSource(input.cinder) : undefined,
    configMap: input.configMap != null ? fromConfigMapVolumeSource(input.configMap) : undefined,
    csi: input.csi != null ? fromCSIVolumeSource(input.csi) : undefined,
    downwardAPI: input.downwardAPI != null ? fromDownwardAPIVolumeSource(input.downwardAPI) : undefined,
    emptyDir: input.emptyDir != null ? fromEmptyDirVolumeSource(input.emptyDir) : undefined,
    ephemeral: input.ephemeral != null ? fromEphemeralVolumeSource(input.ephemeral) : undefined,
    fc: input.fc != null ? fromFCVolumeSource(input.fc) : undefined,
    flexVolume: input.flexVolume != null ? fromFlexVolumeSource(input.flexVolume) : undefined,
    flocker: input.flocker != null ? fromFlockerVolumeSource(input.flocker) : undefined,
    gcePersistentDisk: input.gcePersistentDisk != null ? fromGCEPersistentDiskVolumeSource(input.gcePersistentDisk) : undefined,
    gitRepo: input.gitRepo != null ? fromGitRepoVolumeSource(input.gitRepo) : undefined,
    glusterfs: input.glusterfs != null ? fromGlusterfsVolumeSource(input.glusterfs) : undefined,
    hostPath: input.hostPath != null ? fromHostPathVolumeSource(input.hostPath) : undefined,
    iscsi: input.iscsi != null ? fromISCSIVolumeSource(input.iscsi) : undefined,
    nfs: input.nfs != null ? fromNFSVolumeSource(input.nfs) : undefined,
    persistentVolumeClaim: input.persistentVolumeClaim != null ? fromPersistentVolumeClaimVolumeSource(input.persistentVolumeClaim) : undefined,
    photonPersistentDisk: input.photonPersistentDisk != null ? fromPhotonPersistentDiskVolumeSource(input.photonPersistentDisk) : undefined,
    portworxVolume: input.portworxVolume != null ? fromPortworxVolumeSource(input.portworxVolume) : undefined,
    projected: input.projected != null ? fromProjectedVolumeSource(input.projected) : undefined,
    quobyte: input.quobyte != null ? fromQuobyteVolumeSource(input.quobyte) : undefined,
    rbd: input.rbd != null ? fromRBDVolumeSource(input.rbd) : undefined,
    scaleIO: input.scaleIO != null ? fromScaleIOVolumeSource(input.scaleIO) : undefined,
    secret: input.secret != null ? fromSecretVolumeSource(input.secret) : undefined,
    storageos: input.storageos != null ? fromStorageOSVolumeSource(input.storageos) : undefined,
    vsphereVolume: input.vsphereVolume != null ? fromVsphereVirtualDiskVolumeSource(input.vsphereVolume) : undefined,
  }}

/** Represents a projected volume source */
export interface ProjectedVolumeSource {
  defaultMode?: number | null;
  sources: Array<VolumeProjection>;
}
export function toProjectedVolumeSource(input: c.JSONValue): ProjectedVolumeSource {
  const obj = c.checkObj(input);
  return {
    defaultMode: c.readOpt(obj["defaultMode"], c.checkNum),
    sources: c.readList(obj["sources"], toVolumeProjection),
  }}
export function fromProjectedVolumeSource(input: ProjectedVolumeSource): c.JSONValue {
  return {
    ...input,
    sources: input.sources?.map(fromVolumeProjection),
  }}

/** Projection that may be projected along with other supported volume types */
export interface VolumeProjection {
  configMap?: ConfigMapProjection | null;
  downwardAPI?: DownwardAPIProjection | null;
  secret?: SecretProjection | null;
  serviceAccountToken?: ServiceAccountTokenProjection | null;
}
export function toVolumeProjection(input: c.JSONValue): VolumeProjection {
  const obj = c.checkObj(input);
  return {
    configMap: c.readOpt(obj["configMap"], toConfigMapProjection),
    downwardAPI: c.readOpt(obj["downwardAPI"], toDownwardAPIProjection),
    secret: c.readOpt(obj["secret"], toSecretProjection),
    serviceAccountToken: c.readOpt(obj["serviceAccountToken"], toServiceAccountTokenProjection),
  }}
export function fromVolumeProjection(input: VolumeProjection): c.JSONValue {
  return {
    ...input,
    configMap: input.configMap != null ? fromConfigMapProjection(input.configMap) : undefined,
    downwardAPI: input.downwardAPI != null ? fromDownwardAPIProjection(input.downwardAPI) : undefined,
    secret: input.secret != null ? fromSecretProjection(input.secret) : undefined,
    serviceAccountToken: input.serviceAccountToken != null ? fromServiceAccountTokenProjection(input.serviceAccountToken) : undefined,
  }}

/** Adapts a secret into a projected volume.

The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode. */
export interface SecretProjection {
  items?: Array<KeyToPath> | null;
  name?: string | null;
  optional?: boolean | null;
}
export function toSecretProjection(input: c.JSONValue): SecretProjection {
  const obj = c.checkObj(input);
  return {
    items: c.readOpt(obj["items"], x => c.readList(x, toKeyToPath)),
    name: c.readOpt(obj["name"], c.checkStr),
    optional: c.readOpt(obj["optional"], c.checkBool),
  }}
export function fromSecretProjection(input: SecretProjection): c.JSONValue {
  return {
    ...input,
    items: input.items?.map(fromKeyToPath),
  }}

/** ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise). */
export interface ServiceAccountTokenProjection {
  audience?: string | null;
  expirationSeconds?: number | null;
  path: string;
}
export function toServiceAccountTokenProjection(input: c.JSONValue): ServiceAccountTokenProjection {
  const obj = c.checkObj(input);
  return {
    audience: c.readOpt(obj["audience"], c.checkStr),
    expirationSeconds: c.readOpt(obj["expirationSeconds"], c.checkNum),
    path: c.checkStr(obj["path"]),
  }}
export function fromServiceAccountTokenProjection(input: ServiceAccountTokenProjection): c.JSONValue {
  return {
    ...input,
  }}

/** Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling. */
export interface RBDVolumeSource {
  fsType?: string | null;
  image: string;
  keyring?: string | null;
  monitors: Array<string>;
  pool?: string | null;
  readOnly?: boolean | null;
  secretRef?: LocalObjectReference | null;
  user?: string | null;
}
export function toRBDVolumeSource(input: c.JSONValue): RBDVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    image: c.checkStr(obj["image"]),
    keyring: c.readOpt(obj["keyring"], c.checkStr),
    monitors: c.readList(obj["monitors"], c.checkStr),
    pool: c.readOpt(obj["pool"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: c.readOpt(obj["secretRef"], toLocalObjectReference),
    user: c.readOpt(obj["user"], c.checkStr),
  }}
export function fromRBDVolumeSource(input: RBDVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromLocalObjectReference(input.secretRef) : undefined,
  }}

/** ScaleIOVolumeSource represents a persistent ScaleIO volume */
export interface ScaleIOVolumeSource {
  fsType?: string | null;
  gateway: string;
  protectionDomain?: string | null;
  readOnly?: boolean | null;
  secretRef: LocalObjectReference;
  sslEnabled?: boolean | null;
  storageMode?: string | null;
  storagePool?: string | null;
  system: string;
  volumeName?: string | null;
}
export function toScaleIOVolumeSource(input: c.JSONValue): ScaleIOVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    gateway: c.checkStr(obj["gateway"]),
    protectionDomain: c.readOpt(obj["protectionDomain"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: toLocalObjectReference(obj["secretRef"]),
    sslEnabled: c.readOpt(obj["sslEnabled"], c.checkBool),
    storageMode: c.readOpt(obj["storageMode"], c.checkStr),
    storagePool: c.readOpt(obj["storagePool"], c.checkStr),
    system: c.checkStr(obj["system"]),
    volumeName: c.readOpt(obj["volumeName"], c.checkStr),
  }}
export function fromScaleIOVolumeSource(input: ScaleIOVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromLocalObjectReference(input.secretRef) : undefined,
  }}

/** Adapts a Secret into a volume.

The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling. */
export interface SecretVolumeSource {
  defaultMode?: number | null;
  items?: Array<KeyToPath> | null;
  optional?: boolean | null;
  secretName?: string | null;
}
export function toSecretVolumeSource(input: c.JSONValue): SecretVolumeSource {
  const obj = c.checkObj(input);
  return {
    defaultMode: c.readOpt(obj["defaultMode"], c.checkNum),
    items: c.readOpt(obj["items"], x => c.readList(x, toKeyToPath)),
    optional: c.readOpt(obj["optional"], c.checkBool),
    secretName: c.readOpt(obj["secretName"], c.checkStr),
  }}
export function fromSecretVolumeSource(input: SecretVolumeSource): c.JSONValue {
  return {
    ...input,
    items: input.items?.map(fromKeyToPath),
  }}

/** Represents a StorageOS persistent volume resource. */
export interface StorageOSVolumeSource {
  fsType?: string | null;
  readOnly?: boolean | null;
  secretRef?: LocalObjectReference | null;
  volumeName?: string | null;
  volumeNamespace?: string | null;
}
export function toStorageOSVolumeSource(input: c.JSONValue): StorageOSVolumeSource {
  const obj = c.checkObj(input);
  return {
    fsType: c.readOpt(obj["fsType"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
    secretRef: c.readOpt(obj["secretRef"], toLocalObjectReference),
    volumeName: c.readOpt(obj["volumeName"], c.checkStr),
    volumeNamespace: c.readOpt(obj["volumeNamespace"], c.checkStr),
  }}
export function fromStorageOSVolumeSource(input: StorageOSVolumeSource): c.JSONValue {
  return {
    ...input,
    secretRef: input.secretRef != null ? fromLocalObjectReference(input.secretRef) : undefined,
  }}

/** PodStatus represents information about the status of a pod. Status may trail the actual state of a system, especially if the node that hosts the pod cannot contact the control plane. */
export interface PodStatus {
  conditions?: Array<PodCondition> | null;
  containerStatuses?: Array<ContainerStatus> | null;
  ephemeralContainerStatuses?: Array<ContainerStatus> | null;
  hostIP?: string | null;
  initContainerStatuses?: Array<ContainerStatus> | null;
  message?: string | null;
  nominatedNodeName?: string | null;
  phase?: string | null;
  podIP?: string | null;
  podIPs?: Array<PodIP> | null;
  qosClass?: string | null;
  reason?: string | null;
  startTime?: c.Time | null;
}
export function toPodStatus(input: c.JSONValue): PodStatus {
  const obj = c.checkObj(input);
  return {
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toPodCondition)),
    containerStatuses: c.readOpt(obj["containerStatuses"], x => c.readList(x, toContainerStatus)),
    ephemeralContainerStatuses: c.readOpt(obj["ephemeralContainerStatuses"], x => c.readList(x, toContainerStatus)),
    hostIP: c.readOpt(obj["hostIP"], c.checkStr),
    initContainerStatuses: c.readOpt(obj["initContainerStatuses"], x => c.readList(x, toContainerStatus)),
    message: c.readOpt(obj["message"], c.checkStr),
    nominatedNodeName: c.readOpt(obj["nominatedNodeName"], c.checkStr),
    phase: c.readOpt(obj["phase"], c.checkStr),
    podIP: c.readOpt(obj["podIP"], c.checkStr),
    podIPs: c.readOpt(obj["podIPs"], x => c.readList(x, toPodIP)),
    qosClass: c.readOpt(obj["qosClass"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    startTime: c.readOpt(obj["startTime"], c.toTime),
  }}
export function fromPodStatus(input: PodStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromPodCondition),
    containerStatuses: input.containerStatuses?.map(fromContainerStatus),
    ephemeralContainerStatuses: input.ephemeralContainerStatuses?.map(fromContainerStatus),
    initContainerStatuses: input.initContainerStatuses?.map(fromContainerStatus),
    podIPs: input.podIPs?.map(fromPodIP),
    startTime: input.startTime != null ? c.fromTime(input.startTime) : undefined,
  }}

/** PodCondition contains details for the current condition of this pod. */
export interface PodCondition {
  lastProbeTime?: c.Time | null;
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toPodCondition(input: c.JSONValue): PodCondition {
  const obj = c.checkObj(input);
  return {
    lastProbeTime: c.readOpt(obj["lastProbeTime"], c.toTime),
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromPodCondition(input: PodCondition): c.JSONValue {
  return {
    ...input,
    lastProbeTime: input.lastProbeTime != null ? c.fromTime(input.lastProbeTime) : undefined,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** IP address information for entries in the (plural) PodIPs field. Each entry includes:
   IP: An IP address allocated to the pod. Routable at least within the cluster. */
export interface PodIP {
  ip?: string | null;
}
export function toPodIP(input: c.JSONValue): PodIP {
  const obj = c.checkObj(input);
  return {
    ip: c.readOpt(obj["ip"], c.checkStr),
  }}
export function fromPodIP(input: PodIP): c.JSONValue {
  return {
    ...input,
  }}

/** PodList is a list of Pods. */
export interface PodList extends ListOf<Pod> {
  apiVersion?: "v1";
  kind?: "PodList";
};
export function toPodList(input: c.JSONValue): PodList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "PodList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toPod),
  }}

/** PodTemplate describes a template for creating copies of a predefined pod. */
export interface PodTemplate {
  apiVersion?: "v1";
  kind?: "PodTemplate";
  metadata?: MetaV1.ObjectMeta | null;
  template?: PodTemplateSpec | null;
}
export function toPodTemplate(input: c.JSONValue): PodTemplate & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "PodTemplate"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    template: c.readOpt(obj["template"], toPodTemplateSpec),
  }}
export function fromPodTemplate(input: PodTemplate): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "PodTemplate"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    template: input.template != null ? fromPodTemplateSpec(input.template) : undefined,
  }}

/** PodTemplateSpec describes the data a pod should have when created from a template */
export interface PodTemplateSpec {
  metadata?: MetaV1.ObjectMeta | null;
  spec?: PodSpec | null;
}
export function toPodTemplateSpec(input: c.JSONValue): PodTemplateSpec {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toPodSpec),
  }}
export function fromPodTemplateSpec(input: PodTemplateSpec): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromPodSpec(input.spec) : undefined,
  }}

/** PodTemplateList is a list of PodTemplates. */
export interface PodTemplateList extends ListOf<PodTemplate> {
  apiVersion?: "v1";
  kind?: "PodTemplateList";
};
export function toPodTemplateList(input: c.JSONValue): PodTemplateList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "PodTemplateList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toPodTemplate),
  }}

/** ReplicationController represents the configuration of a replication controller. */
export interface ReplicationController {
  apiVersion?: "v1";
  kind?: "ReplicationController";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: ReplicationControllerSpec | null;
  status?: ReplicationControllerStatus | null;
}
export function toReplicationController(input: c.JSONValue): ReplicationController & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "ReplicationController"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toReplicationControllerSpec),
    status: c.readOpt(obj["status"], toReplicationControllerStatus),
  }}
export function fromReplicationController(input: ReplicationController): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "ReplicationController"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromReplicationControllerSpec(input.spec) : undefined,
    status: input.status != null ? fromReplicationControllerStatus(input.status) : undefined,
  }}

/** ReplicationControllerSpec is the specification of a replication controller. */
export interface ReplicationControllerSpec {
  minReadySeconds?: number | null;
  replicas?: number | null;
  selector?: Record<string,string> | null;
  template?: PodTemplateSpec | null;
}
export function toReplicationControllerSpec(input: c.JSONValue): ReplicationControllerSpec {
  const obj = c.checkObj(input);
  return {
    minReadySeconds: c.readOpt(obj["minReadySeconds"], c.checkNum),
    replicas: c.readOpt(obj["replicas"], c.checkNum),
    selector: c.readOpt(obj["selector"], x => c.readMap(x, c.checkStr)),
    template: c.readOpt(obj["template"], toPodTemplateSpec),
  }}
export function fromReplicationControllerSpec(input: ReplicationControllerSpec): c.JSONValue {
  return {
    ...input,
    template: input.template != null ? fromPodTemplateSpec(input.template) : undefined,
  }}

/** ReplicationControllerStatus represents the current status of a replication controller. */
export interface ReplicationControllerStatus {
  availableReplicas?: number | null;
  conditions?: Array<ReplicationControllerCondition> | null;
  fullyLabeledReplicas?: number | null;
  observedGeneration?: number | null;
  readyReplicas?: number | null;
  replicas: number;
}
export function toReplicationControllerStatus(input: c.JSONValue): ReplicationControllerStatus {
  const obj = c.checkObj(input);
  return {
    availableReplicas: c.readOpt(obj["availableReplicas"], c.checkNum),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toReplicationControllerCondition)),
    fullyLabeledReplicas: c.readOpt(obj["fullyLabeledReplicas"], c.checkNum),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    readyReplicas: c.readOpt(obj["readyReplicas"], c.checkNum),
    replicas: c.checkNum(obj["replicas"]),
  }}
export function fromReplicationControllerStatus(input: ReplicationControllerStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromReplicationControllerCondition),
  }}

/** ReplicationControllerCondition describes the state of a replication controller at a certain point. */
export interface ReplicationControllerCondition {
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toReplicationControllerCondition(input: c.JSONValue): ReplicationControllerCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromReplicationControllerCondition(input: ReplicationControllerCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** ReplicationControllerList is a collection of replication controllers. */
export interface ReplicationControllerList extends ListOf<ReplicationController> {
  apiVersion?: "v1";
  kind?: "ReplicationControllerList";
};
export function toReplicationControllerList(input: c.JSONValue): ReplicationControllerList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "ReplicationControllerList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toReplicationController),
  }}

/** ResourceQuota sets aggregate quota restrictions enforced per namespace */
export interface ResourceQuota {
  apiVersion?: "v1";
  kind?: "ResourceQuota";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: ResourceQuotaSpec | null;
  status?: ResourceQuotaStatus | null;
}
export function toResourceQuota(input: c.JSONValue): ResourceQuota & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "ResourceQuota"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toResourceQuotaSpec),
    status: c.readOpt(obj["status"], toResourceQuotaStatus),
  }}
export function fromResourceQuota(input: ResourceQuota): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "ResourceQuota"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceQuotaSpec(input.spec) : undefined,
    status: input.status != null ? fromResourceQuotaStatus(input.status) : undefined,
  }}

/** ResourceQuotaSpec defines the desired hard limits to enforce for Quota. */
export interface ResourceQuotaSpec {
  hard?: Record<string,c.Quantity> | null;
  scopeSelector?: ScopeSelector | null;
  scopes?: Array<string> | null;
}
export function toResourceQuotaSpec(input: c.JSONValue): ResourceQuotaSpec {
  const obj = c.checkObj(input);
  return {
    hard: c.readOpt(obj["hard"], x => c.readMap(x, c.toQuantity)),
    scopeSelector: c.readOpt(obj["scopeSelector"], toScopeSelector),
    scopes: c.readOpt(obj["scopes"], x => c.readList(x, c.checkStr)),
  }}
export function fromResourceQuotaSpec(input: ResourceQuotaSpec): c.JSONValue {
  return {
    ...input,
    hard: c.writeMap(input.hard, c.fromQuantity),
    scopeSelector: input.scopeSelector != null ? fromScopeSelector(input.scopeSelector) : undefined,
  }}

/** A scope selector represents the AND of the selectors represented by the scoped-resource selector requirements. */
export interface ScopeSelector {
  matchExpressions?: Array<ScopedResourceSelectorRequirement> | null;
}
export function toScopeSelector(input: c.JSONValue): ScopeSelector {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toScopedResourceSelectorRequirement)),
  }}
export function fromScopeSelector(input: ScopeSelector): c.JSONValue {
  return {
    ...input,
    matchExpressions: input.matchExpressions?.map(fromScopedResourceSelectorRequirement),
  }}

/** A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator that relates the scope name and values. */
export interface ScopedResourceSelectorRequirement {
  operator: string;
  scopeName: string;
  values?: Array<string> | null;
}
export function toScopedResourceSelectorRequirement(input: c.JSONValue): ScopedResourceSelectorRequirement {
  const obj = c.checkObj(input);
  return {
    operator: c.checkStr(obj["operator"]),
    scopeName: c.checkStr(obj["scopeName"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function fromScopedResourceSelectorRequirement(input: ScopedResourceSelectorRequirement): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceQuotaStatus defines the enforced hard limits and observed use. */
export interface ResourceQuotaStatus {
  hard?: Record<string,c.Quantity> | null;
  used?: Record<string,c.Quantity> | null;
}
export function toResourceQuotaStatus(input: c.JSONValue): ResourceQuotaStatus {
  const obj = c.checkObj(input);
  return {
    hard: c.readOpt(obj["hard"], x => c.readMap(x, c.toQuantity)),
    used: c.readOpt(obj["used"], x => c.readMap(x, c.toQuantity)),
  }}
export function fromResourceQuotaStatus(input: ResourceQuotaStatus): c.JSONValue {
  return {
    ...input,
    hard: c.writeMap(input.hard, c.fromQuantity),
    used: c.writeMap(input.used, c.fromQuantity),
  }}

/** ResourceQuotaList is a list of ResourceQuota items. */
export interface ResourceQuotaList extends ListOf<ResourceQuota> {
  apiVersion?: "v1";
  kind?: "ResourceQuotaList";
};
export function toResourceQuotaList(input: c.JSONValue): ResourceQuotaList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "ResourceQuotaList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceQuota),
  }}

/** Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes. */
export interface Secret {
  apiVersion?: "v1";
  kind?: "Secret";
  data?: Record<string,string> | null;
  immutable?: boolean | null;
  metadata?: MetaV1.ObjectMeta | null;
  stringData?: Record<string,string> | null;
  type?: string | null;
}
export function toSecret(input: c.JSONValue): Secret & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "Secret"),
    data: c.readOpt(obj["data"], x => c.readMap(x, c.checkStr)),
    immutable: c.readOpt(obj["immutable"], c.checkBool),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    stringData: c.readOpt(obj["stringData"], x => c.readMap(x, c.checkStr)),
    type: c.readOpt(obj["type"], c.checkStr),
  }}
export function fromSecret(input: Secret): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "Secret"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
  }}

/** SecretList is a list of Secret. */
export interface SecretList extends ListOf<Secret> {
  apiVersion?: "v1";
  kind?: "SecretList";
};
export function toSecretList(input: c.JSONValue): SecretList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "SecretList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toSecret),
  }}

/** Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy. */
export interface Service {
  apiVersion?: "v1";
  kind?: "Service";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: ServiceSpec | null;
  status?: ServiceStatus | null;
}
export function toService(input: c.JSONValue): Service & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "Service"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toServiceSpec),
    status: c.readOpt(obj["status"], toServiceStatus),
  }}
export function fromService(input: Service): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "Service"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromServiceSpec(input.spec) : undefined,
    status: input.status != null ? fromServiceStatus(input.status) : undefined,
  }}

/** ServiceSpec describes the attributes that a user creates on a service. */
export interface ServiceSpec {
  clusterIP?: string | null;
  externalIPs?: Array<string> | null;
  externalName?: string | null;
  externalTrafficPolicy?: string | null;
  healthCheckNodePort?: number | null;
  ipFamily?: string | null;
  loadBalancerIP?: string | null;
  loadBalancerSourceRanges?: Array<string> | null;
  ports?: Array<ServicePort> | null;
  publishNotReadyAddresses?: boolean | null;
  selector?: Record<string,string> | null;
  sessionAffinity?: string | null;
  sessionAffinityConfig?: SessionAffinityConfig | null;
  topologyKeys?: Array<string> | null;
  type?: string | null;
}
export function toServiceSpec(input: c.JSONValue): ServiceSpec {
  const obj = c.checkObj(input);
  return {
    clusterIP: c.readOpt(obj["clusterIP"], c.checkStr),
    externalIPs: c.readOpt(obj["externalIPs"], x => c.readList(x, c.checkStr)),
    externalName: c.readOpt(obj["externalName"], c.checkStr),
    externalTrafficPolicy: c.readOpt(obj["externalTrafficPolicy"], c.checkStr),
    healthCheckNodePort: c.readOpt(obj["healthCheckNodePort"], c.checkNum),
    ipFamily: c.readOpt(obj["ipFamily"], c.checkStr),
    loadBalancerIP: c.readOpt(obj["loadBalancerIP"], c.checkStr),
    loadBalancerSourceRanges: c.readOpt(obj["loadBalancerSourceRanges"], x => c.readList(x, c.checkStr)),
    ports: c.readOpt(obj["ports"], x => c.readList(x, toServicePort)),
    publishNotReadyAddresses: c.readOpt(obj["publishNotReadyAddresses"], c.checkBool),
    selector: c.readOpt(obj["selector"], x => c.readMap(x, c.checkStr)),
    sessionAffinity: c.readOpt(obj["sessionAffinity"], c.checkStr),
    sessionAffinityConfig: c.readOpt(obj["sessionAffinityConfig"], toSessionAffinityConfig),
    topologyKeys: c.readOpt(obj["topologyKeys"], x => c.readList(x, c.checkStr)),
    type: c.readOpt(obj["type"], c.checkStr),
  }}
export function fromServiceSpec(input: ServiceSpec): c.JSONValue {
  return {
    ...input,
    ports: input.ports?.map(fromServicePort),
    sessionAffinityConfig: input.sessionAffinityConfig != null ? fromSessionAffinityConfig(input.sessionAffinityConfig) : undefined,
  }}

/** ServicePort contains information on service's port. */
export interface ServicePort {
  appProtocol?: string | null;
  name?: string | null;
  nodePort?: number | null;
  port: number;
  protocol?: string | null;
  targetPort?: c.IntOrString | null;
}
export function toServicePort(input: c.JSONValue): ServicePort {
  const obj = c.checkObj(input);
  return {
    appProtocol: c.readOpt(obj["appProtocol"], c.checkStr),
    name: c.readOpt(obj["name"], c.checkStr),
    nodePort: c.readOpt(obj["nodePort"], c.checkNum),
    port: c.checkNum(obj["port"]),
    protocol: c.readOpt(obj["protocol"], c.checkStr),
    targetPort: c.readOpt(obj["targetPort"], c.toIntOrString),
  }}
export function fromServicePort(input: ServicePort): c.JSONValue {
  return {
    ...input,
  }}

/** SessionAffinityConfig represents the configurations of session affinity. */
export interface SessionAffinityConfig {
  clientIP?: ClientIPConfig | null;
}
export function toSessionAffinityConfig(input: c.JSONValue): SessionAffinityConfig {
  const obj = c.checkObj(input);
  return {
    clientIP: c.readOpt(obj["clientIP"], toClientIPConfig),
  }}
export function fromSessionAffinityConfig(input: SessionAffinityConfig): c.JSONValue {
  return {
    ...input,
    clientIP: input.clientIP != null ? fromClientIPConfig(input.clientIP) : undefined,
  }}

/** ServiceStatus represents the current status of a service. */
export interface ServiceStatus {
  loadBalancer?: LoadBalancerStatus | null;
}
export function toServiceStatus(input: c.JSONValue): ServiceStatus {
  const obj = c.checkObj(input);
  return {
    loadBalancer: c.readOpt(obj["loadBalancer"], toLoadBalancerStatus),
  }}
export function fromServiceStatus(input: ServiceStatus): c.JSONValue {
  return {
    ...input,
    loadBalancer: input.loadBalancer != null ? fromLoadBalancerStatus(input.loadBalancer) : undefined,
  }}

/** ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets */
export interface ServiceAccount {
  apiVersion?: "v1";
  kind?: "ServiceAccount";
  automountServiceAccountToken?: boolean | null;
  imagePullSecrets?: Array<LocalObjectReference> | null;
  metadata?: MetaV1.ObjectMeta | null;
  secrets?: Array<ObjectReference> | null;
}
export function toServiceAccount(input: c.JSONValue): ServiceAccount & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "ServiceAccount"),
    automountServiceAccountToken: c.readOpt(obj["automountServiceAccountToken"], c.checkBool),
    imagePullSecrets: c.readOpt(obj["imagePullSecrets"], x => c.readList(x, toLocalObjectReference)),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    secrets: c.readOpt(obj["secrets"], x => c.readList(x, toObjectReference)),
  }}
export function fromServiceAccount(input: ServiceAccount): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "v1", "ServiceAccount"),
    ...input,
    imagePullSecrets: input.imagePullSecrets?.map(fromLocalObjectReference),
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    secrets: input.secrets?.map(fromObjectReference),
  }}

/** ServiceAccountList is a list of ServiceAccount objects */
export interface ServiceAccountList extends ListOf<ServiceAccount> {
  apiVersion?: "v1";
  kind?: "ServiceAccountList";
};
export function toServiceAccountList(input: c.JSONValue): ServiceAccountList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "ServiceAccountList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toServiceAccount),
  }}

/** ServiceList holds a list of services. */
export interface ServiceList extends ListOf<Service> {
  apiVersion?: "v1";
  kind?: "ServiceList";
};
export function toServiceList(input: c.JSONValue): ServiceList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "v1", "ServiceList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toService),
  }}

/** A topology selector requirement is a selector that matches given label. This is an alpha feature and may change in the future. */
export interface TopologySelectorLabelRequirement {
  key: string;
  values: Array<string>;
}
export function toTopologySelectorLabelRequirement(input: c.JSONValue): TopologySelectorLabelRequirement {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    values: c.readList(obj["values"], c.checkStr),
  }}
export function fromTopologySelectorLabelRequirement(input: TopologySelectorLabelRequirement): c.JSONValue {
  return {
    ...input,
  }}

/** A topology selector term represents the result of label queries. A null or empty topology selector term matches no objects. The requirements of them are ANDed. It provides a subset of functionality as NodeSelectorTerm. This is an alpha feature and may change in the future. */
export interface TopologySelectorTerm {
  matchLabelExpressions?: Array<TopologySelectorLabelRequirement> | null;
}
export function toTopologySelectorTerm(input: c.JSONValue): TopologySelectorTerm {
  const obj = c.checkObj(input);
  return {
    matchLabelExpressions: c.readOpt(obj["matchLabelExpressions"], x => c.readList(x, toTopologySelectorLabelRequirement)),
  }}
export function fromTopologySelectorTerm(input: TopologySelectorTerm): c.JSONValue {
  return {
    ...input,
    matchLabelExpressions: input.matchLabelExpressions?.map(fromTopologySelectorLabelRequirement),
  }}
