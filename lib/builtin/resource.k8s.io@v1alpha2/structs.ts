// Autogenerated Schema file for ResourceV1alpha2
import * as c from "../../common.ts";

import * as CoreV1 from "../core@v1/structs.ts";
import * as MetaV1 from "../meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** AllocationResult contains attributes of an allocated resource. */
export interface AllocationResult {
  availableOnNodes?: CoreV1.NodeSelector | null;
  resourceHandles?: Array<ResourceHandle> | null;
  shareable?: boolean | null;
}
export function toAllocationResult(input: c.JSONValue): AllocationResult {
  const obj = c.checkObj(input);
  return {
    availableOnNodes: c.readOpt(obj["availableOnNodes"], CoreV1.toNodeSelector),
    resourceHandles: c.readOpt(obj["resourceHandles"], x => c.readList(x, toResourceHandle)),
    shareable: c.readOpt(obj["shareable"], c.checkBool),
  }}
export function fromAllocationResult(input: AllocationResult): c.JSONValue {
  return {
    ...input,
    availableOnNodes: input.availableOnNodes != null ? CoreV1.fromNodeSelector(input.availableOnNodes) : undefined,
    resourceHandles: input.resourceHandles?.map(fromResourceHandle),
  }}

/** ResourceHandle holds opaque resource data for processing by a specific kubelet plugin. */
export interface ResourceHandle {
  data?: string | null;
  driverName?: string | null;
}
export function toResourceHandle(input: c.JSONValue): ResourceHandle {
  const obj = c.checkObj(input);
  return {
    data: c.readOpt(obj["data"], c.checkStr),
    driverName: c.readOpt(obj["driverName"], c.checkStr),
  }}
export function fromResourceHandle(input: ResourceHandle): c.JSONValue {
  return {
    ...input,
  }}

/** PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use "WaitForFirstConsumer" allocation mode.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface PodSchedulingContext {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "PodSchedulingContext";
  metadata?: MetaV1.ObjectMeta | null;
  spec: PodSchedulingContextSpec;
  status?: PodSchedulingContextStatus | null;
}
export function toPodSchedulingContext(input: c.JSONValue): PodSchedulingContext & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "PodSchedulingContext"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toPodSchedulingContextSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toPodSchedulingContextStatus),
  }}
export function fromPodSchedulingContext(input: PodSchedulingContext): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha2", "PodSchedulingContext"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromPodSchedulingContextSpec(input.spec) : undefined,
    status: input.status != null ? fromPodSchedulingContextStatus(input.status) : undefined,
  }}

/** PodSchedulingContextSpec describes where resources for the Pod are needed. */
export interface PodSchedulingContextSpec {
  potentialNodes?: Array<string> | null;
  selectedNode?: string | null;
}
export function toPodSchedulingContextSpec(input: c.JSONValue): PodSchedulingContextSpec {
  const obj = c.checkObj(input);
  return {
    potentialNodes: c.readOpt(obj["potentialNodes"], x => c.readList(x, c.checkStr)),
    selectedNode: c.readOpt(obj["selectedNode"], c.checkStr),
  }}
export function fromPodSchedulingContextSpec(input: PodSchedulingContextSpec): c.JSONValue {
  return {
    ...input,
  }}

/** PodSchedulingContextStatus describes where resources for the Pod can be allocated. */
export interface PodSchedulingContextStatus {
  resourceClaims?: Array<ResourceClaimSchedulingStatus> | null;
}
export function toPodSchedulingContextStatus(input: c.JSONValue): PodSchedulingContextStatus {
  const obj = c.checkObj(input);
  return {
    resourceClaims: c.readOpt(obj["resourceClaims"], x => c.readList(x, toResourceClaimSchedulingStatus)),
  }}
export function fromPodSchedulingContextStatus(input: PodSchedulingContextStatus): c.JSONValue {
  return {
    ...input,
    resourceClaims: input.resourceClaims?.map(fromResourceClaimSchedulingStatus),
  }}

/** ResourceClaimSchedulingStatus contains information about one particular ResourceClaim with "WaitForFirstConsumer" allocation mode. */
export interface ResourceClaimSchedulingStatus {
  name?: string | null;
  unsuitableNodes?: Array<string> | null;
}
export function toResourceClaimSchedulingStatus(input: c.JSONValue): ResourceClaimSchedulingStatus {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    unsuitableNodes: c.readOpt(obj["unsuitableNodes"], x => c.readList(x, c.checkStr)),
  }}
export function fromResourceClaimSchedulingStatus(input: ResourceClaimSchedulingStatus): c.JSONValue {
  return {
    ...input,
  }}

/** PodSchedulingContextList is a collection of Pod scheduling objects. */
export interface PodSchedulingContextList extends ListOf<PodSchedulingContext> {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "PodSchedulingContextList";
};
export function toPodSchedulingContextList(input: c.JSONValue): PodSchedulingContextList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "PodSchedulingContextList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toPodSchedulingContext),
  }}

/** ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface ResourceClaim {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClaim";
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimSpec;
  status?: ResourceClaimStatus | null;
}
export function toResourceClaim(input: c.JSONValue): ResourceClaim & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClaim"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toResourceClaimStatus),
  }}
export function fromResourceClaim(input: ResourceClaim): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha2", "ResourceClaim"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimSpec(input.spec) : undefined,
    status: input.status != null ? fromResourceClaimStatus(input.status) : undefined,
  }}

/** ResourceClaimSpec defines how a resource is to be allocated. */
export interface ResourceClaimSpec {
  allocationMode?: string | null;
  parametersRef?: ResourceClaimParametersReference | null;
  resourceClassName: string;
}
export function toResourceClaimSpec(input: c.JSONValue): ResourceClaimSpec {
  const obj = c.checkObj(input);
  return {
    allocationMode: c.readOpt(obj["allocationMode"], c.checkStr),
    parametersRef: c.readOpt(obj["parametersRef"], toResourceClaimParametersReference),
    resourceClassName: c.checkStr(obj["resourceClassName"]),
  }}
export function fromResourceClaimSpec(input: ResourceClaimSpec): c.JSONValue {
  return {
    ...input,
    parametersRef: input.parametersRef != null ? fromResourceClaimParametersReference(input.parametersRef) : undefined,
  }}

/** ResourceClaimParametersReference contains enough information to let you locate the parameters for a ResourceClaim. The object must be in the same namespace as the ResourceClaim. */
export interface ResourceClaimParametersReference {
  apiGroup?: string | null;
  kind: string;
  name: string;
}
export function toResourceClaimParametersReference(input: c.JSONValue): ResourceClaimParametersReference {
  const obj = c.checkObj(input);
  return {
    apiGroup: c.readOpt(obj["apiGroup"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
  }}
export function fromResourceClaimParametersReference(input: ResourceClaimParametersReference): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceClaimStatus tracks whether the resource has been allocated and what the resulting attributes are. */
export interface ResourceClaimStatus {
  allocation?: AllocationResult | null;
  deallocationRequested?: boolean | null;
  driverName?: string | null;
  reservedFor?: Array<ResourceClaimConsumerReference> | null;
}
export function toResourceClaimStatus(input: c.JSONValue): ResourceClaimStatus {
  const obj = c.checkObj(input);
  return {
    allocation: c.readOpt(obj["allocation"], toAllocationResult),
    deallocationRequested: c.readOpt(obj["deallocationRequested"], c.checkBool),
    driverName: c.readOpt(obj["driverName"], c.checkStr),
    reservedFor: c.readOpt(obj["reservedFor"], x => c.readList(x, toResourceClaimConsumerReference)),
  }}
export function fromResourceClaimStatus(input: ResourceClaimStatus): c.JSONValue {
  return {
    ...input,
    allocation: input.allocation != null ? fromAllocationResult(input.allocation) : undefined,
    reservedFor: input.reservedFor?.map(fromResourceClaimConsumerReference),
  }}

/** ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim. */
export interface ResourceClaimConsumerReference {
  apiGroup?: string | null;
  name: string;
  resource: string;
  uid: string;
}
export function toResourceClaimConsumerReference(input: c.JSONValue): ResourceClaimConsumerReference {
  const obj = c.checkObj(input);
  return {
    apiGroup: c.readOpt(obj["apiGroup"], c.checkStr),
    name: c.checkStr(obj["name"]),
    resource: c.checkStr(obj["resource"]),
    uid: c.checkStr(obj["uid"]),
  }}
export function fromResourceClaimConsumerReference(input: ResourceClaimConsumerReference): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceClaimList is a collection of claims. */
export interface ResourceClaimList extends ListOf<ResourceClaim> {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClaimList";
};
export function toResourceClaimList(input: c.JSONValue): ResourceClaimList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClaimList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClaim),
  }}

/** ResourceClaimTemplate is used to produce ResourceClaim objects. */
export interface ResourceClaimTemplate {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClaimTemplate";
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimTemplateSpec;
}
export function toResourceClaimTemplate(input: c.JSONValue): ResourceClaimTemplate & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClaimTemplate"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimTemplateSpec(obj["spec"]),
  }}
export function fromResourceClaimTemplate(input: ResourceClaimTemplate): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha2", "ResourceClaimTemplate"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimTemplateSpec(input.spec) : undefined,
  }}

/** ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim. */
export interface ResourceClaimTemplateSpec {
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimSpec;
}
export function toResourceClaimTemplateSpec(input: c.JSONValue): ResourceClaimTemplateSpec {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimSpec(obj["spec"]),
  }}
export function fromResourceClaimTemplateSpec(input: ResourceClaimTemplateSpec): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimSpec(input.spec) : undefined,
  }}

/** ResourceClaimTemplateList is a collection of claim templates. */
export interface ResourceClaimTemplateList extends ListOf<ResourceClaimTemplate> {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClaimTemplateList";
};
export function toResourceClaimTemplateList(input: c.JSONValue): ResourceClaimTemplateList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClaimTemplateList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClaimTemplate),
  }}

/** ResourceClass is used by administrators to influence how resources are allocated.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface ResourceClass {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClass";
  driverName: string;
  metadata?: MetaV1.ObjectMeta | null;
  parametersRef?: ResourceClassParametersReference | null;
  suitableNodes?: CoreV1.NodeSelector | null;
}
export function toResourceClass(input: c.JSONValue): ResourceClass & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClass"),
    driverName: c.checkStr(obj["driverName"]),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    parametersRef: c.readOpt(obj["parametersRef"], toResourceClassParametersReference),
    suitableNodes: c.readOpt(obj["suitableNodes"], CoreV1.toNodeSelector),
  }}
export function fromResourceClass(input: ResourceClass): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha2", "ResourceClass"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    parametersRef: input.parametersRef != null ? fromResourceClassParametersReference(input.parametersRef) : undefined,
    suitableNodes: input.suitableNodes != null ? CoreV1.fromNodeSelector(input.suitableNodes) : undefined,
  }}

/** ResourceClassParametersReference contains enough information to let you locate the parameters for a ResourceClass. */
export interface ResourceClassParametersReference {
  apiGroup?: string | null;
  kind: string;
  name: string;
  namespace?: string | null;
}
export function toResourceClassParametersReference(input: c.JSONValue): ResourceClassParametersReference {
  const obj = c.checkObj(input);
  return {
    apiGroup: c.readOpt(obj["apiGroup"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
  }}
export function fromResourceClassParametersReference(input: ResourceClassParametersReference): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceClassList is a collection of classes. */
export interface ResourceClassList extends ListOf<ResourceClass> {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClassList";
};
export function toResourceClassList(input: c.JSONValue): ResourceClassList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClassList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClass),
  }}
