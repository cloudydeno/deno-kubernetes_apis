// Autogenerated Schema file for ResourceV1alpha2
import * as c from "../../common.ts";

import * as CoreV1 from "../core@v1/structs.ts";
import * as MetaV1 from "../meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** AllocationResult contains attributes of an allocated resource. */
export interface AllocationResult {
  availableOnNodes?: CoreV1.NodeSelector | null;
  resourceHandles?: Array<ResourceHandle> | null;
  shareable?: boolean | null;
}
export function toAllocationResult(input: c.JSONValue): AllocationResult {
  const obj = c.checkObj(input);
  return {
    availableOnNodes: c.readOpt(obj["availableOnNodes"], CoreV1.toNodeSelector),
    resourceHandles: c.readOpt(obj["resourceHandles"], x => c.readList(x, toResourceHandle)),
    shareable: c.readOpt(obj["shareable"], c.checkBool),
  }}
export function fromAllocationResult(input: AllocationResult): c.JSONValue {
  return {
    ...input,
    availableOnNodes: input.availableOnNodes != null ? CoreV1.fromNodeSelector(input.availableOnNodes) : undefined,
    resourceHandles: input.resourceHandles?.map(fromResourceHandle),
  }}

/** ResourceHandle holds opaque resource data for processing by a specific kubelet plugin. */
export interface ResourceHandle {
  data?: string | null;
  driverName?: string | null;
  structuredData?: StructuredResourceHandle | null;
}
export function toResourceHandle(input: c.JSONValue): ResourceHandle {
  const obj = c.checkObj(input);
  return {
    data: c.readOpt(obj["data"], c.checkStr),
    driverName: c.readOpt(obj["driverName"], c.checkStr),
    structuredData: c.readOpt(obj["structuredData"], toStructuredResourceHandle),
  }}
export function fromResourceHandle(input: ResourceHandle): c.JSONValue {
  return {
    ...input,
    structuredData: input.structuredData != null ? fromStructuredResourceHandle(input.structuredData) : undefined,
  }}

/** StructuredResourceHandle is the in-tree representation of the allocation result. */
export interface StructuredResourceHandle {
  nodeName?: string | null;
  results: Array<DriverAllocationResult>;
  vendorClaimParameters?: c.JSONValue | null;
  vendorClassParameters?: c.JSONValue | null;
}
export function toStructuredResourceHandle(input: c.JSONValue): StructuredResourceHandle {
  const obj = c.checkObj(input);
  return {
    nodeName: c.readOpt(obj["nodeName"], c.checkStr),
    results: c.readList(obj["results"], toDriverAllocationResult),
    vendorClaimParameters: c.readOpt(obj["vendorClaimParameters"], c.identity),
    vendorClassParameters: c.readOpt(obj["vendorClassParameters"], c.identity),
  }}
export function fromStructuredResourceHandle(input: StructuredResourceHandle): c.JSONValue {
  return {
    ...input,
    results: input.results?.map(fromDriverAllocationResult),
  }}

/** DriverAllocationResult contains vendor parameters and the allocation result for one request. */
export interface DriverAllocationResult {
  namedResources?: NamedResourcesAllocationResult | null;
  vendorRequestParameters?: c.JSONValue | null;
}
export function toDriverAllocationResult(input: c.JSONValue): DriverAllocationResult {
  const obj = c.checkObj(input);
  return {
    namedResources: c.readOpt(obj["namedResources"], toNamedResourcesAllocationResult),
    vendorRequestParameters: c.readOpt(obj["vendorRequestParameters"], c.identity),
  }}
export function fromDriverAllocationResult(input: DriverAllocationResult): c.JSONValue {
  return {
    ...input,
    namedResources: input.namedResources != null ? fromNamedResourcesAllocationResult(input.namedResources) : undefined,
  }}

/** NamedResourcesAllocationResult is used in AllocationResultModel. */
export interface NamedResourcesAllocationResult {
  name: string;
}
export function toNamedResourcesAllocationResult(input: c.JSONValue): NamedResourcesAllocationResult {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
  }}
export function fromNamedResourcesAllocationResult(input: NamedResourcesAllocationResult): c.JSONValue {
  return {
    ...input,
  }}

/** DriverRequests describes all resources that are needed from one particular driver. */
export interface DriverRequests {
  driverName?: string | null;
  requests?: Array<ResourceRequest> | null;
  vendorParameters?: c.JSONValue | null;
}
export function toDriverRequests(input: c.JSONValue): DriverRequests {
  const obj = c.checkObj(input);
  return {
    driverName: c.readOpt(obj["driverName"], c.checkStr),
    requests: c.readOpt(obj["requests"], x => c.readList(x, toResourceRequest)),
    vendorParameters: c.readOpt(obj["vendorParameters"], c.identity),
  }}
export function fromDriverRequests(input: DriverRequests): c.JSONValue {
  return {
    ...input,
    requests: input.requests?.map(fromResourceRequest),
  }}

/** ResourceRequest is a request for resources from one particular driver. */
export interface ResourceRequest {
  namedResources?: NamedResourcesRequest | null;
  vendorParameters?: c.JSONValue | null;
}
export function toResourceRequest(input: c.JSONValue): ResourceRequest {
  const obj = c.checkObj(input);
  return {
    namedResources: c.readOpt(obj["namedResources"], toNamedResourcesRequest),
    vendorParameters: c.readOpt(obj["vendorParameters"], c.identity),
  }}
export function fromResourceRequest(input: ResourceRequest): c.JSONValue {
  return {
    ...input,
    namedResources: input.namedResources != null ? fromNamedResourcesRequest(input.namedResources) : undefined,
  }}

/** NamedResourcesRequest is used in ResourceRequestModel. */
export interface NamedResourcesRequest {
  selector: string;
}
export function toNamedResourcesRequest(input: c.JSONValue): NamedResourcesRequest {
  const obj = c.checkObj(input);
  return {
    selector: c.checkStr(obj["selector"]),
  }}
export function fromNamedResourcesRequest(input: NamedResourcesRequest): c.JSONValue {
  return {
    ...input,
  }}

/** NamedResourcesAttribute is a combination of an attribute name and its value. */
export interface NamedResourcesAttribute {
  bool?: boolean | null;
  int?: number | null;
  intSlice?: NamedResourcesIntSlice | null;
  name: string;
  quantity?: c.Quantity | null;
  string?: string | null;
  stringSlice?: NamedResourcesStringSlice | null;
  version?: string | null;
}
export function toNamedResourcesAttribute(input: c.JSONValue): NamedResourcesAttribute {
  const obj = c.checkObj(input);
  return {
    bool: c.readOpt(obj["bool"], c.checkBool),
    int: c.readOpt(obj["int"], c.checkNum),
    intSlice: c.readOpt(obj["intSlice"], toNamedResourcesIntSlice),
    name: c.checkStr(obj["name"]),
    quantity: c.readOpt(obj["quantity"], c.toQuantity),
    string: c.readOpt(obj["string"], c.checkStr),
    stringSlice: c.readOpt(obj["stringSlice"], toNamedResourcesStringSlice),
    version: c.readOpt(obj["version"], c.checkStr),
  }}
export function fromNamedResourcesAttribute(input: NamedResourcesAttribute): c.JSONValue {
  return {
    ...input,
    intSlice: input.intSlice != null ? fromNamedResourcesIntSlice(input.intSlice) : undefined,
    quantity: input.quantity != null ? c.fromQuantity(input.quantity) : undefined,
    stringSlice: input.stringSlice != null ? fromNamedResourcesStringSlice(input.stringSlice) : undefined,
  }}

/** NamedResourcesIntSlice contains a slice of 64-bit integers. */
export interface NamedResourcesIntSlice {
  ints: Array<number>;
}
export function toNamedResourcesIntSlice(input: c.JSONValue): NamedResourcesIntSlice {
  const obj = c.checkObj(input);
  return {
    ints: c.readList(obj["ints"], c.checkNum),
  }}
export function fromNamedResourcesIntSlice(input: NamedResourcesIntSlice): c.JSONValue {
  return {
    ...input,
  }}

/** NamedResourcesStringSlice contains a slice of strings. */
export interface NamedResourcesStringSlice {
  strings: Array<string>;
}
export function toNamedResourcesStringSlice(input: c.JSONValue): NamedResourcesStringSlice {
  const obj = c.checkObj(input);
  return {
    strings: c.readList(obj["strings"], c.checkStr),
  }}
export function fromNamedResourcesStringSlice(input: NamedResourcesStringSlice): c.JSONValue {
  return {
    ...input,
  }}

/** NamedResourcesFilter is used in ResourceFilterModel. */
export interface NamedResourcesFilter {
  selector: string;
}
export function toNamedResourcesFilter(input: c.JSONValue): NamedResourcesFilter {
  const obj = c.checkObj(input);
  return {
    selector: c.checkStr(obj["selector"]),
  }}
export function fromNamedResourcesFilter(input: NamedResourcesFilter): c.JSONValue {
  return {
    ...input,
  }}

/** NamedResourcesInstance represents one individual hardware instance that can be selected based on its attributes. */
export interface NamedResourcesInstance {
  attributes?: Array<NamedResourcesAttribute> | null;
  name: string;
}
export function toNamedResourcesInstance(input: c.JSONValue): NamedResourcesInstance {
  const obj = c.checkObj(input);
  return {
    attributes: c.readOpt(obj["attributes"], x => c.readList(x, toNamedResourcesAttribute)),
    name: c.checkStr(obj["name"]),
  }}
export function fromNamedResourcesInstance(input: NamedResourcesInstance): c.JSONValue {
  return {
    ...input,
    attributes: input.attributes?.map(fromNamedResourcesAttribute),
  }}

/** NamedResourcesResources is used in ResourceModel. */
export interface NamedResourcesResources {
  instances: Array<NamedResourcesInstance>;
}
export function toNamedResourcesResources(input: c.JSONValue): NamedResourcesResources {
  const obj = c.checkObj(input);
  return {
    instances: c.readList(obj["instances"], toNamedResourcesInstance),
  }}
export function fromNamedResourcesResources(input: NamedResourcesResources): c.JSONValue {
  return {
    ...input,
    instances: input.instances?.map(fromNamedResourcesInstance),
  }}

/** PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use "WaitForFirstConsumer" allocation mode.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface PodSchedulingContext {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "PodSchedulingContext";
  metadata?: MetaV1.ObjectMeta | null;
  spec: PodSchedulingContextSpec;
  status?: PodSchedulingContextStatus | null;
}
export function toPodSchedulingContext(input: c.JSONValue): PodSchedulingContext & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "PodSchedulingContext"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toPodSchedulingContextSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toPodSchedulingContextStatus),
  }}
export function fromPodSchedulingContext(input: PodSchedulingContext): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha2", "PodSchedulingContext"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromPodSchedulingContextSpec(input.spec) : undefined,
    status: input.status != null ? fromPodSchedulingContextStatus(input.status) : undefined,
  }}

/** PodSchedulingContextSpec describes where resources for the Pod are needed. */
export interface PodSchedulingContextSpec {
  potentialNodes?: Array<string> | null;
  selectedNode?: string | null;
}
export function toPodSchedulingContextSpec(input: c.JSONValue): PodSchedulingContextSpec {
  const obj = c.checkObj(input);
  return {
    potentialNodes: c.readOpt(obj["potentialNodes"], x => c.readList(x, c.checkStr)),
    selectedNode: c.readOpt(obj["selectedNode"], c.checkStr),
  }}
export function fromPodSchedulingContextSpec(input: PodSchedulingContextSpec): c.JSONValue {
  return {
    ...input,
  }}

/** PodSchedulingContextStatus describes where resources for the Pod can be allocated. */
export interface PodSchedulingContextStatus {
  resourceClaims?: Array<ResourceClaimSchedulingStatus> | null;
}
export function toPodSchedulingContextStatus(input: c.JSONValue): PodSchedulingContextStatus {
  const obj = c.checkObj(input);
  return {
    resourceClaims: c.readOpt(obj["resourceClaims"], x => c.readList(x, toResourceClaimSchedulingStatus)),
  }}
export function fromPodSchedulingContextStatus(input: PodSchedulingContextStatus): c.JSONValue {
  return {
    ...input,
    resourceClaims: input.resourceClaims?.map(fromResourceClaimSchedulingStatus),
  }}

/** ResourceClaimSchedulingStatus contains information about one particular ResourceClaim with "WaitForFirstConsumer" allocation mode. */
export interface ResourceClaimSchedulingStatus {
  name?: string | null;
  unsuitableNodes?: Array<string> | null;
}
export function toResourceClaimSchedulingStatus(input: c.JSONValue): ResourceClaimSchedulingStatus {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    unsuitableNodes: c.readOpt(obj["unsuitableNodes"], x => c.readList(x, c.checkStr)),
  }}
export function fromResourceClaimSchedulingStatus(input: ResourceClaimSchedulingStatus): c.JSONValue {
  return {
    ...input,
  }}

/** PodSchedulingContextList is a collection of Pod scheduling objects. */
export interface PodSchedulingContextList extends ListOf<PodSchedulingContext> {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "PodSchedulingContextList";
};
export function toPodSchedulingContextList(input: c.JSONValue): PodSchedulingContextList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "PodSchedulingContextList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toPodSchedulingContext),
  }}

/** ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface ResourceClaim {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClaim";
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimSpec;
  status?: ResourceClaimStatus | null;
}
export function toResourceClaim(input: c.JSONValue): ResourceClaim & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClaim"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toResourceClaimStatus),
  }}
export function fromResourceClaim(input: ResourceClaim): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha2", "ResourceClaim"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimSpec(input.spec) : undefined,
    status: input.status != null ? fromResourceClaimStatus(input.status) : undefined,
  }}

/** ResourceClaimSpec defines how a resource is to be allocated. */
export interface ResourceClaimSpec {
  allocationMode?: string | null;
  parametersRef?: ResourceClaimParametersReference | null;
  resourceClassName: string;
}
export function toResourceClaimSpec(input: c.JSONValue): ResourceClaimSpec {
  const obj = c.checkObj(input);
  return {
    allocationMode: c.readOpt(obj["allocationMode"], c.checkStr),
    parametersRef: c.readOpt(obj["parametersRef"], toResourceClaimParametersReference),
    resourceClassName: c.checkStr(obj["resourceClassName"]),
  }}
export function fromResourceClaimSpec(input: ResourceClaimSpec): c.JSONValue {
  return {
    ...input,
    parametersRef: input.parametersRef != null ? fromResourceClaimParametersReference(input.parametersRef) : undefined,
  }}

/** ResourceClaimParametersReference contains enough information to let you locate the parameters for a ResourceClaim. The object must be in the same namespace as the ResourceClaim. */
export interface ResourceClaimParametersReference {
  apiGroup?: string | null;
  kind: string;
  name: string;
}
export function toResourceClaimParametersReference(input: c.JSONValue): ResourceClaimParametersReference {
  const obj = c.checkObj(input);
  return {
    apiGroup: c.readOpt(obj["apiGroup"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
  }}
export function fromResourceClaimParametersReference(input: ResourceClaimParametersReference): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceClaimStatus tracks whether the resource has been allocated and what the resulting attributes are. */
export interface ResourceClaimStatus {
  allocation?: AllocationResult | null;
  deallocationRequested?: boolean | null;
  driverName?: string | null;
  reservedFor?: Array<ResourceClaimConsumerReference> | null;
}
export function toResourceClaimStatus(input: c.JSONValue): ResourceClaimStatus {
  const obj = c.checkObj(input);
  return {
    allocation: c.readOpt(obj["allocation"], toAllocationResult),
    deallocationRequested: c.readOpt(obj["deallocationRequested"], c.checkBool),
    driverName: c.readOpt(obj["driverName"], c.checkStr),
    reservedFor: c.readOpt(obj["reservedFor"], x => c.readList(x, toResourceClaimConsumerReference)),
  }}
export function fromResourceClaimStatus(input: ResourceClaimStatus): c.JSONValue {
  return {
    ...input,
    allocation: input.allocation != null ? fromAllocationResult(input.allocation) : undefined,
    reservedFor: input.reservedFor?.map(fromResourceClaimConsumerReference),
  }}

/** ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim. */
export interface ResourceClaimConsumerReference {
  apiGroup?: string | null;
  name: string;
  resource: string;
  uid: string;
}
export function toResourceClaimConsumerReference(input: c.JSONValue): ResourceClaimConsumerReference {
  const obj = c.checkObj(input);
  return {
    apiGroup: c.readOpt(obj["apiGroup"], c.checkStr),
    name: c.checkStr(obj["name"]),
    resource: c.checkStr(obj["resource"]),
    uid: c.checkStr(obj["uid"]),
  }}
export function fromResourceClaimConsumerReference(input: ResourceClaimConsumerReference): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceClaimList is a collection of claims. */
export interface ResourceClaimList extends ListOf<ResourceClaim> {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClaimList";
};
export function toResourceClaimList(input: c.JSONValue): ResourceClaimList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClaimList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClaim),
  }}

/** ResourceClaimParameters defines resource requests for a ResourceClaim in an in-tree format understood by Kubernetes. */
export interface ResourceClaimParameters {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClaimParameters";
  driverRequests?: Array<DriverRequests> | null;
  generatedFrom?: ResourceClaimParametersReference | null;
  metadata?: MetaV1.ObjectMeta | null;
  shareable?: boolean | null;
}
export function toResourceClaimParameters(input: c.JSONValue): ResourceClaimParameters & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClaimParameters"),
    driverRequests: c.readOpt(obj["driverRequests"], x => c.readList(x, toDriverRequests)),
    generatedFrom: c.readOpt(obj["generatedFrom"], toResourceClaimParametersReference),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    shareable: c.readOpt(obj["shareable"], c.checkBool),
  }}
export function fromResourceClaimParameters(input: ResourceClaimParameters): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha2", "ResourceClaimParameters"),
    ...input,
    driverRequests: input.driverRequests?.map(fromDriverRequests),
    generatedFrom: input.generatedFrom != null ? fromResourceClaimParametersReference(input.generatedFrom) : undefined,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
  }}

/** ResourceClaimParametersList is a collection of ResourceClaimParameters. */
export interface ResourceClaimParametersList extends ListOf<ResourceClaimParameters> {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClaimParametersList";
};
export function toResourceClaimParametersList(input: c.JSONValue): ResourceClaimParametersList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClaimParametersList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClaimParameters),
  }}

/** ResourceClaimTemplate is used to produce ResourceClaim objects. */
export interface ResourceClaimTemplate {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClaimTemplate";
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimTemplateSpec;
}
export function toResourceClaimTemplate(input: c.JSONValue): ResourceClaimTemplate & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClaimTemplate"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimTemplateSpec(obj["spec"]),
  }}
export function fromResourceClaimTemplate(input: ResourceClaimTemplate): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha2", "ResourceClaimTemplate"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimTemplateSpec(input.spec) : undefined,
  }}

/** ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim. */
export interface ResourceClaimTemplateSpec {
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimSpec;
}
export function toResourceClaimTemplateSpec(input: c.JSONValue): ResourceClaimTemplateSpec {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimSpec(obj["spec"]),
  }}
export function fromResourceClaimTemplateSpec(input: ResourceClaimTemplateSpec): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimSpec(input.spec) : undefined,
  }}

/** ResourceClaimTemplateList is a collection of claim templates. */
export interface ResourceClaimTemplateList extends ListOf<ResourceClaimTemplate> {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClaimTemplateList";
};
export function toResourceClaimTemplateList(input: c.JSONValue): ResourceClaimTemplateList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClaimTemplateList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClaimTemplate),
  }}

/** ResourceClass is used by administrators to influence how resources are allocated.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface ResourceClass {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClass";
  driverName: string;
  metadata?: MetaV1.ObjectMeta | null;
  parametersRef?: ResourceClassParametersReference | null;
  structuredParameters?: boolean | null;
  suitableNodes?: CoreV1.NodeSelector | null;
}
export function toResourceClass(input: c.JSONValue): ResourceClass & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClass"),
    driverName: c.checkStr(obj["driverName"]),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    parametersRef: c.readOpt(obj["parametersRef"], toResourceClassParametersReference),
    structuredParameters: c.readOpt(obj["structuredParameters"], c.checkBool),
    suitableNodes: c.readOpt(obj["suitableNodes"], CoreV1.toNodeSelector),
  }}
export function fromResourceClass(input: ResourceClass): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha2", "ResourceClass"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    parametersRef: input.parametersRef != null ? fromResourceClassParametersReference(input.parametersRef) : undefined,
    suitableNodes: input.suitableNodes != null ? CoreV1.fromNodeSelector(input.suitableNodes) : undefined,
  }}

/** ResourceClassParametersReference contains enough information to let you locate the parameters for a ResourceClass. */
export interface ResourceClassParametersReference {
  apiGroup?: string | null;
  kind: string;
  name: string;
  namespace?: string | null;
}
export function toResourceClassParametersReference(input: c.JSONValue): ResourceClassParametersReference {
  const obj = c.checkObj(input);
  return {
    apiGroup: c.readOpt(obj["apiGroup"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
  }}
export function fromResourceClassParametersReference(input: ResourceClassParametersReference): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceClassList is a collection of classes. */
export interface ResourceClassList extends ListOf<ResourceClass> {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClassList";
};
export function toResourceClassList(input: c.JSONValue): ResourceClassList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClassList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClass),
  }}

/** ResourceClassParameters defines resource requests for a ResourceClass in an in-tree format understood by Kubernetes. */
export interface ResourceClassParameters {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClassParameters";
  filters?: Array<ResourceFilter> | null;
  generatedFrom?: ResourceClassParametersReference | null;
  metadata?: MetaV1.ObjectMeta | null;
  vendorParameters?: Array<VendorParameters> | null;
}
export function toResourceClassParameters(input: c.JSONValue): ResourceClassParameters & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClassParameters"),
    filters: c.readOpt(obj["filters"], x => c.readList(x, toResourceFilter)),
    generatedFrom: c.readOpt(obj["generatedFrom"], toResourceClassParametersReference),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    vendorParameters: c.readOpt(obj["vendorParameters"], x => c.readList(x, toVendorParameters)),
  }}
export function fromResourceClassParameters(input: ResourceClassParameters): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha2", "ResourceClassParameters"),
    ...input,
    filters: input.filters?.map(fromResourceFilter),
    generatedFrom: input.generatedFrom != null ? fromResourceClassParametersReference(input.generatedFrom) : undefined,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    vendorParameters: input.vendorParameters?.map(fromVendorParameters),
  }}

/** ResourceFilter is a filter for resources from one particular driver. */
export interface ResourceFilter {
  driverName?: string | null;
  namedResources?: NamedResourcesFilter | null;
}
export function toResourceFilter(input: c.JSONValue): ResourceFilter {
  const obj = c.checkObj(input);
  return {
    driverName: c.readOpt(obj["driverName"], c.checkStr),
    namedResources: c.readOpt(obj["namedResources"], toNamedResourcesFilter),
  }}
export function fromResourceFilter(input: ResourceFilter): c.JSONValue {
  return {
    ...input,
    namedResources: input.namedResources != null ? fromNamedResourcesFilter(input.namedResources) : undefined,
  }}

/** VendorParameters are opaque parameters for one particular driver. */
export interface VendorParameters {
  driverName?: string | null;
  parameters?: c.JSONValue | null;
}
export function toVendorParameters(input: c.JSONValue): VendorParameters {
  const obj = c.checkObj(input);
  return {
    driverName: c.readOpt(obj["driverName"], c.checkStr),
    parameters: c.readOpt(obj["parameters"], c.identity),
  }}
export function fromVendorParameters(input: VendorParameters): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceClassParametersList is a collection of ResourceClassParameters. */
export interface ResourceClassParametersList extends ListOf<ResourceClassParameters> {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceClassParametersList";
};
export function toResourceClassParametersList(input: c.JSONValue): ResourceClassParametersList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceClassParametersList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClassParameters),
  }}

/** ResourceSlice provides information about available resources on individual nodes. */
export interface ResourceSlice {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceSlice";
  driverName: string;
  metadata?: MetaV1.ObjectMeta | null;
  namedResources?: NamedResourcesResources | null;
  nodeName?: string | null;
}
export function toResourceSlice(input: c.JSONValue): ResourceSlice & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceSlice"),
    driverName: c.checkStr(obj["driverName"]),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    namedResources: c.readOpt(obj["namedResources"], toNamedResourcesResources),
    nodeName: c.readOpt(obj["nodeName"], c.checkStr),
  }}
export function fromResourceSlice(input: ResourceSlice): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha2", "ResourceSlice"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    namedResources: input.namedResources != null ? fromNamedResourcesResources(input.namedResources) : undefined,
  }}

/** ResourceSliceList is a collection of ResourceSlices. */
export interface ResourceSliceList extends ListOf<ResourceSlice> {
  apiVersion?: "resource.k8s.io/v1alpha2";
  kind?: "ResourceSliceList";
};
export function toResourceSliceList(input: c.JSONValue): ResourceSliceList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha2", "ResourceSliceList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceSlice),
  }}
