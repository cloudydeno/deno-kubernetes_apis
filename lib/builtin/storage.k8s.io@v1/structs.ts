// Autogenerated Schema file for StorageV1
import * as c from "../../common.ts";

import * as CoreV1 from "../core@v1/structs.ts";
import * as MetaV1 from "../meta@v1/structs.ts";
type Kind<T extends string> = {
  apiVersion: "storage.k8s.io/v1";
  kind: T;
};
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced. */
export type CSIDriver = Kind<"CSIDriver"> & CSIDriverFields;
export interface CSIDriverFields {
  metadata?: MetaV1.ObjectMeta | null;
  spec: CSIDriverSpec;
}
export function toCSIDriverFields(input: c.JSONValue): CSIDriverFields {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toCSIDriverSpec(obj["spec"]),
  }}
export function toCSIDriver(input: c.JSONValue): CSIDriver {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "storage.k8s.io/v1") throw new Error("Type apiv mis 2");
  if (kind !== "CSIDriver") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toCSIDriverFields(fields),
  }}
export function fromCSIDriver(input: CSIDriver): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromCSIDriverSpec(input.spec) : undefined,
  }}

/** CSIDriverSpec is the specification of a CSIDriver. */
export interface CSIDriverSpec {
  attachRequired?: boolean | null;
  fsGroupPolicy?: string | null;
  podInfoOnMount?: boolean | null;
  storageCapacity?: boolean | null;
  volumeLifecycleModes?: Array<string> | null;
}
export function toCSIDriverSpec(input: c.JSONValue): CSIDriverSpec {
  const obj = c.checkObj(input);
  return {
    attachRequired: c.readOpt(obj["attachRequired"], c.checkBool),
    fsGroupPolicy: c.readOpt(obj["fsGroupPolicy"], c.checkStr),
    podInfoOnMount: c.readOpt(obj["podInfoOnMount"], c.checkBool),
    storageCapacity: c.readOpt(obj["storageCapacity"], c.checkBool),
    volumeLifecycleModes: c.readOpt(obj["volumeLifecycleModes"], x => c.readList(x, c.checkStr)),
  }}
export function fromCSIDriverSpec(input: CSIDriverSpec): c.JSONValue {
  return {
    ...input,
  }}

/** CSIDriverList is a collection of CSIDriver objects. */
export type CSIDriverList = Kind<"CSIDriverList"> & ListOf<CSIDriverFields>;
export function toCSIDriverList(input: c.JSONValue): CSIDriverList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "storage.k8s.io/v1") throw new Error("Type apiv mis 2");
  if (kind !== "CSIDriverList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toCSIDriverFields),
  }}

/** CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object. */
export type CSINode = Kind<"CSINode"> & CSINodeFields;
export interface CSINodeFields {
  metadata?: MetaV1.ObjectMeta | null;
  spec: CSINodeSpec;
}
export function toCSINodeFields(input: c.JSONValue): CSINodeFields {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toCSINodeSpec(obj["spec"]),
  }}
export function toCSINode(input: c.JSONValue): CSINode {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "storage.k8s.io/v1") throw new Error("Type apiv mis 2");
  if (kind !== "CSINode") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toCSINodeFields(fields),
  }}
export function fromCSINode(input: CSINode): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromCSINodeSpec(input.spec) : undefined,
  }}

/** CSINodeSpec holds information about the specification of all CSI drivers installed on a node */
export interface CSINodeSpec {
  drivers: Array<CSINodeDriver>;
}
export function toCSINodeSpec(input: c.JSONValue): CSINodeSpec {
  const obj = c.checkObj(input);
  return {
    drivers: c.readList(obj["drivers"], toCSINodeDriver),
  }}
export function fromCSINodeSpec(input: CSINodeSpec): c.JSONValue {
  return {
    ...input,
    drivers: input.drivers?.map(fromCSINodeDriver),
  }}

/** CSINodeDriver holds information about the specification of one CSI driver installed on a node */
export interface CSINodeDriver {
  allocatable?: VolumeNodeResources | null;
  name: string;
  nodeID: string;
  topologyKeys?: Array<string> | null;
}
export function toCSINodeDriver(input: c.JSONValue): CSINodeDriver {
  const obj = c.checkObj(input);
  return {
    allocatable: c.readOpt(obj["allocatable"], toVolumeNodeResources),
    name: c.checkStr(obj["name"]),
    nodeID: c.checkStr(obj["nodeID"]),
    topologyKeys: c.readOpt(obj["topologyKeys"], x => c.readList(x, c.checkStr)),
  }}
export function fromCSINodeDriver(input: CSINodeDriver): c.JSONValue {
  return {
    ...input,
    allocatable: input.allocatable != null ? fromVolumeNodeResources(input.allocatable) : undefined,
  }}

/** VolumeNodeResources is a set of resource limits for scheduling of volumes. */
export interface VolumeNodeResources {
  count?: number | null;
}
export function toVolumeNodeResources(input: c.JSONValue): VolumeNodeResources {
  const obj = c.checkObj(input);
  return {
    count: c.readOpt(obj["count"], c.checkNum),
  }}
export function fromVolumeNodeResources(input: VolumeNodeResources): c.JSONValue {
  return {
    ...input,
  }}

/** CSINodeList is a collection of CSINode objects. */
export type CSINodeList = Kind<"CSINodeList"> & ListOf<CSINodeFields>;
export function toCSINodeList(input: c.JSONValue): CSINodeList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "storage.k8s.io/v1") throw new Error("Type apiv mis 2");
  if (kind !== "CSINodeList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toCSINodeFields),
  }}

/** StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.

StorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name. */
export type StorageClass = Kind<"StorageClass"> & StorageClassFields;
export interface StorageClassFields {
  allowVolumeExpansion?: boolean | null;
  allowedTopologies?: Array<CoreV1.TopologySelectorTerm> | null;
  metadata?: MetaV1.ObjectMeta | null;
  mountOptions?: Array<string> | null;
  parameters?: Record<string,string> | null;
  provisioner: string;
  reclaimPolicy?: string | null;
  volumeBindingMode?: string | null;
}
export function toStorageClassFields(input: c.JSONValue): StorageClassFields {
  const obj = c.checkObj(input);
  return {
    allowVolumeExpansion: c.readOpt(obj["allowVolumeExpansion"], c.checkBool),
    allowedTopologies: c.readOpt(obj["allowedTopologies"], x => c.readList(x, CoreV1.toTopologySelectorTerm)),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    mountOptions: c.readOpt(obj["mountOptions"], x => c.readList(x, c.checkStr)),
    parameters: c.readOpt(obj["parameters"], x => c.readMap(x, c.checkStr)),
    provisioner: c.checkStr(obj["provisioner"]),
    reclaimPolicy: c.readOpt(obj["reclaimPolicy"], c.checkStr),
    volumeBindingMode: c.readOpt(obj["volumeBindingMode"], c.checkStr),
  }}
export function toStorageClass(input: c.JSONValue): StorageClass {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "storage.k8s.io/v1") throw new Error("Type apiv mis 2");
  if (kind !== "StorageClass") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toStorageClassFields(fields),
  }}
export function fromStorageClass(input: StorageClass): c.JSONValue {
  return {
    ...input,
    allowedTopologies: input.allowedTopologies?.map(CoreV1.fromTopologySelectorTerm),
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
  }}

/** StorageClassList is a collection of storage classes. */
export type StorageClassList = Kind<"StorageClassList"> & ListOf<StorageClassFields>;
export function toStorageClassList(input: c.JSONValue): StorageClassList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "storage.k8s.io/v1") throw new Error("Type apiv mis 2");
  if (kind !== "StorageClassList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toStorageClassFields),
  }}

/** VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.

VolumeAttachment objects are non-namespaced. */
export type VolumeAttachment = Kind<"VolumeAttachment"> & VolumeAttachmentFields;
export interface VolumeAttachmentFields {
  metadata?: MetaV1.ObjectMeta | null;
  spec: VolumeAttachmentSpec;
  status?: VolumeAttachmentStatus | null;
}
export function toVolumeAttachmentFields(input: c.JSONValue): VolumeAttachmentFields {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toVolumeAttachmentSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toVolumeAttachmentStatus),
  }}
export function toVolumeAttachment(input: c.JSONValue): VolumeAttachment {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "storage.k8s.io/v1") throw new Error("Type apiv mis 2");
  if (kind !== "VolumeAttachment") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toVolumeAttachmentFields(fields),
  }}
export function fromVolumeAttachment(input: VolumeAttachment): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromVolumeAttachmentSpec(input.spec) : undefined,
    status: input.status != null ? fromVolumeAttachmentStatus(input.status) : undefined,
  }}

/** VolumeAttachmentSpec is the specification of a VolumeAttachment request. */
export interface VolumeAttachmentSpec {
  attacher: string;
  nodeName: string;
  source: VolumeAttachmentSource;
}
export function toVolumeAttachmentSpec(input: c.JSONValue): VolumeAttachmentSpec {
  const obj = c.checkObj(input);
  return {
    attacher: c.checkStr(obj["attacher"]),
    nodeName: c.checkStr(obj["nodeName"]),
    source: toVolumeAttachmentSource(obj["source"]),
  }}
export function fromVolumeAttachmentSpec(input: VolumeAttachmentSpec): c.JSONValue {
  return {
    ...input,
    source: input.source != null ? fromVolumeAttachmentSource(input.source) : undefined,
  }}

/** VolumeAttachmentSource represents a volume that should be attached. Right now only PersistenVolumes can be attached via external attacher, in future we may allow also inline volumes in pods. Exactly one member can be set. */
export interface VolumeAttachmentSource {
  inlineVolumeSpec?: CoreV1.PersistentVolumeSpec | null;
  persistentVolumeName?: string | null;
}
export function toVolumeAttachmentSource(input: c.JSONValue): VolumeAttachmentSource {
  const obj = c.checkObj(input);
  return {
    inlineVolumeSpec: c.readOpt(obj["inlineVolumeSpec"], CoreV1.toPersistentVolumeSpec),
    persistentVolumeName: c.readOpt(obj["persistentVolumeName"], c.checkStr),
  }}
export function fromVolumeAttachmentSource(input: VolumeAttachmentSource): c.JSONValue {
  return {
    ...input,
    inlineVolumeSpec: input.inlineVolumeSpec != null ? CoreV1.fromPersistentVolumeSpec(input.inlineVolumeSpec) : undefined,
  }}

/** VolumeAttachmentStatus is the status of a VolumeAttachment request. */
export interface VolumeAttachmentStatus {
  attachError?: VolumeError | null;
  attached: boolean;
  attachmentMetadata?: Record<string,string> | null;
  detachError?: VolumeError | null;
}
export function toVolumeAttachmentStatus(input: c.JSONValue): VolumeAttachmentStatus {
  const obj = c.checkObj(input);
  return {
    attachError: c.readOpt(obj["attachError"], toVolumeError),
    attached: c.checkBool(obj["attached"]),
    attachmentMetadata: c.readOpt(obj["attachmentMetadata"], x => c.readMap(x, c.checkStr)),
    detachError: c.readOpt(obj["detachError"], toVolumeError),
  }}
export function fromVolumeAttachmentStatus(input: VolumeAttachmentStatus): c.JSONValue {
  return {
    ...input,
    attachError: input.attachError != null ? fromVolumeError(input.attachError) : undefined,
    detachError: input.detachError != null ? fromVolumeError(input.detachError) : undefined,
  }}

/** VolumeError captures an error encountered during a volume operation. */
export interface VolumeError {
  message?: string | null;
  time?: c.Time | null;
}
export function toVolumeError(input: c.JSONValue): VolumeError {
  const obj = c.checkObj(input);
  return {
    message: c.readOpt(obj["message"], c.checkStr),
    time: c.readOpt(obj["time"], c.toTime),
  }}
export function fromVolumeError(input: VolumeError): c.JSONValue {
  return {
    ...input,
    time: input.time != null ? c.fromTime(input.time) : undefined,
  }}

/** VolumeAttachmentList is a collection of VolumeAttachment objects. */
export type VolumeAttachmentList = Kind<"VolumeAttachmentList"> & ListOf<VolumeAttachmentFields>;
export function toVolumeAttachmentList(input: c.JSONValue): VolumeAttachmentList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "storage.k8s.io/v1") throw new Error("Type apiv mis 2");
  if (kind !== "VolumeAttachmentList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toVolumeAttachmentFields),
  }}
