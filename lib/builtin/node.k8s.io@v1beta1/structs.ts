// Autogenerated Schema file for NodeV1beta1
import * as c from "../../common.ts";

import * as CoreV1 from "../core@v1/structs.ts";
import * as MetaV1 from "../meta@v1/structs.ts";
type Kind<T extends string> = {
  apiVersion: "node.k8s.io/v1beta1";
  kind: T;
};
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** Overhead structure represents the resource overhead associated with running a pod. */
export interface Overhead {
  podFixed?: Record<string,c.Quantity> | null;
}
export function toOverhead(input: c.JSONValue): Overhead {
  const obj = c.checkObj(input);
  return {
    podFixed: c.readOpt(obj["podFixed"], x => c.readMap(x, c.toQuantity)),
  }}
export function fromOverhead(input: Overhead): c.JSONValue {
  return {
    ...input,
    podFixed: c.writeMap(input.podFixed, c.fromQuantity),
  }}

/** RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md */
export interface RuntimeClass {
  apiVersion?: "node.k8s.io/v1beta1";
  kind?: "RuntimeClass";
  handler: string;
  metadata?: MetaV1.ObjectMeta | null;
  overhead?: Overhead | null;
  scheduling?: Scheduling | null;
}
export function toRuntimeClass(input: c.JSONValue): RuntimeClass & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "node.k8s.io/v1beta1", "RuntimeClass"),
    handler: c.checkStr(obj["handler"]),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    overhead: c.readOpt(obj["overhead"], toOverhead),
    scheduling: c.readOpt(obj["scheduling"], toScheduling),
  }}
export function fromRuntimeClass(input: RuntimeClass): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "node.k8s.io/v1beta1", "RuntimeClass"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    overhead: input.overhead != null ? fromOverhead(input.overhead) : undefined,
    scheduling: input.scheduling != null ? fromScheduling(input.scheduling) : undefined,
  }}

/** Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass. */
export interface Scheduling {
  nodeSelector?: Record<string,string> | null;
  tolerations?: Array<CoreV1.Toleration> | null;
}
export function toScheduling(input: c.JSONValue): Scheduling {
  const obj = c.checkObj(input);
  return {
    nodeSelector: c.readOpt(obj["nodeSelector"], x => c.readMap(x, c.checkStr)),
    tolerations: c.readOpt(obj["tolerations"], x => c.readList(x, CoreV1.toToleration)),
  }}
export function fromScheduling(input: Scheduling): c.JSONValue {
  return {
    ...input,
    tolerations: input.tolerations?.map(CoreV1.fromToleration),
  }}

/** RuntimeClassList is a list of RuntimeClass objects. */
export interface RuntimeClassList extends ListOf<RuntimeClass> {
  apiVersion?: "node.k8s.io/v1beta1";
  kind?: "RuntimeClassList";
};
export function toRuntimeClassList(input: c.JSONValue): RuntimeClassList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "node.k8s.io/v1beta1", "RuntimeClassList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toRuntimeClass),
  }}
