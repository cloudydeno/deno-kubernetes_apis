// Autogenerated Schema file for BatchV1
import * as c from "../../common.ts";

import * as CoreV1 from "../core@v1/structs.ts";
import * as MetaV1 from "../meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** CronJob represents the configuration of a single cron job. */
export interface CronJob {
  apiVersion?: "batch/v1";
  kind?: "CronJob";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: CronJobSpec | null;
  status?: CronJobStatus | null;
}
export function toCronJob(input: c.JSONValue): CronJob & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "batch/v1", "CronJob"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toCronJobSpec),
    status: c.readOpt(obj["status"], toCronJobStatus),
  }}
export function fromCronJob(input: CronJob): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "batch/v1", "CronJob"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromCronJobSpec(input.spec) : undefined,
    status: input.status != null ? fromCronJobStatus(input.status) : undefined,
  }}

/** CronJobSpec describes how the job execution will look like and when it will actually run. */
export interface CronJobSpec {
  concurrencyPolicy?: string | null;
  failedJobsHistoryLimit?: number | null;
  jobTemplate: JobTemplateSpec;
  schedule: string;
  startingDeadlineSeconds?: number | null;
  successfulJobsHistoryLimit?: number | null;
  suspend?: boolean | null;
  timeZone?: string | null;
}
export function toCronJobSpec(input: c.JSONValue): CronJobSpec {
  const obj = c.checkObj(input);
  return {
    concurrencyPolicy: c.readOpt(obj["concurrencyPolicy"], c.checkStr),
    failedJobsHistoryLimit: c.readOpt(obj["failedJobsHistoryLimit"], c.checkNum),
    jobTemplate: toJobTemplateSpec(obj["jobTemplate"]),
    schedule: c.checkStr(obj["schedule"]),
    startingDeadlineSeconds: c.readOpt(obj["startingDeadlineSeconds"], c.checkNum),
    successfulJobsHistoryLimit: c.readOpt(obj["successfulJobsHistoryLimit"], c.checkNum),
    suspend: c.readOpt(obj["suspend"], c.checkBool),
    timeZone: c.readOpt(obj["timeZone"], c.checkStr),
  }}
export function fromCronJobSpec(input: CronJobSpec): c.JSONValue {
  return {
    ...input,
    jobTemplate: input.jobTemplate != null ? fromJobTemplateSpec(input.jobTemplate) : undefined,
  }}

/** JobTemplateSpec describes the data a Job should have when created from a template */
export interface JobTemplateSpec {
  metadata?: MetaV1.ObjectMeta | null;
  spec?: JobSpec | null;
}
export function toJobTemplateSpec(input: c.JSONValue): JobTemplateSpec {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toJobSpec),
  }}
export function fromJobTemplateSpec(input: JobTemplateSpec): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromJobSpec(input.spec) : undefined,
  }}

/** JobSpec describes how the job execution will look like. */
export interface JobSpec {
  activeDeadlineSeconds?: number | null;
  backoffLimit?: number | null;
  backoffLimitPerIndex?: number | null;
  completionMode?: string | null;
  completions?: number | null;
  managedBy?: string | null;
  manualSelector?: boolean | null;
  maxFailedIndexes?: number | null;
  parallelism?: number | null;
  podFailurePolicy?: PodFailurePolicy | null;
  podReplacementPolicy?: string | null;
  selector?: MetaV1.LabelSelector | null;
  successPolicy?: SuccessPolicy | null;
  suspend?: boolean | null;
  template: CoreV1.PodTemplateSpec;
  ttlSecondsAfterFinished?: number | null;
}
export function toJobSpec(input: c.JSONValue): JobSpec {
  const obj = c.checkObj(input);
  return {
    activeDeadlineSeconds: c.readOpt(obj["activeDeadlineSeconds"], c.checkNum),
    backoffLimit: c.readOpt(obj["backoffLimit"], c.checkNum),
    backoffLimitPerIndex: c.readOpt(obj["backoffLimitPerIndex"], c.checkNum),
    completionMode: c.readOpt(obj["completionMode"], c.checkStr),
    completions: c.readOpt(obj["completions"], c.checkNum),
    managedBy: c.readOpt(obj["managedBy"], c.checkStr),
    manualSelector: c.readOpt(obj["manualSelector"], c.checkBool),
    maxFailedIndexes: c.readOpt(obj["maxFailedIndexes"], c.checkNum),
    parallelism: c.readOpt(obj["parallelism"], c.checkNum),
    podFailurePolicy: c.readOpt(obj["podFailurePolicy"], toPodFailurePolicy),
    podReplacementPolicy: c.readOpt(obj["podReplacementPolicy"], c.checkStr),
    selector: c.readOpt(obj["selector"], MetaV1.toLabelSelector),
    successPolicy: c.readOpt(obj["successPolicy"], toSuccessPolicy),
    suspend: c.readOpt(obj["suspend"], c.checkBool),
    template: CoreV1.toPodTemplateSpec(obj["template"]),
    ttlSecondsAfterFinished: c.readOpt(obj["ttlSecondsAfterFinished"], c.checkNum),
  }}
export function fromJobSpec(input: JobSpec): c.JSONValue {
  return {
    ...input,
    podFailurePolicy: input.podFailurePolicy != null ? fromPodFailurePolicy(input.podFailurePolicy) : undefined,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
    successPolicy: input.successPolicy != null ? fromSuccessPolicy(input.successPolicy) : undefined,
    template: input.template != null ? CoreV1.fromPodTemplateSpec(input.template) : undefined,
  }}

/** PodFailurePolicy describes how failed pods influence the backoffLimit. */
export interface PodFailurePolicy {
  rules: Array<PodFailurePolicyRule>;
}
export function toPodFailurePolicy(input: c.JSONValue): PodFailurePolicy {
  const obj = c.checkObj(input);
  return {
    rules: c.readList(obj["rules"], toPodFailurePolicyRule),
  }}
export function fromPodFailurePolicy(input: PodFailurePolicy): c.JSONValue {
  return {
    ...input,
    rules: input.rules?.map(fromPodFailurePolicyRule),
  }}

/** PodFailurePolicyRule describes how a pod failure is handled when the requirements are met. One of onExitCodes and onPodConditions, but not both, can be used in each rule. */
export interface PodFailurePolicyRule {
  action: string;
  onExitCodes?: PodFailurePolicyOnExitCodesRequirement | null;
  onPodConditions?: Array<PodFailurePolicyOnPodConditionsPattern> | null;
}
export function toPodFailurePolicyRule(input: c.JSONValue): PodFailurePolicyRule {
  const obj = c.checkObj(input);
  return {
    action: c.checkStr(obj["action"]),
    onExitCodes: c.readOpt(obj["onExitCodes"], toPodFailurePolicyOnExitCodesRequirement),
    onPodConditions: c.readOpt(obj["onPodConditions"], x => c.readList(x, toPodFailurePolicyOnPodConditionsPattern)),
  }}
export function fromPodFailurePolicyRule(input: PodFailurePolicyRule): c.JSONValue {
  return {
    ...input,
    onExitCodes: input.onExitCodes != null ? fromPodFailurePolicyOnExitCodesRequirement(input.onExitCodes) : undefined,
    onPodConditions: input.onPodConditions?.map(fromPodFailurePolicyOnPodConditionsPattern),
  }}

/** PodFailurePolicyOnExitCodesRequirement describes the requirement for handling a failed pod based on its container exit codes. In particular, it lookups the .state.terminated.exitCode for each app container and init container status, represented by the .status.containerStatuses and .status.initContainerStatuses fields in the Pod status, respectively. Containers completed with success (exit code 0) are excluded from the requirement check. */
export interface PodFailurePolicyOnExitCodesRequirement {
  containerName?: string | null;
  operator: string;
  values: Array<number>;
}
export function toPodFailurePolicyOnExitCodesRequirement(input: c.JSONValue): PodFailurePolicyOnExitCodesRequirement {
  const obj = c.checkObj(input);
  return {
    containerName: c.readOpt(obj["containerName"], c.checkStr),
    operator: c.checkStr(obj["operator"]),
    values: c.readList(obj["values"], c.checkNum),
  }}
export function fromPodFailurePolicyOnExitCodesRequirement(input: PodFailurePolicyOnExitCodesRequirement): c.JSONValue {
  return {
    ...input,
  }}

/** PodFailurePolicyOnPodConditionsPattern describes a pattern for matching an actual pod condition type. */
export interface PodFailurePolicyOnPodConditionsPattern {
  status: string;
  type: string;
}
export function toPodFailurePolicyOnPodConditionsPattern(input: c.JSONValue): PodFailurePolicyOnPodConditionsPattern {
  const obj = c.checkObj(input);
  return {
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromPodFailurePolicyOnPodConditionsPattern(input: PodFailurePolicyOnPodConditionsPattern): c.JSONValue {
  return {
    ...input,
  }}

/** SuccessPolicy describes when a Job can be declared as succeeded based on the success of some indexes. */
export interface SuccessPolicy {
  rules: Array<SuccessPolicyRule>;
}
export function toSuccessPolicy(input: c.JSONValue): SuccessPolicy {
  const obj = c.checkObj(input);
  return {
    rules: c.readList(obj["rules"], toSuccessPolicyRule),
  }}
export function fromSuccessPolicy(input: SuccessPolicy): c.JSONValue {
  return {
    ...input,
    rules: input.rules?.map(fromSuccessPolicyRule),
  }}

/** SuccessPolicyRule describes rule for declaring a Job as succeeded. Each rule must have at least one of the "succeededIndexes" or "succeededCount" specified. */
export interface SuccessPolicyRule {
  succeededCount?: number | null;
  succeededIndexes?: string | null;
}
export function toSuccessPolicyRule(input: c.JSONValue): SuccessPolicyRule {
  const obj = c.checkObj(input);
  return {
    succeededCount: c.readOpt(obj["succeededCount"], c.checkNum),
    succeededIndexes: c.readOpt(obj["succeededIndexes"], c.checkStr),
  }}
export function fromSuccessPolicyRule(input: SuccessPolicyRule): c.JSONValue {
  return {
    ...input,
  }}

/** CronJobStatus represents the current state of a cron job. */
export interface CronJobStatus {
  active?: Array<CoreV1.ObjectReference> | null;
  lastScheduleTime?: c.Time | null;
  lastSuccessfulTime?: c.Time | null;
}
export function toCronJobStatus(input: c.JSONValue): CronJobStatus {
  const obj = c.checkObj(input);
  return {
    active: c.readOpt(obj["active"], x => c.readList(x, CoreV1.toObjectReference)),
    lastScheduleTime: c.readOpt(obj["lastScheduleTime"], c.toTime),
    lastSuccessfulTime: c.readOpt(obj["lastSuccessfulTime"], c.toTime),
  }}
export function fromCronJobStatus(input: CronJobStatus): c.JSONValue {
  return {
    ...input,
    active: input.active?.map(CoreV1.fromObjectReference),
    lastScheduleTime: input.lastScheduleTime != null ? c.fromTime(input.lastScheduleTime) : undefined,
    lastSuccessfulTime: input.lastSuccessfulTime != null ? c.fromTime(input.lastSuccessfulTime) : undefined,
  }}

/** CronJobList is a collection of cron jobs. */
export interface CronJobList extends ListOf<CronJob> {
  apiVersion?: "batch/v1";
  kind?: "CronJobList";
};
export function toCronJobList(input: c.JSONValue): CronJobList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "batch/v1", "CronJobList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toCronJob),
  }}

/** Job represents the configuration of a single job. */
export interface Job {
  apiVersion?: "batch/v1";
  kind?: "Job";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: JobSpec | null;
  status?: JobStatus | null;
}
export function toJob(input: c.JSONValue): Job & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "batch/v1", "Job"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toJobSpec),
    status: c.readOpt(obj["status"], toJobStatus),
  }}
export function fromJob(input: Job): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "batch/v1", "Job"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromJobSpec(input.spec) : undefined,
    status: input.status != null ? fromJobStatus(input.status) : undefined,
  }}

/** JobStatus represents the current state of a Job. */
export interface JobStatus {
  active?: number | null;
  completedIndexes?: string | null;
  completionTime?: c.Time | null;
  conditions?: Array<JobCondition> | null;
  failed?: number | null;
  failedIndexes?: string | null;
  ready?: number | null;
  startTime?: c.Time | null;
  succeeded?: number | null;
  terminating?: number | null;
  uncountedTerminatedPods?: UncountedTerminatedPods | null;
}
export function toJobStatus(input: c.JSONValue): JobStatus {
  const obj = c.checkObj(input);
  return {
    active: c.readOpt(obj["active"], c.checkNum),
    completedIndexes: c.readOpt(obj["completedIndexes"], c.checkStr),
    completionTime: c.readOpt(obj["completionTime"], c.toTime),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toJobCondition)),
    failed: c.readOpt(obj["failed"], c.checkNum),
    failedIndexes: c.readOpt(obj["failedIndexes"], c.checkStr),
    ready: c.readOpt(obj["ready"], c.checkNum),
    startTime: c.readOpt(obj["startTime"], c.toTime),
    succeeded: c.readOpt(obj["succeeded"], c.checkNum),
    terminating: c.readOpt(obj["terminating"], c.checkNum),
    uncountedTerminatedPods: c.readOpt(obj["uncountedTerminatedPods"], toUncountedTerminatedPods),
  }}
export function fromJobStatus(input: JobStatus): c.JSONValue {
  return {
    ...input,
    completionTime: input.completionTime != null ? c.fromTime(input.completionTime) : undefined,
    conditions: input.conditions?.map(fromJobCondition),
    startTime: input.startTime != null ? c.fromTime(input.startTime) : undefined,
    uncountedTerminatedPods: input.uncountedTerminatedPods != null ? fromUncountedTerminatedPods(input.uncountedTerminatedPods) : undefined,
  }}

/** JobCondition describes current state of a job. */
export interface JobCondition {
  lastProbeTime?: c.Time | null;
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toJobCondition(input: c.JSONValue): JobCondition {
  const obj = c.checkObj(input);
  return {
    lastProbeTime: c.readOpt(obj["lastProbeTime"], c.toTime),
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromJobCondition(input: JobCondition): c.JSONValue {
  return {
    ...input,
    lastProbeTime: input.lastProbeTime != null ? c.fromTime(input.lastProbeTime) : undefined,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** UncountedTerminatedPods holds UIDs of Pods that have terminated but haven't been accounted in Job status counters. */
export interface UncountedTerminatedPods {
  failed?: Array<string> | null;
  succeeded?: Array<string> | null;
}
export function toUncountedTerminatedPods(input: c.JSONValue): UncountedTerminatedPods {
  const obj = c.checkObj(input);
  return {
    failed: c.readOpt(obj["failed"], x => c.readList(x, c.checkStr)),
    succeeded: c.readOpt(obj["succeeded"], x => c.readList(x, c.checkStr)),
  }}
export function fromUncountedTerminatedPods(input: UncountedTerminatedPods): c.JSONValue {
  return {
    ...input,
  }}

/** JobList is a collection of jobs. */
export interface JobList extends ListOf<Job> {
  apiVersion?: "batch/v1";
  kind?: "JobList";
};
export function toJobList(input: c.JSONValue): JobList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "batch/v1", "JobList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toJob),
  }}
