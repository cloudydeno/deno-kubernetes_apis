// Autogenerated Schema file for AdmissionregistrationV1alpha1
import * as c from "../../common.ts";

import * as MetaV1 from "../meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** ApplyConfiguration defines the desired configuration values of an object. */
export interface ApplyConfiguration {
  expression?: string | null;
}
export function toApplyConfiguration(input: c.JSONValue): ApplyConfiguration {
  const obj = c.checkObj(input);
  return {
    expression: c.readOpt(obj["expression"], c.checkStr),
  }}
export function fromApplyConfiguration(input: ApplyConfiguration): c.JSONValue {
  return {
    ...input,
  }}

/** JSONPatch defines a JSON Patch. */
export interface JSONPatch {
  expression?: string | null;
}
export function toJSONPatch(input: c.JSONValue): JSONPatch {
  const obj = c.checkObj(input);
  return {
    expression: c.readOpt(obj["expression"], c.checkStr),
  }}
export function fromJSONPatch(input: JSONPatch): c.JSONValue {
  return {
    ...input,
  }}

export interface MatchCondition {
  expression: string;
  name: string;
}
export function toMatchCondition(input: c.JSONValue): MatchCondition {
  const obj = c.checkObj(input);
  return {
    expression: c.checkStr(obj["expression"]),
    name: c.checkStr(obj["name"]),
  }}
export function fromMatchCondition(input: MatchCondition): c.JSONValue {
  return {
    ...input,
  }}

/** MatchResources decides whether to run the admission control policy on an object based on whether it meets the match criteria. The exclude rules take precedence over include rules (if a resource matches both, it is excluded) */
export interface MatchResources {
  excludeResourceRules?: Array<NamedRuleWithOperations> | null;
  matchPolicy?: string | null;
  namespaceSelector?: MetaV1.LabelSelector | null;
  objectSelector?: MetaV1.LabelSelector | null;
  resourceRules?: Array<NamedRuleWithOperations> | null;
}
export function toMatchResources(input: c.JSONValue): MatchResources {
  const obj = c.checkObj(input);
  return {
    excludeResourceRules: c.readOpt(obj["excludeResourceRules"], x => c.readList(x, toNamedRuleWithOperations)),
    matchPolicy: c.readOpt(obj["matchPolicy"], c.checkStr),
    namespaceSelector: c.readOpt(obj["namespaceSelector"], MetaV1.toLabelSelector),
    objectSelector: c.readOpt(obj["objectSelector"], MetaV1.toLabelSelector),
    resourceRules: c.readOpt(obj["resourceRules"], x => c.readList(x, toNamedRuleWithOperations)),
  }}
export function fromMatchResources(input: MatchResources): c.JSONValue {
  return {
    ...input,
    excludeResourceRules: input.excludeResourceRules?.map(fromNamedRuleWithOperations),
    namespaceSelector: input.namespaceSelector != null ? MetaV1.fromLabelSelector(input.namespaceSelector) : undefined,
    objectSelector: input.objectSelector != null ? MetaV1.fromLabelSelector(input.objectSelector) : undefined,
    resourceRules: input.resourceRules?.map(fromNamedRuleWithOperations),
  }}

/** NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames. */
export interface NamedRuleWithOperations {
  apiGroups?: Array<string> | null;
  apiVersions?: Array<string> | null;
  operations?: Array<string> | null;
  resourceNames?: Array<string> | null;
  resources?: Array<string> | null;
  scope?: string | null;
}
export function toNamedRuleWithOperations(input: c.JSONValue): NamedRuleWithOperations {
  const obj = c.checkObj(input);
  return {
    apiGroups: c.readOpt(obj["apiGroups"], x => c.readList(x, c.checkStr)),
    apiVersions: c.readOpt(obj["apiVersions"], x => c.readList(x, c.checkStr)),
    operations: c.readOpt(obj["operations"], x => c.readList(x, c.checkStr)),
    resourceNames: c.readOpt(obj["resourceNames"], x => c.readList(x, c.checkStr)),
    resources: c.readOpt(obj["resources"], x => c.readList(x, c.checkStr)),
    scope: c.readOpt(obj["scope"], c.checkStr),
  }}
export function fromNamedRuleWithOperations(input: NamedRuleWithOperations): c.JSONValue {
  return {
    ...input,
  }}

/** MutatingAdmissionPolicy describes the definition of an admission mutation policy that mutates the object coming into admission chain. */
export interface MutatingAdmissionPolicy {
  apiVersion?: "admissionregistration.k8s.io/v1alpha1";
  kind?: "MutatingAdmissionPolicy";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: MutatingAdmissionPolicySpec | null;
}
export function toMutatingAdmissionPolicy(input: c.JSONValue): MutatingAdmissionPolicy & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "admissionregistration.k8s.io/v1alpha1", "MutatingAdmissionPolicy"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toMutatingAdmissionPolicySpec),
  }}
export function fromMutatingAdmissionPolicy(input: MutatingAdmissionPolicy): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "admissionregistration.k8s.io/v1alpha1", "MutatingAdmissionPolicy"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromMutatingAdmissionPolicySpec(input.spec) : undefined,
  }}

/** MutatingAdmissionPolicySpec is the specification of the desired behavior of the admission policy. */
export interface MutatingAdmissionPolicySpec {
  failurePolicy?: string | null;
  matchConditions?: Array<MatchCondition> | null;
  matchConstraints?: MatchResources | null;
  mutations?: Array<Mutation> | null;
  paramKind?: ParamKind | null;
  reinvocationPolicy?: string | null;
  variables?: Array<Variable> | null;
}
export function toMutatingAdmissionPolicySpec(input: c.JSONValue): MutatingAdmissionPolicySpec {
  const obj = c.checkObj(input);
  return {
    failurePolicy: c.readOpt(obj["failurePolicy"], c.checkStr),
    matchConditions: c.readOpt(obj["matchConditions"], x => c.readList(x, toMatchCondition)),
    matchConstraints: c.readOpt(obj["matchConstraints"], toMatchResources),
    mutations: c.readOpt(obj["mutations"], x => c.readList(x, toMutation)),
    paramKind: c.readOpt(obj["paramKind"], toParamKind),
    reinvocationPolicy: c.readOpt(obj["reinvocationPolicy"], c.checkStr),
    variables: c.readOpt(obj["variables"], x => c.readList(x, toVariable)),
  }}
export function fromMutatingAdmissionPolicySpec(input: MutatingAdmissionPolicySpec): c.JSONValue {
  return {
    ...input,
    matchConditions: input.matchConditions?.map(fromMatchCondition),
    matchConstraints: input.matchConstraints != null ? fromMatchResources(input.matchConstraints) : undefined,
    mutations: input.mutations?.map(fromMutation),
    paramKind: input.paramKind != null ? fromParamKind(input.paramKind) : undefined,
    variables: input.variables?.map(fromVariable),
  }}

/** Mutation specifies the CEL expression which is used to apply the Mutation. */
export interface Mutation {
  applyConfiguration?: ApplyConfiguration | null;
  jsonPatch?: JSONPatch | null;
  patchType: string;
}
export function toMutation(input: c.JSONValue): Mutation {
  const obj = c.checkObj(input);
  return {
    applyConfiguration: c.readOpt(obj["applyConfiguration"], toApplyConfiguration),
    jsonPatch: c.readOpt(obj["jsonPatch"], toJSONPatch),
    patchType: c.checkStr(obj["patchType"]),
  }}
export function fromMutation(input: Mutation): c.JSONValue {
  return {
    ...input,
    applyConfiguration: input.applyConfiguration != null ? fromApplyConfiguration(input.applyConfiguration) : undefined,
    jsonPatch: input.jsonPatch != null ? fromJSONPatch(input.jsonPatch) : undefined,
  }}

/** ParamKind is a tuple of Group Kind and Version. */
export interface ParamKind {
  apiVersion?: string | null;
  kind?: string | null;
}
export function toParamKind(input: c.JSONValue): ParamKind {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
  }}
export function fromParamKind(input: ParamKind): c.JSONValue {
  return {
    ...input,
  }}

/** Variable is the definition of a variable that is used for composition. */
export interface Variable {
  expression: string;
  name: string;
}
export function toVariable(input: c.JSONValue): Variable {
  const obj = c.checkObj(input);
  return {
    expression: c.checkStr(obj["expression"]),
    name: c.checkStr(obj["name"]),
  }}
export function fromVariable(input: Variable): c.JSONValue {
  return {
    ...input,
  }}

/** MutatingAdmissionPolicyBinding binds the MutatingAdmissionPolicy with parametrized resources. MutatingAdmissionPolicyBinding and the optional parameter resource together define how cluster administrators configure policies for clusters.

For a given admission request, each binding will cause its policy to be evaluated N times, where N is 1 for policies/bindings that don't use params, otherwise N is the number of parameters selected by the binding. Each evaluation is constrained by a [runtime cost budget](https://kubernetes.io/docs/reference/using-api/cel/#runtime-cost-budget).

Adding/removing policies, bindings, or params can not affect whether a given (policy, binding, param) combination is within its own CEL budget. */
export interface MutatingAdmissionPolicyBinding {
  apiVersion?: "admissionregistration.k8s.io/v1alpha1";
  kind?: "MutatingAdmissionPolicyBinding";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: MutatingAdmissionPolicyBindingSpec | null;
}
export function toMutatingAdmissionPolicyBinding(input: c.JSONValue): MutatingAdmissionPolicyBinding & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "admissionregistration.k8s.io/v1alpha1", "MutatingAdmissionPolicyBinding"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toMutatingAdmissionPolicyBindingSpec),
  }}
export function fromMutatingAdmissionPolicyBinding(input: MutatingAdmissionPolicyBinding): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "admissionregistration.k8s.io/v1alpha1", "MutatingAdmissionPolicyBinding"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromMutatingAdmissionPolicyBindingSpec(input.spec) : undefined,
  }}

/** MutatingAdmissionPolicyBindingSpec is the specification of the MutatingAdmissionPolicyBinding. */
export interface MutatingAdmissionPolicyBindingSpec {
  matchResources?: MatchResources | null;
  paramRef?: ParamRef | null;
  policyName?: string | null;
}
export function toMutatingAdmissionPolicyBindingSpec(input: c.JSONValue): MutatingAdmissionPolicyBindingSpec {
  const obj = c.checkObj(input);
  return {
    matchResources: c.readOpt(obj["matchResources"], toMatchResources),
    paramRef: c.readOpt(obj["paramRef"], toParamRef),
    policyName: c.readOpt(obj["policyName"], c.checkStr),
  }}
export function fromMutatingAdmissionPolicyBindingSpec(input: MutatingAdmissionPolicyBindingSpec): c.JSONValue {
  return {
    ...input,
    matchResources: input.matchResources != null ? fromMatchResources(input.matchResources) : undefined,
    paramRef: input.paramRef != null ? fromParamRef(input.paramRef) : undefined,
  }}

/** ParamRef describes how to locate the params to be used as input to expressions of rules applied by a policy binding. */
export interface ParamRef {
  name?: string | null;
  namespace?: string | null;
  parameterNotFoundAction?: string | null;
  selector?: MetaV1.LabelSelector | null;
}
export function toParamRef(input: c.JSONValue): ParamRef {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    parameterNotFoundAction: c.readOpt(obj["parameterNotFoundAction"], c.checkStr),
    selector: c.readOpt(obj["selector"], MetaV1.toLabelSelector),
  }}
export function fromParamRef(input: ParamRef): c.JSONValue {
  return {
    ...input,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
  }}

/** MutatingAdmissionPolicyBindingList is a list of MutatingAdmissionPolicyBinding. */
export interface MutatingAdmissionPolicyBindingList extends ListOf<MutatingAdmissionPolicyBinding> {
  apiVersion?: "admissionregistration.k8s.io/v1alpha1";
  kind?: "MutatingAdmissionPolicyBindingList";
};
export function toMutatingAdmissionPolicyBindingList(input: c.JSONValue): MutatingAdmissionPolicyBindingList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "admissionregistration.k8s.io/v1alpha1", "MutatingAdmissionPolicyBindingList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toMutatingAdmissionPolicyBinding),
  }}

/** MutatingAdmissionPolicyList is a list of MutatingAdmissionPolicy. */
export interface MutatingAdmissionPolicyList extends ListOf<MutatingAdmissionPolicy> {
  apiVersion?: "admissionregistration.k8s.io/v1alpha1";
  kind?: "MutatingAdmissionPolicyList";
};
export function toMutatingAdmissionPolicyList(input: c.JSONValue): MutatingAdmissionPolicyList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "admissionregistration.k8s.io/v1alpha1", "MutatingAdmissionPolicyList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toMutatingAdmissionPolicy),
  }}
