// Autogenerated Schema file for AutoscalingV2beta2
import * as c from "../../common.ts";

import * as MetaV1 from "../meta@v1/structs.ts";
type Kind<T extends string> = {
  apiVersion: "autoscaling/v2beta2";
  kind: T;
};
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** CrossVersionObjectReference contains enough information to let you identify the referred resource. */
export interface CrossVersionObjectReference {
  apiVersion?: string | null;
  kind: string;
  name: string;
}
export function toCrossVersionObjectReference(input: c.JSONValue): CrossVersionObjectReference {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
  }}
export function fromCrossVersionObjectReference(input: CrossVersionObjectReference): c.JSONValue {
  return {
    ...input,
  }}

/** ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes object (for example length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster). */
export interface ExternalMetricSource {
  metric: MetricIdentifier;
  target: MetricTarget;
}
export function toExternalMetricSource(input: c.JSONValue): ExternalMetricSource {
  const obj = c.checkObj(input);
  return {
    metric: toMetricIdentifier(obj["metric"]),
    target: toMetricTarget(obj["target"]),
  }}
export function fromExternalMetricSource(input: ExternalMetricSource): c.JSONValue {
  return {
    ...input,
    metric: input.metric != null ? fromMetricIdentifier(input.metric) : undefined,
    target: input.target != null ? fromMetricTarget(input.target) : undefined,
  }}

/** MetricIdentifier defines the name and optionally selector for a metric */
export interface MetricIdentifier {
  name: string;
  selector?: MetaV1.LabelSelector | null;
}
export function toMetricIdentifier(input: c.JSONValue): MetricIdentifier {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    selector: c.readOpt(obj["selector"], MetaV1.toLabelSelector),
  }}
export function fromMetricIdentifier(input: MetricIdentifier): c.JSONValue {
  return {
    ...input,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
  }}

/** MetricTarget defines the target value, average value, or average utilization of a specific metric */
export interface MetricTarget {
  averageUtilization?: number | null;
  averageValue?: c.Quantity | null;
  type: string;
  value?: c.Quantity | null;
}
export function toMetricTarget(input: c.JSONValue): MetricTarget {
  const obj = c.checkObj(input);
  return {
    averageUtilization: c.readOpt(obj["averageUtilization"], c.checkNum),
    averageValue: c.readOpt(obj["averageValue"], c.toQuantity),
    type: c.checkStr(obj["type"]),
    value: c.readOpt(obj["value"], c.toQuantity),
  }}
export function fromMetricTarget(input: MetricTarget): c.JSONValue {
  return {
    ...input,
    averageValue: input.averageValue != null ? c.fromQuantity(input.averageValue) : undefined,
    value: input.value != null ? c.fromQuantity(input.value) : undefined,
  }}

/** ExternalMetricStatus indicates the current value of a global metric not associated with any Kubernetes object. */
export interface ExternalMetricStatus {
  current: MetricValueStatus;
  metric: MetricIdentifier;
}
export function toExternalMetricStatus(input: c.JSONValue): ExternalMetricStatus {
  const obj = c.checkObj(input);
  return {
    current: toMetricValueStatus(obj["current"]),
    metric: toMetricIdentifier(obj["metric"]),
  }}
export function fromExternalMetricStatus(input: ExternalMetricStatus): c.JSONValue {
  return {
    ...input,
    current: input.current != null ? fromMetricValueStatus(input.current) : undefined,
    metric: input.metric != null ? fromMetricIdentifier(input.metric) : undefined,
  }}

/** MetricValueStatus holds the current value for a metric */
export interface MetricValueStatus {
  averageUtilization?: number | null;
  averageValue?: c.Quantity | null;
  value?: c.Quantity | null;
}
export function toMetricValueStatus(input: c.JSONValue): MetricValueStatus {
  const obj = c.checkObj(input);
  return {
    averageUtilization: c.readOpt(obj["averageUtilization"], c.checkNum),
    averageValue: c.readOpt(obj["averageValue"], c.toQuantity),
    value: c.readOpt(obj["value"], c.toQuantity),
  }}
export function fromMetricValueStatus(input: MetricValueStatus): c.JSONValue {
  return {
    ...input,
    averageValue: input.averageValue != null ? c.fromQuantity(input.averageValue) : undefined,
    value: input.value != null ? c.fromQuantity(input.value) : undefined,
  }}

/** HPAScalingPolicy is a single policy which must hold true for a specified past interval. */
export interface HPAScalingPolicy {
  periodSeconds: number;
  type: string;
  value: number;
}
export function toHPAScalingPolicy(input: c.JSONValue): HPAScalingPolicy {
  const obj = c.checkObj(input);
  return {
    periodSeconds: c.checkNum(obj["periodSeconds"]),
    type: c.checkStr(obj["type"]),
    value: c.checkNum(obj["value"]),
  }}
export function fromHPAScalingPolicy(input: HPAScalingPolicy): c.JSONValue {
  return {
    ...input,
  }}

/** HPAScalingRules configures the scaling behavior for one direction. These Rules are applied after calculating DesiredReplicas from metrics for the HPA. They can limit the scaling velocity by specifying scaling policies. They can prevent flapping by specifying the stabilization window, so that the number of replicas is not set instantly, instead, the safest value from the stabilization window is chosen. */
export interface HPAScalingRules {
  policies?: Array<HPAScalingPolicy> | null;
  selectPolicy?: string | null;
  stabilizationWindowSeconds?: number | null;
}
export function toHPAScalingRules(input: c.JSONValue): HPAScalingRules {
  const obj = c.checkObj(input);
  return {
    policies: c.readOpt(obj["policies"], x => c.readList(x, toHPAScalingPolicy)),
    selectPolicy: c.readOpt(obj["selectPolicy"], c.checkStr),
    stabilizationWindowSeconds: c.readOpt(obj["stabilizationWindowSeconds"], c.checkNum),
  }}
export function fromHPAScalingRules(input: HPAScalingRules): c.JSONValue {
  return {
    ...input,
    policies: input.policies?.map(fromHPAScalingPolicy),
  }}

/** HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified. */
export interface HorizontalPodAutoscaler {
  apiVersion?: "autoscaling/v2beta2";
  kind?: "HorizontalPodAutoscaler";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: HorizontalPodAutoscalerSpec | null;
  status?: HorizontalPodAutoscalerStatus | null;
}
export function toHorizontalPodAutoscaler(input: c.JSONValue): HorizontalPodAutoscaler & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "autoscaling/v2beta2", "HorizontalPodAutoscaler"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toHorizontalPodAutoscalerSpec),
    status: c.readOpt(obj["status"], toHorizontalPodAutoscalerStatus),
  }}
export function fromHorizontalPodAutoscaler(input: HorizontalPodAutoscaler): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "autoscaling/v2beta2", "HorizontalPodAutoscaler"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromHorizontalPodAutoscalerSpec(input.spec) : undefined,
    status: input.status != null ? fromHorizontalPodAutoscalerStatus(input.status) : undefined,
  }}

/** HorizontalPodAutoscalerSpec describes the desired functionality of the HorizontalPodAutoscaler. */
export interface HorizontalPodAutoscalerSpec {
  behavior?: HorizontalPodAutoscalerBehavior | null;
  maxReplicas: number;
  metrics?: Array<MetricSpec> | null;
  minReplicas?: number | null;
  scaleTargetRef: CrossVersionObjectReference;
}
export function toHorizontalPodAutoscalerSpec(input: c.JSONValue): HorizontalPodAutoscalerSpec {
  const obj = c.checkObj(input);
  return {
    behavior: c.readOpt(obj["behavior"], toHorizontalPodAutoscalerBehavior),
    maxReplicas: c.checkNum(obj["maxReplicas"]),
    metrics: c.readOpt(obj["metrics"], x => c.readList(x, toMetricSpec)),
    minReplicas: c.readOpt(obj["minReplicas"], c.checkNum),
    scaleTargetRef: toCrossVersionObjectReference(obj["scaleTargetRef"]),
  }}
export function fromHorizontalPodAutoscalerSpec(input: HorizontalPodAutoscalerSpec): c.JSONValue {
  return {
    ...input,
    behavior: input.behavior != null ? fromHorizontalPodAutoscalerBehavior(input.behavior) : undefined,
    metrics: input.metrics?.map(fromMetricSpec),
    scaleTargetRef: input.scaleTargetRef != null ? fromCrossVersionObjectReference(input.scaleTargetRef) : undefined,
  }}

/** HorizontalPodAutoscalerBehavior configures the scaling behavior of the target in both Up and Down directions (scaleUp and scaleDown fields respectively). */
export interface HorizontalPodAutoscalerBehavior {
  scaleDown?: HPAScalingRules | null;
  scaleUp?: HPAScalingRules | null;
}
export function toHorizontalPodAutoscalerBehavior(input: c.JSONValue): HorizontalPodAutoscalerBehavior {
  const obj = c.checkObj(input);
  return {
    scaleDown: c.readOpt(obj["scaleDown"], toHPAScalingRules),
    scaleUp: c.readOpt(obj["scaleUp"], toHPAScalingRules),
  }}
export function fromHorizontalPodAutoscalerBehavior(input: HorizontalPodAutoscalerBehavior): c.JSONValue {
  return {
    ...input,
    scaleDown: input.scaleDown != null ? fromHPAScalingRules(input.scaleDown) : undefined,
    scaleUp: input.scaleUp != null ? fromHPAScalingRules(input.scaleUp) : undefined,
  }}

/** MetricSpec specifies how to scale based on a single metric (only `type` and one other matching field should be set at once). */
export interface MetricSpec {
  external?: ExternalMetricSource | null;
  object?: ObjectMetricSource | null;
  pods?: PodsMetricSource | null;
  resource?: ResourceMetricSource | null;
  type: string;
}
export function toMetricSpec(input: c.JSONValue): MetricSpec {
  const obj = c.checkObj(input);
  return {
    external: c.readOpt(obj["external"], toExternalMetricSource),
    object: c.readOpt(obj["object"], toObjectMetricSource),
    pods: c.readOpt(obj["pods"], toPodsMetricSource),
    resource: c.readOpt(obj["resource"], toResourceMetricSource),
    type: c.checkStr(obj["type"]),
  }}
export function fromMetricSpec(input: MetricSpec): c.JSONValue {
  return {
    ...input,
    external: input.external != null ? fromExternalMetricSource(input.external) : undefined,
    object: input.object != null ? fromObjectMetricSource(input.object) : undefined,
    pods: input.pods != null ? fromPodsMetricSource(input.pods) : undefined,
    resource: input.resource != null ? fromResourceMetricSource(input.resource) : undefined,
  }}

/** ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for example, hits-per-second on an Ingress object). */
export interface ObjectMetricSource {
  describedObject: CrossVersionObjectReference;
  metric: MetricIdentifier;
  target: MetricTarget;
}
export function toObjectMetricSource(input: c.JSONValue): ObjectMetricSource {
  const obj = c.checkObj(input);
  return {
    describedObject: toCrossVersionObjectReference(obj["describedObject"]),
    metric: toMetricIdentifier(obj["metric"]),
    target: toMetricTarget(obj["target"]),
  }}
export function fromObjectMetricSource(input: ObjectMetricSource): c.JSONValue {
  return {
    ...input,
    describedObject: input.describedObject != null ? fromCrossVersionObjectReference(input.describedObject) : undefined,
    metric: input.metric != null ? fromMetricIdentifier(input.metric) : undefined,
    target: input.target != null ? fromMetricTarget(input.target) : undefined,
  }}

/** PodsMetricSource indicates how to scale on a metric describing each pod in the current scale target (for example, transactions-processed-per-second). The values will be averaged together before being compared to the target value. */
export interface PodsMetricSource {
  metric: MetricIdentifier;
  target: MetricTarget;
}
export function toPodsMetricSource(input: c.JSONValue): PodsMetricSource {
  const obj = c.checkObj(input);
  return {
    metric: toMetricIdentifier(obj["metric"]),
    target: toMetricTarget(obj["target"]),
  }}
export function fromPodsMetricSource(input: PodsMetricSource): c.JSONValue {
  return {
    ...input,
    metric: input.metric != null ? fromMetricIdentifier(input.metric) : undefined,
    target: input.target != null ? fromMetricTarget(input.target) : undefined,
  }}

/** ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  The values will be averaged together before being compared to the target.  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the "pods" source.  Only one "target" type should be set. */
export interface ResourceMetricSource {
  name: string;
  target: MetricTarget;
}
export function toResourceMetricSource(input: c.JSONValue): ResourceMetricSource {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    target: toMetricTarget(obj["target"]),
  }}
export function fromResourceMetricSource(input: ResourceMetricSource): c.JSONValue {
  return {
    ...input,
    target: input.target != null ? fromMetricTarget(input.target) : undefined,
  }}

/** HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler. */
export interface HorizontalPodAutoscalerStatus {
  conditions: Array<HorizontalPodAutoscalerCondition>;
  currentMetrics?: Array<MetricStatus> | null;
  currentReplicas: number;
  desiredReplicas: number;
  lastScaleTime?: c.Time | null;
  observedGeneration?: number | null;
}
export function toHorizontalPodAutoscalerStatus(input: c.JSONValue): HorizontalPodAutoscalerStatus {
  const obj = c.checkObj(input);
  return {
    conditions: c.readList(obj["conditions"], toHorizontalPodAutoscalerCondition),
    currentMetrics: c.readOpt(obj["currentMetrics"], x => c.readList(x, toMetricStatus)),
    currentReplicas: c.checkNum(obj["currentReplicas"]),
    desiredReplicas: c.checkNum(obj["desiredReplicas"]),
    lastScaleTime: c.readOpt(obj["lastScaleTime"], c.toTime),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
  }}
export function fromHorizontalPodAutoscalerStatus(input: HorizontalPodAutoscalerStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromHorizontalPodAutoscalerCondition),
    currentMetrics: input.currentMetrics?.map(fromMetricStatus),
    lastScaleTime: input.lastScaleTime != null ? c.fromTime(input.lastScaleTime) : undefined,
  }}

/** HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a certain point. */
export interface HorizontalPodAutoscalerCondition {
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toHorizontalPodAutoscalerCondition(input: c.JSONValue): HorizontalPodAutoscalerCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromHorizontalPodAutoscalerCondition(input: HorizontalPodAutoscalerCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** MetricStatus describes the last-read state of a single metric. */
export interface MetricStatus {
  external?: ExternalMetricStatus | null;
  object?: ObjectMetricStatus | null;
  pods?: PodsMetricStatus | null;
  resource?: ResourceMetricStatus | null;
  type: string;
}
export function toMetricStatus(input: c.JSONValue): MetricStatus {
  const obj = c.checkObj(input);
  return {
    external: c.readOpt(obj["external"], toExternalMetricStatus),
    object: c.readOpt(obj["object"], toObjectMetricStatus),
    pods: c.readOpt(obj["pods"], toPodsMetricStatus),
    resource: c.readOpt(obj["resource"], toResourceMetricStatus),
    type: c.checkStr(obj["type"]),
  }}
export function fromMetricStatus(input: MetricStatus): c.JSONValue {
  return {
    ...input,
    external: input.external != null ? fromExternalMetricStatus(input.external) : undefined,
    object: input.object != null ? fromObjectMetricStatus(input.object) : undefined,
    pods: input.pods != null ? fromPodsMetricStatus(input.pods) : undefined,
    resource: input.resource != null ? fromResourceMetricStatus(input.resource) : undefined,
  }}

/** ObjectMetricStatus indicates the current value of a metric describing a kubernetes object (for example, hits-per-second on an Ingress object). */
export interface ObjectMetricStatus {
  current: MetricValueStatus;
  describedObject: CrossVersionObjectReference;
  metric: MetricIdentifier;
}
export function toObjectMetricStatus(input: c.JSONValue): ObjectMetricStatus {
  const obj = c.checkObj(input);
  return {
    current: toMetricValueStatus(obj["current"]),
    describedObject: toCrossVersionObjectReference(obj["describedObject"]),
    metric: toMetricIdentifier(obj["metric"]),
  }}
export function fromObjectMetricStatus(input: ObjectMetricStatus): c.JSONValue {
  return {
    ...input,
    current: input.current != null ? fromMetricValueStatus(input.current) : undefined,
    describedObject: input.describedObject != null ? fromCrossVersionObjectReference(input.describedObject) : undefined,
    metric: input.metric != null ? fromMetricIdentifier(input.metric) : undefined,
  }}

/** PodsMetricStatus indicates the current value of a metric describing each pod in the current scale target (for example, transactions-processed-per-second). */
export interface PodsMetricStatus {
  current: MetricValueStatus;
  metric: MetricIdentifier;
}
export function toPodsMetricStatus(input: c.JSONValue): PodsMetricStatus {
  const obj = c.checkObj(input);
  return {
    current: toMetricValueStatus(obj["current"]),
    metric: toMetricIdentifier(obj["metric"]),
  }}
export function fromPodsMetricStatus(input: PodsMetricStatus): c.JSONValue {
  return {
    ...input,
    current: input.current != null ? fromMetricValueStatus(input.current) : undefined,
    metric: input.metric != null ? fromMetricIdentifier(input.metric) : undefined,
  }}

/** ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the "pods" source. */
export interface ResourceMetricStatus {
  current: MetricValueStatus;
  name: string;
}
export function toResourceMetricStatus(input: c.JSONValue): ResourceMetricStatus {
  const obj = c.checkObj(input);
  return {
    current: toMetricValueStatus(obj["current"]),
    name: c.checkStr(obj["name"]),
  }}
export function fromResourceMetricStatus(input: ResourceMetricStatus): c.JSONValue {
  return {
    ...input,
    current: input.current != null ? fromMetricValueStatus(input.current) : undefined,
  }}

/** HorizontalPodAutoscalerList is a list of horizontal pod autoscaler objects. */
export interface HorizontalPodAutoscalerList extends ListOf<HorizontalPodAutoscaler> {
  apiVersion?: "autoscaling/v2beta2";
  kind?: "HorizontalPodAutoscalerList";
};
export function toHorizontalPodAutoscalerList(input: c.JSONValue): HorizontalPodAutoscalerList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "autoscaling/v2beta2", "HorizontalPodAutoscalerList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toHorizontalPodAutoscaler),
  }}
