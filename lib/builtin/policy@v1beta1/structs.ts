// Autogenerated Schema file for PolicyV1beta1
import * as c from "../../common.ts";

import * as CoreV1 from "../core@v1/structs.ts";
import * as MetaV1 from "../meta@v1/structs.ts";
type Kind<T extends string> = {
  apiVersion: "policy/v1beta1";
  kind: T;
};
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used. */
export interface AllowedCSIDriver {
  name: string;
}
export function toAllowedCSIDriver(input: c.JSONValue): AllowedCSIDriver {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
  }}
export function fromAllowedCSIDriver(input: AllowedCSIDriver): c.JSONValue {
  return {
    ...input,
  }}

/** AllowedFlexVolume represents a single Flexvolume that is allowed to be used. */
export interface AllowedFlexVolume {
  driver: string;
}
export function toAllowedFlexVolume(input: c.JSONValue): AllowedFlexVolume {
  const obj = c.checkObj(input);
  return {
    driver: c.checkStr(obj["driver"]),
  }}
export function fromAllowedFlexVolume(input: AllowedFlexVolume): c.JSONValue {
  return {
    ...input,
  }}

/** AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods to use. It requires the path prefix to be defined. */
export interface AllowedHostPath {
  pathPrefix?: string | null;
  readOnly?: boolean | null;
}
export function toAllowedHostPath(input: c.JSONValue): AllowedHostPath {
  const obj = c.checkObj(input);
  return {
    pathPrefix: c.readOpt(obj["pathPrefix"], c.checkStr),
    readOnly: c.readOpt(obj["readOnly"], c.checkBool),
  }}
export function fromAllowedHostPath(input: AllowedHostPath): c.JSONValue {
  return {
    ...input,
  }}

/** Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions. */
export interface Eviction {
  apiVersion?: string | null;
  deleteOptions?: MetaV1.DeleteOptions | null;
  kind?: string | null;
  metadata?: MetaV1.ObjectMeta | null;
}
export function toEviction(input: c.JSONValue): Eviction {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    deleteOptions: c.readOpt(obj["deleteOptions"], MetaV1.toDeleteOptions),
    kind: c.readOpt(obj["kind"], c.checkStr),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
  }}
export function fromEviction(input: Eviction): c.JSONValue {
  return {
    ...input,
    deleteOptions: input.deleteOptions != null ? MetaV1.fromDeleteOptions(input.deleteOptions) : undefined,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
  }}

/** FSGroupStrategyOptions defines the strategy type and options used to create the strategy. */
export interface FSGroupStrategyOptions {
  ranges?: Array<IDRange> | null;
  rule?: string | null;
}
export function toFSGroupStrategyOptions(input: c.JSONValue): FSGroupStrategyOptions {
  const obj = c.checkObj(input);
  return {
    ranges: c.readOpt(obj["ranges"], x => c.readList(x, toIDRange)),
    rule: c.readOpt(obj["rule"], c.checkStr),
  }}
export function fromFSGroupStrategyOptions(input: FSGroupStrategyOptions): c.JSONValue {
  return {
    ...input,
    ranges: input.ranges?.map(fromIDRange),
  }}

/** IDRange provides a min/max of an allowed range of IDs. */
export interface IDRange {
  max: number;
  min: number;
}
export function toIDRange(input: c.JSONValue): IDRange {
  const obj = c.checkObj(input);
  return {
    max: c.checkNum(obj["max"]),
    min: c.checkNum(obj["min"]),
  }}
export function fromIDRange(input: IDRange): c.JSONValue {
  return {
    ...input,
  }}

/** HostPortRange defines a range of host ports that will be enabled by a policy for pods to use.  It requires both the start and end to be defined. */
export interface HostPortRange {
  max: number;
  min: number;
}
export function toHostPortRange(input: c.JSONValue): HostPortRange {
  const obj = c.checkObj(input);
  return {
    max: c.checkNum(obj["max"]),
    min: c.checkNum(obj["min"]),
  }}
export function fromHostPortRange(input: HostPortRange): c.JSONValue {
  return {
    ...input,
  }}

/** PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods */
export type PodDisruptionBudget = Kind<"PodDisruptionBudget"> & PodDisruptionBudgetFields;
export interface PodDisruptionBudgetFields {
  metadata?: MetaV1.ObjectMeta | null;
  spec?: PodDisruptionBudgetSpec | null;
  status?: PodDisruptionBudgetStatus | null;
}
export function toPodDisruptionBudgetFields(input: c.JSONValue): PodDisruptionBudgetFields {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toPodDisruptionBudgetSpec),
    status: c.readOpt(obj["status"], toPodDisruptionBudgetStatus),
  }}
export function toPodDisruptionBudget(input: c.JSONValue): PodDisruptionBudget {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "policy/v1beta1") throw new Error("Type apiv mis 2");
  if (kind !== "PodDisruptionBudget") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toPodDisruptionBudgetFields(fields),
  }}
export function fromPodDisruptionBudget(input: PodDisruptionBudget): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromPodDisruptionBudgetSpec(input.spec) : undefined,
    status: input.status != null ? fromPodDisruptionBudgetStatus(input.status) : undefined,
  }}

/** PodDisruptionBudgetSpec is a description of a PodDisruptionBudget. */
export interface PodDisruptionBudgetSpec {
  maxUnavailable?: c.IntOrString | null;
  minAvailable?: c.IntOrString | null;
  selector?: MetaV1.LabelSelector | null;
}
export function toPodDisruptionBudgetSpec(input: c.JSONValue): PodDisruptionBudgetSpec {
  const obj = c.checkObj(input);
  return {
    maxUnavailable: c.readOpt(obj["maxUnavailable"], c.toIntOrString),
    minAvailable: c.readOpt(obj["minAvailable"], c.toIntOrString),
    selector: c.readOpt(obj["selector"], MetaV1.toLabelSelector),
  }}
export function fromPodDisruptionBudgetSpec(input: PodDisruptionBudgetSpec): c.JSONValue {
  return {
    ...input,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
  }}

/** PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system. */
export interface PodDisruptionBudgetStatus {
  currentHealthy: number;
  desiredHealthy: number;
  disruptedPods?: Record<string,c.Time> | null;
  disruptionsAllowed: number;
  expectedPods: number;
  observedGeneration?: number | null;
}
export function toPodDisruptionBudgetStatus(input: c.JSONValue): PodDisruptionBudgetStatus {
  const obj = c.checkObj(input);
  return {
    currentHealthy: c.checkNum(obj["currentHealthy"]),
    desiredHealthy: c.checkNum(obj["desiredHealthy"]),
    disruptedPods: c.readOpt(obj["disruptedPods"], x => c.readMap(x, c.toTime)),
    disruptionsAllowed: c.checkNum(obj["disruptionsAllowed"]),
    expectedPods: c.checkNum(obj["expectedPods"]),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
  }}
export function fromPodDisruptionBudgetStatus(input: PodDisruptionBudgetStatus): c.JSONValue {
  return {
    ...input,
    disruptedPods: c.writeMap(input.disruptedPods, c.fromTime),
  }}

/** PodDisruptionBudgetList is a collection of PodDisruptionBudgets. */
export type PodDisruptionBudgetList = Kind<"PodDisruptionBudgetList"> & ListOf<PodDisruptionBudgetFields>;
export function toPodDisruptionBudgetList(input: c.JSONValue): PodDisruptionBudgetList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "policy/v1beta1") throw new Error("Type apiv mis 2");
  if (kind !== "PodDisruptionBudgetList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toPodDisruptionBudgetFields),
  }}

/** PodSecurityPolicy governs the ability to make requests that affect the Security Context that will be applied to a pod and container. */
export type PodSecurityPolicy = Kind<"PodSecurityPolicy"> & PodSecurityPolicyFields;
export interface PodSecurityPolicyFields {
  metadata?: MetaV1.ObjectMeta | null;
  spec?: PodSecurityPolicySpec | null;
}
export function toPodSecurityPolicyFields(input: c.JSONValue): PodSecurityPolicyFields {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toPodSecurityPolicySpec),
  }}
export function toPodSecurityPolicy(input: c.JSONValue): PodSecurityPolicy {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "policy/v1beta1") throw new Error("Type apiv mis 2");
  if (kind !== "PodSecurityPolicy") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toPodSecurityPolicyFields(fields),
  }}
export function fromPodSecurityPolicy(input: PodSecurityPolicy): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromPodSecurityPolicySpec(input.spec) : undefined,
  }}

/** PodSecurityPolicySpec defines the policy enforced. */
export interface PodSecurityPolicySpec {
  allowPrivilegeEscalation?: boolean | null;
  allowedCSIDrivers?: Array<AllowedCSIDriver> | null;
  allowedCapabilities?: Array<string> | null;
  allowedFlexVolumes?: Array<AllowedFlexVolume> | null;
  allowedHostPaths?: Array<AllowedHostPath> | null;
  allowedProcMountTypes?: Array<string> | null;
  allowedUnsafeSysctls?: Array<string> | null;
  defaultAddCapabilities?: Array<string> | null;
  defaultAllowPrivilegeEscalation?: boolean | null;
  forbiddenSysctls?: Array<string> | null;
  fsGroup: FSGroupStrategyOptions;
  hostIPC?: boolean | null;
  hostNetwork?: boolean | null;
  hostPID?: boolean | null;
  hostPorts?: Array<HostPortRange> | null;
  privileged?: boolean | null;
  readOnlyRootFilesystem?: boolean | null;
  requiredDropCapabilities?: Array<string> | null;
  runAsGroup?: RunAsGroupStrategyOptions | null;
  runAsUser: RunAsUserStrategyOptions;
  runtimeClass?: RuntimeClassStrategyOptions | null;
  seLinux: SELinuxStrategyOptions;
  supplementalGroups: SupplementalGroupsStrategyOptions;
  volumes?: Array<string> | null;
}
export function toPodSecurityPolicySpec(input: c.JSONValue): PodSecurityPolicySpec {
  const obj = c.checkObj(input);
  return {
    allowPrivilegeEscalation: c.readOpt(obj["allowPrivilegeEscalation"], c.checkBool),
    allowedCSIDrivers: c.readOpt(obj["allowedCSIDrivers"], x => c.readList(x, toAllowedCSIDriver)),
    allowedCapabilities: c.readOpt(obj["allowedCapabilities"], x => c.readList(x, c.checkStr)),
    allowedFlexVolumes: c.readOpt(obj["allowedFlexVolumes"], x => c.readList(x, toAllowedFlexVolume)),
    allowedHostPaths: c.readOpt(obj["allowedHostPaths"], x => c.readList(x, toAllowedHostPath)),
    allowedProcMountTypes: c.readOpt(obj["allowedProcMountTypes"], x => c.readList(x, c.checkStr)),
    allowedUnsafeSysctls: c.readOpt(obj["allowedUnsafeSysctls"], x => c.readList(x, c.checkStr)),
    defaultAddCapabilities: c.readOpt(obj["defaultAddCapabilities"], x => c.readList(x, c.checkStr)),
    defaultAllowPrivilegeEscalation: c.readOpt(obj["defaultAllowPrivilegeEscalation"], c.checkBool),
    forbiddenSysctls: c.readOpt(obj["forbiddenSysctls"], x => c.readList(x, c.checkStr)),
    fsGroup: toFSGroupStrategyOptions(obj["fsGroup"]),
    hostIPC: c.readOpt(obj["hostIPC"], c.checkBool),
    hostNetwork: c.readOpt(obj["hostNetwork"], c.checkBool),
    hostPID: c.readOpt(obj["hostPID"], c.checkBool),
    hostPorts: c.readOpt(obj["hostPorts"], x => c.readList(x, toHostPortRange)),
    privileged: c.readOpt(obj["privileged"], c.checkBool),
    readOnlyRootFilesystem: c.readOpt(obj["readOnlyRootFilesystem"], c.checkBool),
    requiredDropCapabilities: c.readOpt(obj["requiredDropCapabilities"], x => c.readList(x, c.checkStr)),
    runAsGroup: c.readOpt(obj["runAsGroup"], toRunAsGroupStrategyOptions),
    runAsUser: toRunAsUserStrategyOptions(obj["runAsUser"]),
    runtimeClass: c.readOpt(obj["runtimeClass"], toRuntimeClassStrategyOptions),
    seLinux: toSELinuxStrategyOptions(obj["seLinux"]),
    supplementalGroups: toSupplementalGroupsStrategyOptions(obj["supplementalGroups"]),
    volumes: c.readOpt(obj["volumes"], x => c.readList(x, c.checkStr)),
  }}
export function fromPodSecurityPolicySpec(input: PodSecurityPolicySpec): c.JSONValue {
  return {
    ...input,
    allowedCSIDrivers: input.allowedCSIDrivers?.map(fromAllowedCSIDriver),
    allowedFlexVolumes: input.allowedFlexVolumes?.map(fromAllowedFlexVolume),
    allowedHostPaths: input.allowedHostPaths?.map(fromAllowedHostPath),
    fsGroup: input.fsGroup != null ? fromFSGroupStrategyOptions(input.fsGroup) : undefined,
    hostPorts: input.hostPorts?.map(fromHostPortRange),
    runAsGroup: input.runAsGroup != null ? fromRunAsGroupStrategyOptions(input.runAsGroup) : undefined,
    runAsUser: input.runAsUser != null ? fromRunAsUserStrategyOptions(input.runAsUser) : undefined,
    runtimeClass: input.runtimeClass != null ? fromRuntimeClassStrategyOptions(input.runtimeClass) : undefined,
    seLinux: input.seLinux != null ? fromSELinuxStrategyOptions(input.seLinux) : undefined,
    supplementalGroups: input.supplementalGroups != null ? fromSupplementalGroupsStrategyOptions(input.supplementalGroups) : undefined,
  }}

/** RunAsGroupStrategyOptions defines the strategy type and any options used to create the strategy. */
export interface RunAsGroupStrategyOptions {
  ranges?: Array<IDRange> | null;
  rule: string;
}
export function toRunAsGroupStrategyOptions(input: c.JSONValue): RunAsGroupStrategyOptions {
  const obj = c.checkObj(input);
  return {
    ranges: c.readOpt(obj["ranges"], x => c.readList(x, toIDRange)),
    rule: c.checkStr(obj["rule"]),
  }}
export function fromRunAsGroupStrategyOptions(input: RunAsGroupStrategyOptions): c.JSONValue {
  return {
    ...input,
    ranges: input.ranges?.map(fromIDRange),
  }}

/** RunAsUserStrategyOptions defines the strategy type and any options used to create the strategy. */
export interface RunAsUserStrategyOptions {
  ranges?: Array<IDRange> | null;
  rule: string;
}
export function toRunAsUserStrategyOptions(input: c.JSONValue): RunAsUserStrategyOptions {
  const obj = c.checkObj(input);
  return {
    ranges: c.readOpt(obj["ranges"], x => c.readList(x, toIDRange)),
    rule: c.checkStr(obj["rule"]),
  }}
export function fromRunAsUserStrategyOptions(input: RunAsUserStrategyOptions): c.JSONValue {
  return {
    ...input,
    ranges: input.ranges?.map(fromIDRange),
  }}

/** RuntimeClassStrategyOptions define the strategy that will dictate the allowable RuntimeClasses for a pod. */
export interface RuntimeClassStrategyOptions {
  allowedRuntimeClassNames: Array<string>;
  defaultRuntimeClassName?: string | null;
}
export function toRuntimeClassStrategyOptions(input: c.JSONValue): RuntimeClassStrategyOptions {
  const obj = c.checkObj(input);
  return {
    allowedRuntimeClassNames: c.readList(obj["allowedRuntimeClassNames"], c.checkStr),
    defaultRuntimeClassName: c.readOpt(obj["defaultRuntimeClassName"], c.checkStr),
  }}
export function fromRuntimeClassStrategyOptions(input: RuntimeClassStrategyOptions): c.JSONValue {
  return {
    ...input,
  }}

/** SELinuxStrategyOptions defines the strategy type and any options used to create the strategy. */
export interface SELinuxStrategyOptions {
  rule: string;
  seLinuxOptions?: CoreV1.SELinuxOptions | null;
}
export function toSELinuxStrategyOptions(input: c.JSONValue): SELinuxStrategyOptions {
  const obj = c.checkObj(input);
  return {
    rule: c.checkStr(obj["rule"]),
    seLinuxOptions: c.readOpt(obj["seLinuxOptions"], CoreV1.toSELinuxOptions),
  }}
export function fromSELinuxStrategyOptions(input: SELinuxStrategyOptions): c.JSONValue {
  return {
    ...input,
    seLinuxOptions: input.seLinuxOptions != null ? CoreV1.fromSELinuxOptions(input.seLinuxOptions) : undefined,
  }}

/** SupplementalGroupsStrategyOptions defines the strategy type and options used to create the strategy. */
export interface SupplementalGroupsStrategyOptions {
  ranges?: Array<IDRange> | null;
  rule?: string | null;
}
export function toSupplementalGroupsStrategyOptions(input: c.JSONValue): SupplementalGroupsStrategyOptions {
  const obj = c.checkObj(input);
  return {
    ranges: c.readOpt(obj["ranges"], x => c.readList(x, toIDRange)),
    rule: c.readOpt(obj["rule"], c.checkStr),
  }}
export function fromSupplementalGroupsStrategyOptions(input: SupplementalGroupsStrategyOptions): c.JSONValue {
  return {
    ...input,
    ranges: input.ranges?.map(fromIDRange),
  }}

/** PodSecurityPolicyList is a list of PodSecurityPolicy objects. */
export type PodSecurityPolicyList = Kind<"PodSecurityPolicyList"> & ListOf<PodSecurityPolicyFields>;
export function toPodSecurityPolicyList(input: c.JSONValue): PodSecurityPolicyList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "policy/v1beta1") throw new Error("Type apiv mis 2");
  if (kind !== "PodSecurityPolicyList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toPodSecurityPolicyFields),
  }}
