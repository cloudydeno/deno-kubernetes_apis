// Autogenerated Schema file for CertificatesV1
import * as c from "../../common.ts";

import * as MetaV1 from "../meta@v1/structs.ts";
type Kind<T extends string> = {
  apiVersion: "certificates.k8s.io/v1";
  kind: T;
};
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.

Kubelets use this API to obtain:
 1. client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client-kubelet" signerName).
 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the "kubernetes.io/kubelet-serving" signerName).

This API can be used to request client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client" signerName), or to obtain certificates from custom non-Kubernetes signers. */
export type CertificateSigningRequest = Kind<"CertificateSigningRequest"> & CertificateSigningRequestFields;
export interface CertificateSigningRequestFields {
  metadata?: MetaV1.ObjectMeta | null;
  spec: CertificateSigningRequestSpec;
  status?: CertificateSigningRequestStatus | null;
}
export function toCertificateSigningRequestFields(input: c.JSONValue): CertificateSigningRequestFields {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toCertificateSigningRequestSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toCertificateSigningRequestStatus),
  }}
export function toCertificateSigningRequest(input: c.JSONValue): CertificateSigningRequest {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "certificates.k8s.io/v1") throw new Error("Type apiv mis 2");
  if (kind !== "CertificateSigningRequest") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toCertificateSigningRequestFields(fields),
  }}
export function fromCertificateSigningRequest(input: CertificateSigningRequest): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromCertificateSigningRequestSpec(input.spec) : undefined,
    status: input.status != null ? fromCertificateSigningRequestStatus(input.status) : undefined,
  }}

/** CertificateSigningRequestSpec contains the certificate request. */
export interface CertificateSigningRequestSpec {
  extra?: Record<string,Array<string>> | null;
  groups?: Array<string> | null;
  request: string;
  signerName: string;
  uid?: string | null;
  usages?: Array<string> | null;
  username?: string | null;
}
export function toCertificateSigningRequestSpec(input: c.JSONValue): CertificateSigningRequestSpec {
  const obj = c.checkObj(input);
  return {
    extra: c.readOpt(obj["extra"], y => c.readMap(y, x => c.readList(x, c.checkStr))),
    groups: c.readOpt(obj["groups"], x => c.readList(x, c.checkStr)),
    request: c.checkStr(obj["request"]),
    signerName: c.checkStr(obj["signerName"]),
    uid: c.readOpt(obj["uid"], c.checkStr),
    usages: c.readOpt(obj["usages"], x => c.readList(x, c.checkStr)),
    username: c.readOpt(obj["username"], c.checkStr),
  }}
export function fromCertificateSigningRequestSpec(input: CertificateSigningRequestSpec): c.JSONValue {
  return {
    ...input,
  }}

/** CertificateSigningRequestStatus contains conditions used to indicate approved/denied/failed status of the request, and the issued certificate. */
export interface CertificateSigningRequestStatus {
  certificate?: string | null;
  conditions?: Array<CertificateSigningRequestCondition> | null;
}
export function toCertificateSigningRequestStatus(input: c.JSONValue): CertificateSigningRequestStatus {
  const obj = c.checkObj(input);
  return {
    certificate: c.readOpt(obj["certificate"], c.checkStr),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toCertificateSigningRequestCondition)),
  }}
export function fromCertificateSigningRequestStatus(input: CertificateSigningRequestStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromCertificateSigningRequestCondition),
  }}

/** CertificateSigningRequestCondition describes a condition of a CertificateSigningRequest object */
export interface CertificateSigningRequestCondition {
  lastTransitionTime?: c.Time | null;
  lastUpdateTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toCertificateSigningRequestCondition(input: c.JSONValue): CertificateSigningRequestCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    lastUpdateTime: c.readOpt(obj["lastUpdateTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromCertificateSigningRequestCondition(input: CertificateSigningRequestCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
    lastUpdateTime: input.lastUpdateTime != null ? c.fromTime(input.lastUpdateTime) : undefined,
  }}

/** CertificateSigningRequestList is a collection of CertificateSigningRequest objects */
export type CertificateSigningRequestList = Kind<"CertificateSigningRequestList"> & ListOf<CertificateSigningRequestFields>;
export function toCertificateSigningRequestList(input: c.JSONValue): CertificateSigningRequestList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "certificates.k8s.io/v1") throw new Error("Type apiv mis 2");
  if (kind !== "CertificateSigningRequestList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toCertificateSigningRequestFields),
  }}
