// Autogenerated Schema file for AuthenticationV1
import * as c from "../../common.ts";

import * as MetaV1 from "../meta@v1/structs.ts";
type Kind<T extends string> = {
  apiVersion: "authentication.k8s.io/v1";
  kind: T;
};
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** BoundObjectReference is a reference to an object that a token is bound to. */
export interface BoundObjectReference {
  apiVersion?: string | null;
  kind?: string | null;
  name?: string | null;
  uid?: string | null;
}
export function toBoundObjectReference(input: c.JSONValue): BoundObjectReference {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.readOpt(obj["name"], c.checkStr),
    uid: c.readOpt(obj["uid"], c.checkStr),
  }}
export function fromBoundObjectReference(input: BoundObjectReference): c.JSONValue {
  return {
    ...input,
  }}

/** TokenRequest requests a token for a given service account. */
export interface TokenRequest {
  apiVersion?: string | null;
  kind?: string | null;
  metadata?: MetaV1.ObjectMeta | null;
  spec: TokenRequestSpec;
  status?: TokenRequestStatus | null;
}
export function toTokenRequest(input: c.JSONValue): TokenRequest {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toTokenRequestSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toTokenRequestStatus),
  }}
export function fromTokenRequest(input: TokenRequest): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromTokenRequestSpec(input.spec) : undefined,
    status: input.status != null ? fromTokenRequestStatus(input.status) : undefined,
  }}

/** TokenRequestSpec contains client provided parameters of a token request. */
export interface TokenRequestSpec {
  audiences: Array<string>;
  boundObjectRef?: BoundObjectReference | null;
  expirationSeconds?: number | null;
}
export function toTokenRequestSpec(input: c.JSONValue): TokenRequestSpec {
  const obj = c.checkObj(input);
  return {
    audiences: c.readList(obj["audiences"], c.checkStr),
    boundObjectRef: c.readOpt(obj["boundObjectRef"], toBoundObjectReference),
    expirationSeconds: c.readOpt(obj["expirationSeconds"], c.checkNum),
  }}
export function fromTokenRequestSpec(input: TokenRequestSpec): c.JSONValue {
  return {
    ...input,
    boundObjectRef: input.boundObjectRef != null ? fromBoundObjectReference(input.boundObjectRef) : undefined,
  }}

/** TokenRequestStatus is the result of a token request. */
export interface TokenRequestStatus {
  expirationTimestamp: c.Time;
  token: string;
}
export function toTokenRequestStatus(input: c.JSONValue): TokenRequestStatus {
  const obj = c.checkObj(input);
  return {
    expirationTimestamp: c.toTime(obj["expirationTimestamp"]),
    token: c.checkStr(obj["token"]),
  }}
export function fromTokenRequestStatus(input: TokenRequestStatus): c.JSONValue {
  return {
    ...input,
    expirationTimestamp: input.expirationTimestamp != null ? c.fromTime(input.expirationTimestamp) : undefined,
  }}

/** TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver. */
export interface TokenReview {
  apiVersion?: "authentication.k8s.io/v1";
  kind?: "TokenReview";
  metadata?: MetaV1.ObjectMeta | null;
  spec: TokenReviewSpec;
  status?: TokenReviewStatus | null;
}
export function toTokenReview(input: c.JSONValue): TokenReview & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "authentication.k8s.io/v1", "TokenReview"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toTokenReviewSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toTokenReviewStatus),
  }}
export function fromTokenReview(input: TokenReview): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "authentication.k8s.io/v1", "TokenReview"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromTokenReviewSpec(input.spec) : undefined,
    status: input.status != null ? fromTokenReviewStatus(input.status) : undefined,
  }}

/** TokenReviewSpec is a description of the token authentication request. */
export interface TokenReviewSpec {
  audiences?: Array<string> | null;
  token?: string | null;
}
export function toTokenReviewSpec(input: c.JSONValue): TokenReviewSpec {
  const obj = c.checkObj(input);
  return {
    audiences: c.readOpt(obj["audiences"], x => c.readList(x, c.checkStr)),
    token: c.readOpt(obj["token"], c.checkStr),
  }}
export function fromTokenReviewSpec(input: TokenReviewSpec): c.JSONValue {
  return {
    ...input,
  }}

/** TokenReviewStatus is the result of the token authentication request. */
export interface TokenReviewStatus {
  audiences?: Array<string> | null;
  authenticated?: boolean | null;
  error?: string | null;
  user?: UserInfo | null;
}
export function toTokenReviewStatus(input: c.JSONValue): TokenReviewStatus {
  const obj = c.checkObj(input);
  return {
    audiences: c.readOpt(obj["audiences"], x => c.readList(x, c.checkStr)),
    authenticated: c.readOpt(obj["authenticated"], c.checkBool),
    error: c.readOpt(obj["error"], c.checkStr),
    user: c.readOpt(obj["user"], toUserInfo),
  }}
export function fromTokenReviewStatus(input: TokenReviewStatus): c.JSONValue {
  return {
    ...input,
    user: input.user != null ? fromUserInfo(input.user) : undefined,
  }}

/** UserInfo holds the information about the user needed to implement the user.Info interface. */
export interface UserInfo {
  extra?: Record<string,Array<string>> | null;
  groups?: Array<string> | null;
  uid?: string | null;
  username?: string | null;
}
export function toUserInfo(input: c.JSONValue): UserInfo {
  const obj = c.checkObj(input);
  return {
    extra: c.readOpt(obj["extra"], y => c.readMap(y, x => c.readList(x, c.checkStr))),
    groups: c.readOpt(obj["groups"], x => c.readList(x, c.checkStr)),
    uid: c.readOpt(obj["uid"], c.checkStr),
    username: c.readOpt(obj["username"], c.checkStr),
  }}
export function fromUserInfo(input: UserInfo): c.JSONValue {
  return {
    ...input,
  }}
