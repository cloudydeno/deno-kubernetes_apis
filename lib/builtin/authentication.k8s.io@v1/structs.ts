// Autogenerated Schema file for AuthenticationV1
import * as c from "../../common.ts";

import * as MetaV1 from "../meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** BoundObjectReference is a reference to an object that a token is bound to. */
export interface BoundObjectReference {
  apiVersion?: string | null;
  kind?: string | null;
  name?: string | null;
  uid?: string | null;
}
export function toBoundObjectReference(input: c.JSONValue): BoundObjectReference {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.readOpt(obj["name"], c.checkStr),
    uid: c.readOpt(obj["uid"], c.checkStr),
  }}
export function fromBoundObjectReference(input: BoundObjectReference): c.JSONValue {
  return {
    ...input,
  }}

/** SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase. */
export interface SelfSubjectReview {
  apiVersion?: "authentication.k8s.io/v1";
  kind?: "SelfSubjectReview";
  metadata?: MetaV1.ObjectMeta | null;
  status?: SelfSubjectReviewStatus | null;
}
export function toSelfSubjectReview(input: c.JSONValue): SelfSubjectReview & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "authentication.k8s.io/v1", "SelfSubjectReview"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    status: c.readOpt(obj["status"], toSelfSubjectReviewStatus),
  }}
export function fromSelfSubjectReview(input: SelfSubjectReview): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "authentication.k8s.io/v1", "SelfSubjectReview"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    status: input.status != null ? fromSelfSubjectReviewStatus(input.status) : undefined,
  }}

/** SelfSubjectReviewStatus is filled by the kube-apiserver and sent back to a user. */
export interface SelfSubjectReviewStatus {
  userInfo?: UserInfo | null;
}
export function toSelfSubjectReviewStatus(input: c.JSONValue): SelfSubjectReviewStatus {
  const obj = c.checkObj(input);
  return {
    userInfo: c.readOpt(obj["userInfo"], toUserInfo),
  }}
export function fromSelfSubjectReviewStatus(input: SelfSubjectReviewStatus): c.JSONValue {
  return {
    ...input,
    userInfo: input.userInfo != null ? fromUserInfo(input.userInfo) : undefined,
  }}

/** UserInfo holds the information about the user needed to implement the user.Info interface. */
export interface UserInfo {
  extra?: Record<string,Array<string>> | null;
  groups?: Array<string> | null;
  uid?: string | null;
  username?: string | null;
}
export function toUserInfo(input: c.JSONValue): UserInfo {
  const obj = c.checkObj(input);
  return {
    extra: c.readOpt(obj["extra"], y => c.readMap(y, x => c.readList(x, c.checkStr))),
    groups: c.readOpt(obj["groups"], x => c.readList(x, c.checkStr)),
    uid: c.readOpt(obj["uid"], c.checkStr),
    username: c.readOpt(obj["username"], c.checkStr),
  }}
export function fromUserInfo(input: UserInfo): c.JSONValue {
  return {
    ...input,
  }}

/** TokenRequest requests a token for a given service account. */
export interface TokenRequest {
  apiVersion?: string | null;
  kind?: string | null;
  metadata?: MetaV1.ObjectMeta | null;
  spec: TokenRequestSpec;
  status?: TokenRequestStatus | null;
}
export function toTokenRequest(input: c.JSONValue): TokenRequest {
  const obj = c.checkObj(input);
  return {
    apiVersion: c.readOpt(obj["apiVersion"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toTokenRequestSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toTokenRequestStatus),
  }}
export function fromTokenRequest(input: TokenRequest): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromTokenRequestSpec(input.spec) : undefined,
    status: input.status != null ? fromTokenRequestStatus(input.status) : undefined,
  }}

/** TokenRequestSpec contains client provided parameters of a token request. */
export interface TokenRequestSpec {
  audiences: Array<string>;
  boundObjectRef?: BoundObjectReference | null;
  expirationSeconds?: number | null;
}
export function toTokenRequestSpec(input: c.JSONValue): TokenRequestSpec {
  const obj = c.checkObj(input);
  return {
    audiences: c.readList(obj["audiences"], c.checkStr),
    boundObjectRef: c.readOpt(obj["boundObjectRef"], toBoundObjectReference),
    expirationSeconds: c.readOpt(obj["expirationSeconds"], c.checkNum),
  }}
export function fromTokenRequestSpec(input: TokenRequestSpec): c.JSONValue {
  return {
    ...input,
    boundObjectRef: input.boundObjectRef != null ? fromBoundObjectReference(input.boundObjectRef) : undefined,
  }}

/** TokenRequestStatus is the result of a token request. */
export interface TokenRequestStatus {
  expirationTimestamp: c.Time;
  token: string;
}
export function toTokenRequestStatus(input: c.JSONValue): TokenRequestStatus {
  const obj = c.checkObj(input);
  return {
    expirationTimestamp: c.toTime(obj["expirationTimestamp"]),
    token: c.checkStr(obj["token"]),
  }}
export function fromTokenRequestStatus(input: TokenRequestStatus): c.JSONValue {
  return {
    ...input,
    expirationTimestamp: input.expirationTimestamp != null ? c.fromTime(input.expirationTimestamp) : undefined,
  }}

/** TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver. */
export interface TokenReview {
  apiVersion?: "authentication.k8s.io/v1";
  kind?: "TokenReview";
  metadata?: MetaV1.ObjectMeta | null;
  spec: TokenReviewSpec;
  status?: TokenReviewStatus | null;
}
export function toTokenReview(input: c.JSONValue): TokenReview & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "authentication.k8s.io/v1", "TokenReview"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toTokenReviewSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toTokenReviewStatus),
  }}
export function fromTokenReview(input: TokenReview): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "authentication.k8s.io/v1", "TokenReview"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromTokenReviewSpec(input.spec) : undefined,
    status: input.status != null ? fromTokenReviewStatus(input.status) : undefined,
  }}

/** TokenReviewSpec is a description of the token authentication request. */
export interface TokenReviewSpec {
  audiences?: Array<string> | null;
  token?: string | null;
}
export function toTokenReviewSpec(input: c.JSONValue): TokenReviewSpec {
  const obj = c.checkObj(input);
  return {
    audiences: c.readOpt(obj["audiences"], x => c.readList(x, c.checkStr)),
    token: c.readOpt(obj["token"], c.checkStr),
  }}
export function fromTokenReviewSpec(input: TokenReviewSpec): c.JSONValue {
  return {
    ...input,
  }}

/** TokenReviewStatus is the result of the token authentication request. */
export interface TokenReviewStatus {
  audiences?: Array<string> | null;
  authenticated?: boolean | null;
  error?: string | null;
  user?: UserInfo | null;
}
export function toTokenReviewStatus(input: c.JSONValue): TokenReviewStatus {
  const obj = c.checkObj(input);
  return {
    audiences: c.readOpt(obj["audiences"], x => c.readList(x, c.checkStr)),
    authenticated: c.readOpt(obj["authenticated"], c.checkBool),
    error: c.readOpt(obj["error"], c.checkStr),
    user: c.readOpt(obj["user"], toUserInfo),
  }}
export function fromTokenReviewStatus(input: TokenReviewStatus): c.JSONValue {
  return {
    ...input,
    user: input.user != null ? fromUserInfo(input.user) : undefined,
  }}
