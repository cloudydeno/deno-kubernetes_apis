// Autogenerated Schema file for ResourceV1alpha1
import * as c from "../../common.ts";

import * as CoreV1 from "../core@v1/structs.ts";
import * as MetaV1 from "../meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** AllocationResult contains attributed of an allocated resource. */
export interface AllocationResult {
  availableOnNodes?: CoreV1.NodeSelector | null;
  resourceHandle?: string | null;
  shareable?: boolean | null;
}
export function toAllocationResult(input: c.JSONValue): AllocationResult {
  const obj = c.checkObj(input);
  return {
    availableOnNodes: c.readOpt(obj["availableOnNodes"], CoreV1.toNodeSelector),
    resourceHandle: c.readOpt(obj["resourceHandle"], c.checkStr),
    shareable: c.readOpt(obj["shareable"], c.checkBool),
  }}
export function fromAllocationResult(input: AllocationResult): c.JSONValue {
  return {
    ...input,
    availableOnNodes: input.availableOnNodes != null ? CoreV1.fromNodeSelector(input.availableOnNodes) : undefined,
  }}

/** PodScheduling objects hold information that is needed to schedule a Pod with ResourceClaims that use "WaitForFirstConsumer" allocation mode.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface PodScheduling {
  apiVersion?: "resource.k8s.io/v1alpha1";
  kind?: "PodScheduling";
  metadata?: MetaV1.ObjectMeta | null;
  spec: PodSchedulingSpec;
  status?: PodSchedulingStatus | null;
}
export function toPodScheduling(input: c.JSONValue): PodScheduling & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha1", "PodScheduling"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toPodSchedulingSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toPodSchedulingStatus),
  }}
export function fromPodScheduling(input: PodScheduling): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha1", "PodScheduling"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromPodSchedulingSpec(input.spec) : undefined,
    status: input.status != null ? fromPodSchedulingStatus(input.status) : undefined,
  }}

/** PodSchedulingSpec describes where resources for the Pod are needed. */
export interface PodSchedulingSpec {
  potentialNodes?: Array<string> | null;
  selectedNode?: string | null;
}
export function toPodSchedulingSpec(input: c.JSONValue): PodSchedulingSpec {
  const obj = c.checkObj(input);
  return {
    potentialNodes: c.readOpt(obj["potentialNodes"], x => c.readList(x, c.checkStr)),
    selectedNode: c.readOpt(obj["selectedNode"], c.checkStr),
  }}
export function fromPodSchedulingSpec(input: PodSchedulingSpec): c.JSONValue {
  return {
    ...input,
  }}

/** PodSchedulingStatus describes where resources for the Pod can be allocated. */
export interface PodSchedulingStatus {
  resourceClaims?: Array<ResourceClaimSchedulingStatus> | null;
}
export function toPodSchedulingStatus(input: c.JSONValue): PodSchedulingStatus {
  const obj = c.checkObj(input);
  return {
    resourceClaims: c.readOpt(obj["resourceClaims"], x => c.readList(x, toResourceClaimSchedulingStatus)),
  }}
export function fromPodSchedulingStatus(input: PodSchedulingStatus): c.JSONValue {
  return {
    ...input,
    resourceClaims: input.resourceClaims?.map(fromResourceClaimSchedulingStatus),
  }}

/** ResourceClaimSchedulingStatus contains information about one particular ResourceClaim with "WaitForFirstConsumer" allocation mode. */
export interface ResourceClaimSchedulingStatus {
  name?: string | null;
  unsuitableNodes?: Array<string> | null;
}
export function toResourceClaimSchedulingStatus(input: c.JSONValue): ResourceClaimSchedulingStatus {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    unsuitableNodes: c.readOpt(obj["unsuitableNodes"], x => c.readList(x, c.checkStr)),
  }}
export function fromResourceClaimSchedulingStatus(input: ResourceClaimSchedulingStatus): c.JSONValue {
  return {
    ...input,
  }}

/** PodSchedulingList is a collection of Pod scheduling objects. */
export interface PodSchedulingList extends ListOf<PodScheduling> {
  apiVersion?: "resource.k8s.io/v1alpha1";
  kind?: "PodSchedulingList";
};
export function toPodSchedulingList(input: c.JSONValue): PodSchedulingList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha1", "PodSchedulingList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toPodScheduling),
  }}

/** ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface ResourceClaim {
  apiVersion?: "resource.k8s.io/v1alpha1";
  kind?: "ResourceClaim";
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimSpec;
  status?: ResourceClaimStatus | null;
}
export function toResourceClaim(input: c.JSONValue): ResourceClaim & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha1", "ResourceClaim"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toResourceClaimStatus),
  }}
export function fromResourceClaim(input: ResourceClaim): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha1", "ResourceClaim"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimSpec(input.spec) : undefined,
    status: input.status != null ? fromResourceClaimStatus(input.status) : undefined,
  }}

/** ResourceClaimSpec defines how a resource is to be allocated. */
export interface ResourceClaimSpec {
  allocationMode?: string | null;
  parametersRef?: ResourceClaimParametersReference | null;
  resourceClassName: string;
}
export function toResourceClaimSpec(input: c.JSONValue): ResourceClaimSpec {
  const obj = c.checkObj(input);
  return {
    allocationMode: c.readOpt(obj["allocationMode"], c.checkStr),
    parametersRef: c.readOpt(obj["parametersRef"], toResourceClaimParametersReference),
    resourceClassName: c.checkStr(obj["resourceClassName"]),
  }}
export function fromResourceClaimSpec(input: ResourceClaimSpec): c.JSONValue {
  return {
    ...input,
    parametersRef: input.parametersRef != null ? fromResourceClaimParametersReference(input.parametersRef) : undefined,
  }}

/** ResourceClaimParametersReference contains enough information to let you locate the parameters for a ResourceClaim. The object must be in the same namespace as the ResourceClaim. */
export interface ResourceClaimParametersReference {
  apiGroup?: string | null;
  kind: string;
  name: string;
}
export function toResourceClaimParametersReference(input: c.JSONValue): ResourceClaimParametersReference {
  const obj = c.checkObj(input);
  return {
    apiGroup: c.readOpt(obj["apiGroup"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
  }}
export function fromResourceClaimParametersReference(input: ResourceClaimParametersReference): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceClaimStatus tracks whether the resource has been allocated and what the resulting attributes are. */
export interface ResourceClaimStatus {
  allocation?: AllocationResult | null;
  deallocationRequested?: boolean | null;
  driverName?: string | null;
  reservedFor?: Array<ResourceClaimConsumerReference> | null;
}
export function toResourceClaimStatus(input: c.JSONValue): ResourceClaimStatus {
  const obj = c.checkObj(input);
  return {
    allocation: c.readOpt(obj["allocation"], toAllocationResult),
    deallocationRequested: c.readOpt(obj["deallocationRequested"], c.checkBool),
    driverName: c.readOpt(obj["driverName"], c.checkStr),
    reservedFor: c.readOpt(obj["reservedFor"], x => c.readList(x, toResourceClaimConsumerReference)),
  }}
export function fromResourceClaimStatus(input: ResourceClaimStatus): c.JSONValue {
  return {
    ...input,
    allocation: input.allocation != null ? fromAllocationResult(input.allocation) : undefined,
    reservedFor: input.reservedFor?.map(fromResourceClaimConsumerReference),
  }}

/** ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim. */
export interface ResourceClaimConsumerReference {
  apiGroup?: string | null;
  name: string;
  resource: string;
  uid: string;
}
export function toResourceClaimConsumerReference(input: c.JSONValue): ResourceClaimConsumerReference {
  const obj = c.checkObj(input);
  return {
    apiGroup: c.readOpt(obj["apiGroup"], c.checkStr),
    name: c.checkStr(obj["name"]),
    resource: c.checkStr(obj["resource"]),
    uid: c.checkStr(obj["uid"]),
  }}
export function fromResourceClaimConsumerReference(input: ResourceClaimConsumerReference): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceClaimList is a collection of claims. */
export interface ResourceClaimList extends ListOf<ResourceClaim> {
  apiVersion?: "resource.k8s.io/v1alpha1";
  kind?: "ResourceClaimList";
};
export function toResourceClaimList(input: c.JSONValue): ResourceClaimList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha1", "ResourceClaimList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClaim),
  }}

/** ResourceClaimTemplate is used to produce ResourceClaim objects. */
export interface ResourceClaimTemplate {
  apiVersion?: "resource.k8s.io/v1alpha1";
  kind?: "ResourceClaimTemplate";
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimTemplateSpec;
}
export function toResourceClaimTemplate(input: c.JSONValue): ResourceClaimTemplate & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha1", "ResourceClaimTemplate"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimTemplateSpec(obj["spec"]),
  }}
export function fromResourceClaimTemplate(input: ResourceClaimTemplate): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha1", "ResourceClaimTemplate"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimTemplateSpec(input.spec) : undefined,
  }}

/** ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim. */
export interface ResourceClaimTemplateSpec {
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimSpec;
}
export function toResourceClaimTemplateSpec(input: c.JSONValue): ResourceClaimTemplateSpec {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimSpec(obj["spec"]),
  }}
export function fromResourceClaimTemplateSpec(input: ResourceClaimTemplateSpec): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimSpec(input.spec) : undefined,
  }}

/** ResourceClaimTemplateList is a collection of claim templates. */
export interface ResourceClaimTemplateList extends ListOf<ResourceClaimTemplate> {
  apiVersion?: "resource.k8s.io/v1alpha1";
  kind?: "ResourceClaimTemplateList";
};
export function toResourceClaimTemplateList(input: c.JSONValue): ResourceClaimTemplateList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha1", "ResourceClaimTemplateList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClaimTemplate),
  }}

/** ResourceClass is used by administrators to influence how resources are allocated.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface ResourceClass {
  apiVersion?: "resource.k8s.io/v1alpha1";
  kind?: "ResourceClass";
  driverName: string;
  metadata?: MetaV1.ObjectMeta | null;
  parametersRef?: ResourceClassParametersReference | null;
  suitableNodes?: CoreV1.NodeSelector | null;
}
export function toResourceClass(input: c.JSONValue): ResourceClass & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha1", "ResourceClass"),
    driverName: c.checkStr(obj["driverName"]),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    parametersRef: c.readOpt(obj["parametersRef"], toResourceClassParametersReference),
    suitableNodes: c.readOpt(obj["suitableNodes"], CoreV1.toNodeSelector),
  }}
export function fromResourceClass(input: ResourceClass): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1alpha1", "ResourceClass"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    parametersRef: input.parametersRef != null ? fromResourceClassParametersReference(input.parametersRef) : undefined,
    suitableNodes: input.suitableNodes != null ? CoreV1.fromNodeSelector(input.suitableNodes) : undefined,
  }}

/** ResourceClassParametersReference contains enough information to let you locate the parameters for a ResourceClass. */
export interface ResourceClassParametersReference {
  apiGroup?: string | null;
  kind: string;
  name: string;
  namespace?: string | null;
}
export function toResourceClassParametersReference(input: c.JSONValue): ResourceClassParametersReference {
  const obj = c.checkObj(input);
  return {
    apiGroup: c.readOpt(obj["apiGroup"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
  }}
export function fromResourceClassParametersReference(input: ResourceClassParametersReference): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceClassList is a collection of classes. */
export interface ResourceClassList extends ListOf<ResourceClass> {
  apiVersion?: "resource.k8s.io/v1alpha1";
  kind?: "ResourceClassList";
};
export function toResourceClassList(input: c.JSONValue): ResourceClassList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1alpha1", "ResourceClassList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClass),
  }}
