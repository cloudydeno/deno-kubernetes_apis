// Autogenerated Schema file for AppsV1
import * as c from "../../common.ts";

import * as CoreV1 from "../core@v1/structs.ts";
import * as MetaV1 from "../meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers. */
export interface ControllerRevision {
  apiVersion?: "apps/v1";
  kind?: "ControllerRevision";
  data?: c.JSONValue | null;
  metadata?: MetaV1.ObjectMeta | null;
  revision: number;
}
export function toControllerRevision(input: c.JSONValue): ControllerRevision & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "apps/v1", "ControllerRevision"),
    data: c.readOpt(obj["data"], c.identity),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    revision: c.checkNum(obj["revision"]),
  }}
export function fromControllerRevision(input: ControllerRevision): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "apps/v1", "ControllerRevision"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
  }}

/** ControllerRevisionList is a resource containing a list of ControllerRevision objects. */
export interface ControllerRevisionList extends ListOf<ControllerRevision> {
  apiVersion?: "apps/v1";
  kind?: "ControllerRevisionList";
};
export function toControllerRevisionList(input: c.JSONValue): ControllerRevisionList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "apps/v1", "ControllerRevisionList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toControllerRevision),
  }}

/** DaemonSet represents the configuration of a daemon set. */
export interface DaemonSet {
  apiVersion?: "apps/v1";
  kind?: "DaemonSet";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: DaemonSetSpec | null;
  status?: DaemonSetStatus | null;
}
export function toDaemonSet(input: c.JSONValue): DaemonSet & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "apps/v1", "DaemonSet"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toDaemonSetSpec),
    status: c.readOpt(obj["status"], toDaemonSetStatus),
  }}
export function fromDaemonSet(input: DaemonSet): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "apps/v1", "DaemonSet"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromDaemonSetSpec(input.spec) : undefined,
    status: input.status != null ? fromDaemonSetStatus(input.status) : undefined,
  }}

/** DaemonSetSpec is the specification of a daemon set. */
export interface DaemonSetSpec {
  minReadySeconds?: number | null;
  revisionHistoryLimit?: number | null;
  selector: MetaV1.LabelSelector;
  template: CoreV1.PodTemplateSpec;
  updateStrategy?: DaemonSetUpdateStrategy | null;
}
export function toDaemonSetSpec(input: c.JSONValue): DaemonSetSpec {
  const obj = c.checkObj(input);
  return {
    minReadySeconds: c.readOpt(obj["minReadySeconds"], c.checkNum),
    revisionHistoryLimit: c.readOpt(obj["revisionHistoryLimit"], c.checkNum),
    selector: MetaV1.toLabelSelector(obj["selector"]),
    template: CoreV1.toPodTemplateSpec(obj["template"]),
    updateStrategy: c.readOpt(obj["updateStrategy"], toDaemonSetUpdateStrategy),
  }}
export function fromDaemonSetSpec(input: DaemonSetSpec): c.JSONValue {
  return {
    ...input,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
    template: input.template != null ? CoreV1.fromPodTemplateSpec(input.template) : undefined,
    updateStrategy: input.updateStrategy != null ? fromDaemonSetUpdateStrategy(input.updateStrategy) : undefined,
  }}

/** DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet. */
export interface DaemonSetUpdateStrategy {
  rollingUpdate?: RollingUpdateDaemonSet | null;
  type?: string | null;
}
export function toDaemonSetUpdateStrategy(input: c.JSONValue): DaemonSetUpdateStrategy {
  const obj = c.checkObj(input);
  return {
    rollingUpdate: c.readOpt(obj["rollingUpdate"], toRollingUpdateDaemonSet),
    type: c.readOpt(obj["type"], c.checkStr),
  }}
export function fromDaemonSetUpdateStrategy(input: DaemonSetUpdateStrategy): c.JSONValue {
  return {
    ...input,
    rollingUpdate: input.rollingUpdate != null ? fromRollingUpdateDaemonSet(input.rollingUpdate) : undefined,
  }}

/** Spec to control the desired behavior of daemon set rolling update. */
export interface RollingUpdateDaemonSet {
  maxUnavailable?: c.IntOrString | null;
}
export function toRollingUpdateDaemonSet(input: c.JSONValue): RollingUpdateDaemonSet {
  const obj = c.checkObj(input);
  return {
    maxUnavailable: c.readOpt(obj["maxUnavailable"], c.toIntOrString),
  }}
export function fromRollingUpdateDaemonSet(input: RollingUpdateDaemonSet): c.JSONValue {
  return {
    ...input,
  }}

/** DaemonSetStatus represents the current status of a daemon set. */
export interface DaemonSetStatus {
  collisionCount?: number | null;
  conditions?: Array<DaemonSetCondition> | null;
  currentNumberScheduled: number;
  desiredNumberScheduled: number;
  numberAvailable?: number | null;
  numberMisscheduled: number;
  numberReady: number;
  numberUnavailable?: number | null;
  observedGeneration?: number | null;
  updatedNumberScheduled?: number | null;
}
export function toDaemonSetStatus(input: c.JSONValue): DaemonSetStatus {
  const obj = c.checkObj(input);
  return {
    collisionCount: c.readOpt(obj["collisionCount"], c.checkNum),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toDaemonSetCondition)),
    currentNumberScheduled: c.checkNum(obj["currentNumberScheduled"]),
    desiredNumberScheduled: c.checkNum(obj["desiredNumberScheduled"]),
    numberAvailable: c.readOpt(obj["numberAvailable"], c.checkNum),
    numberMisscheduled: c.checkNum(obj["numberMisscheduled"]),
    numberReady: c.checkNum(obj["numberReady"]),
    numberUnavailable: c.readOpt(obj["numberUnavailable"], c.checkNum),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    updatedNumberScheduled: c.readOpt(obj["updatedNumberScheduled"], c.checkNum),
  }}
export function fromDaemonSetStatus(input: DaemonSetStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromDaemonSetCondition),
  }}

/** DaemonSetCondition describes the state of a DaemonSet at a certain point. */
export interface DaemonSetCondition {
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toDaemonSetCondition(input: c.JSONValue): DaemonSetCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromDaemonSetCondition(input: DaemonSetCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** DaemonSetList is a collection of daemon sets. */
export interface DaemonSetList extends ListOf<DaemonSet> {
  apiVersion?: "apps/v1";
  kind?: "DaemonSetList";
};
export function toDaemonSetList(input: c.JSONValue): DaemonSetList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "apps/v1", "DaemonSetList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toDaemonSet),
  }}

/** Deployment enables declarative updates for Pods and ReplicaSets. */
export interface Deployment {
  apiVersion?: "apps/v1";
  kind?: "Deployment";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: DeploymentSpec | null;
  status?: DeploymentStatus | null;
}
export function toDeployment(input: c.JSONValue): Deployment & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "apps/v1", "Deployment"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toDeploymentSpec),
    status: c.readOpt(obj["status"], toDeploymentStatus),
  }}
export function fromDeployment(input: Deployment): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "apps/v1", "Deployment"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromDeploymentSpec(input.spec) : undefined,
    status: input.status != null ? fromDeploymentStatus(input.status) : undefined,
  }}

/** DeploymentSpec is the specification of the desired behavior of the Deployment. */
export interface DeploymentSpec {
  minReadySeconds?: number | null;
  paused?: boolean | null;
  progressDeadlineSeconds?: number | null;
  replicas?: number | null;
  revisionHistoryLimit?: number | null;
  selector: MetaV1.LabelSelector;
  strategy?: DeploymentStrategy | null;
  template: CoreV1.PodTemplateSpec;
}
export function toDeploymentSpec(input: c.JSONValue): DeploymentSpec {
  const obj = c.checkObj(input);
  return {
    minReadySeconds: c.readOpt(obj["minReadySeconds"], c.checkNum),
    paused: c.readOpt(obj["paused"], c.checkBool),
    progressDeadlineSeconds: c.readOpt(obj["progressDeadlineSeconds"], c.checkNum),
    replicas: c.readOpt(obj["replicas"], c.checkNum),
    revisionHistoryLimit: c.readOpt(obj["revisionHistoryLimit"], c.checkNum),
    selector: MetaV1.toLabelSelector(obj["selector"]),
    strategy: c.readOpt(obj["strategy"], toDeploymentStrategy),
    template: CoreV1.toPodTemplateSpec(obj["template"]),
  }}
export function fromDeploymentSpec(input: DeploymentSpec): c.JSONValue {
  return {
    ...input,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
    strategy: input.strategy != null ? fromDeploymentStrategy(input.strategy) : undefined,
    template: input.template != null ? CoreV1.fromPodTemplateSpec(input.template) : undefined,
  }}

/** DeploymentStrategy describes how to replace existing pods with new ones. */
export interface DeploymentStrategy {
  rollingUpdate?: RollingUpdateDeployment | null;
  type?: string | null;
}
export function toDeploymentStrategy(input: c.JSONValue): DeploymentStrategy {
  const obj = c.checkObj(input);
  return {
    rollingUpdate: c.readOpt(obj["rollingUpdate"], toRollingUpdateDeployment),
    type: c.readOpt(obj["type"], c.checkStr),
  }}
export function fromDeploymentStrategy(input: DeploymentStrategy): c.JSONValue {
  return {
    ...input,
    rollingUpdate: input.rollingUpdate != null ? fromRollingUpdateDeployment(input.rollingUpdate) : undefined,
  }}

/** Spec to control the desired behavior of rolling update. */
export interface RollingUpdateDeployment {
  maxSurge?: c.IntOrString | null;
  maxUnavailable?: c.IntOrString | null;
}
export function toRollingUpdateDeployment(input: c.JSONValue): RollingUpdateDeployment {
  const obj = c.checkObj(input);
  return {
    maxSurge: c.readOpt(obj["maxSurge"], c.toIntOrString),
    maxUnavailable: c.readOpt(obj["maxUnavailable"], c.toIntOrString),
  }}
export function fromRollingUpdateDeployment(input: RollingUpdateDeployment): c.JSONValue {
  return {
    ...input,
  }}

/** DeploymentStatus is the most recently observed status of the Deployment. */
export interface DeploymentStatus {
  availableReplicas?: number | null;
  collisionCount?: number | null;
  conditions?: Array<DeploymentCondition> | null;
  observedGeneration?: number | null;
  readyReplicas?: number | null;
  replicas?: number | null;
  unavailableReplicas?: number | null;
  updatedReplicas?: number | null;
}
export function toDeploymentStatus(input: c.JSONValue): DeploymentStatus {
  const obj = c.checkObj(input);
  return {
    availableReplicas: c.readOpt(obj["availableReplicas"], c.checkNum),
    collisionCount: c.readOpt(obj["collisionCount"], c.checkNum),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toDeploymentCondition)),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    readyReplicas: c.readOpt(obj["readyReplicas"], c.checkNum),
    replicas: c.readOpt(obj["replicas"], c.checkNum),
    unavailableReplicas: c.readOpt(obj["unavailableReplicas"], c.checkNum),
    updatedReplicas: c.readOpt(obj["updatedReplicas"], c.checkNum),
  }}
export function fromDeploymentStatus(input: DeploymentStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromDeploymentCondition),
  }}

/** DeploymentCondition describes the state of a deployment at a certain point. */
export interface DeploymentCondition {
  lastTransitionTime?: c.Time | null;
  lastUpdateTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toDeploymentCondition(input: c.JSONValue): DeploymentCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    lastUpdateTime: c.readOpt(obj["lastUpdateTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromDeploymentCondition(input: DeploymentCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
    lastUpdateTime: input.lastUpdateTime != null ? c.fromTime(input.lastUpdateTime) : undefined,
  }}

/** DeploymentList is a list of Deployments. */
export interface DeploymentList extends ListOf<Deployment> {
  apiVersion?: "apps/v1";
  kind?: "DeploymentList";
};
export function toDeploymentList(input: c.JSONValue): DeploymentList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "apps/v1", "DeploymentList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toDeployment),
  }}

/** ReplicaSet ensures that a specified number of pod replicas are running at any given time. */
export interface ReplicaSet {
  apiVersion?: "apps/v1";
  kind?: "ReplicaSet";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: ReplicaSetSpec | null;
  status?: ReplicaSetStatus | null;
}
export function toReplicaSet(input: c.JSONValue): ReplicaSet & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "apps/v1", "ReplicaSet"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toReplicaSetSpec),
    status: c.readOpt(obj["status"], toReplicaSetStatus),
  }}
export function fromReplicaSet(input: ReplicaSet): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "apps/v1", "ReplicaSet"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromReplicaSetSpec(input.spec) : undefined,
    status: input.status != null ? fromReplicaSetStatus(input.status) : undefined,
  }}

/** ReplicaSetSpec is the specification of a ReplicaSet. */
export interface ReplicaSetSpec {
  minReadySeconds?: number | null;
  replicas?: number | null;
  selector: MetaV1.LabelSelector;
  template?: CoreV1.PodTemplateSpec | null;
}
export function toReplicaSetSpec(input: c.JSONValue): ReplicaSetSpec {
  const obj = c.checkObj(input);
  return {
    minReadySeconds: c.readOpt(obj["minReadySeconds"], c.checkNum),
    replicas: c.readOpt(obj["replicas"], c.checkNum),
    selector: MetaV1.toLabelSelector(obj["selector"]),
    template: c.readOpt(obj["template"], CoreV1.toPodTemplateSpec),
  }}
export function fromReplicaSetSpec(input: ReplicaSetSpec): c.JSONValue {
  return {
    ...input,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
    template: input.template != null ? CoreV1.fromPodTemplateSpec(input.template) : undefined,
  }}

/** ReplicaSetStatus represents the current status of a ReplicaSet. */
export interface ReplicaSetStatus {
  availableReplicas?: number | null;
  conditions?: Array<ReplicaSetCondition> | null;
  fullyLabeledReplicas?: number | null;
  observedGeneration?: number | null;
  readyReplicas?: number | null;
  replicas: number;
}
export function toReplicaSetStatus(input: c.JSONValue): ReplicaSetStatus {
  const obj = c.checkObj(input);
  return {
    availableReplicas: c.readOpt(obj["availableReplicas"], c.checkNum),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toReplicaSetCondition)),
    fullyLabeledReplicas: c.readOpt(obj["fullyLabeledReplicas"], c.checkNum),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    readyReplicas: c.readOpt(obj["readyReplicas"], c.checkNum),
    replicas: c.checkNum(obj["replicas"]),
  }}
export function fromReplicaSetStatus(input: ReplicaSetStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromReplicaSetCondition),
  }}

/** ReplicaSetCondition describes the state of a replica set at a certain point. */
export interface ReplicaSetCondition {
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toReplicaSetCondition(input: c.JSONValue): ReplicaSetCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromReplicaSetCondition(input: ReplicaSetCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** ReplicaSetList is a collection of ReplicaSets. */
export interface ReplicaSetList extends ListOf<ReplicaSet> {
  apiVersion?: "apps/v1";
  kind?: "ReplicaSetList";
};
export function toReplicaSetList(input: c.JSONValue): ReplicaSetList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "apps/v1", "ReplicaSetList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toReplicaSet),
  }}

/** RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType. */
export interface RollingUpdateStatefulSetStrategy {
  partition?: number | null;
}
export function toRollingUpdateStatefulSetStrategy(input: c.JSONValue): RollingUpdateStatefulSetStrategy {
  const obj = c.checkObj(input);
  return {
    partition: c.readOpt(obj["partition"], c.checkNum),
  }}
export function fromRollingUpdateStatefulSetStrategy(input: RollingUpdateStatefulSetStrategy): c.JSONValue {
  return {
    ...input,
  }}

/** StatefulSet represents a set of pods with consistent identities. Identities are defined as:
 - Network: A single stable DNS and hostname.
 - Storage: As many VolumeClaims as requested.
The StatefulSet guarantees that a given network identity will always map to the same storage identity. */
export interface StatefulSet {
  apiVersion?: "apps/v1";
  kind?: "StatefulSet";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: StatefulSetSpec | null;
  status?: StatefulSetStatus | null;
}
export function toStatefulSet(input: c.JSONValue): StatefulSet & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "apps/v1", "StatefulSet"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toStatefulSetSpec),
    status: c.readOpt(obj["status"], toStatefulSetStatus),
  }}
export function fromStatefulSet(input: StatefulSet): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "apps/v1", "StatefulSet"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromStatefulSetSpec(input.spec) : undefined,
    status: input.status != null ? fromStatefulSetStatus(input.status) : undefined,
  }}

/** A StatefulSetSpec is the specification of a StatefulSet. */
export interface StatefulSetSpec {
  podManagementPolicy?: string | null;
  replicas?: number | null;
  revisionHistoryLimit?: number | null;
  selector: MetaV1.LabelSelector;
  serviceName: string;
  template: CoreV1.PodTemplateSpec;
  updateStrategy?: StatefulSetUpdateStrategy | null;
  volumeClaimTemplates?: Array<CoreV1.PersistentVolumeClaim> | null;
}
export function toStatefulSetSpec(input: c.JSONValue): StatefulSetSpec {
  const obj = c.checkObj(input);
  return {
    podManagementPolicy: c.readOpt(obj["podManagementPolicy"], c.checkStr),
    replicas: c.readOpt(obj["replicas"], c.checkNum),
    revisionHistoryLimit: c.readOpt(obj["revisionHistoryLimit"], c.checkNum),
    selector: MetaV1.toLabelSelector(obj["selector"]),
    serviceName: c.checkStr(obj["serviceName"]),
    template: CoreV1.toPodTemplateSpec(obj["template"]),
    updateStrategy: c.readOpt(obj["updateStrategy"], toStatefulSetUpdateStrategy),
    volumeClaimTemplates: c.readOpt(obj["volumeClaimTemplates"], x => c.readList(x, CoreV1.toPersistentVolumeClaim)),
  }}
export function fromStatefulSetSpec(input: StatefulSetSpec): c.JSONValue {
  return {
    ...input,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
    template: input.template != null ? CoreV1.fromPodTemplateSpec(input.template) : undefined,
    updateStrategy: input.updateStrategy != null ? fromStatefulSetUpdateStrategy(input.updateStrategy) : undefined,
    volumeClaimTemplates: input.volumeClaimTemplates?.map(CoreV1.fromPersistentVolumeClaim),
  }}

/** StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy. */
export interface StatefulSetUpdateStrategy {
  rollingUpdate?: RollingUpdateStatefulSetStrategy | null;
  type?: string | null;
}
export function toStatefulSetUpdateStrategy(input: c.JSONValue): StatefulSetUpdateStrategy {
  const obj = c.checkObj(input);
  return {
    rollingUpdate: c.readOpt(obj["rollingUpdate"], toRollingUpdateStatefulSetStrategy),
    type: c.readOpt(obj["type"], c.checkStr),
  }}
export function fromStatefulSetUpdateStrategy(input: StatefulSetUpdateStrategy): c.JSONValue {
  return {
    ...input,
    rollingUpdate: input.rollingUpdate != null ? fromRollingUpdateStatefulSetStrategy(input.rollingUpdate) : undefined,
  }}

/** StatefulSetStatus represents the current state of a StatefulSet. */
export interface StatefulSetStatus {
  collisionCount?: number | null;
  conditions?: Array<StatefulSetCondition> | null;
  currentReplicas?: number | null;
  currentRevision?: string | null;
  observedGeneration?: number | null;
  readyReplicas?: number | null;
  replicas: number;
  updateRevision?: string | null;
  updatedReplicas?: number | null;
}
export function toStatefulSetStatus(input: c.JSONValue): StatefulSetStatus {
  const obj = c.checkObj(input);
  return {
    collisionCount: c.readOpt(obj["collisionCount"], c.checkNum),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toStatefulSetCondition)),
    currentReplicas: c.readOpt(obj["currentReplicas"], c.checkNum),
    currentRevision: c.readOpt(obj["currentRevision"], c.checkStr),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    readyReplicas: c.readOpt(obj["readyReplicas"], c.checkNum),
    replicas: c.checkNum(obj["replicas"]),
    updateRevision: c.readOpt(obj["updateRevision"], c.checkStr),
    updatedReplicas: c.readOpt(obj["updatedReplicas"], c.checkNum),
  }}
export function fromStatefulSetStatus(input: StatefulSetStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromStatefulSetCondition),
  }}

/** StatefulSetCondition describes the state of a statefulset at a certain point. */
export interface StatefulSetCondition {
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toStatefulSetCondition(input: c.JSONValue): StatefulSetCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromStatefulSetCondition(input: StatefulSetCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** StatefulSetList is a collection of StatefulSets. */
export interface StatefulSetList extends ListOf<StatefulSet> {
  apiVersion?: "apps/v1";
  kind?: "StatefulSetList";
};
export function toStatefulSetList(input: c.JSONValue): StatefulSetList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "apps/v1", "StatefulSetList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toStatefulSet),
  }}
