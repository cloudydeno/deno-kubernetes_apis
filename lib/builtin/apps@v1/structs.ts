// Autogenerated Schema file for AppsV1
import * as c from "../../common.ts";

import * as CoreV1 from "../core@v1/structs.ts";
import * as MetaV1 from "../meta@v1/structs.ts";
type Kind<T extends string> = {
  apiVersion: "apps/v1";
  kind: T;
};
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers. */
export type ControllerRevision = Kind<"ControllerRevision"> & ControllerRevisionFields;
export interface ControllerRevisionFields {
  data?: c.JSONValue | null;
  metadata?: MetaV1.ObjectMeta | null;
  revision: number;
}
export function toControllerRevisionFields(input: c.JSONValue): ControllerRevisionFields {
  const obj = c.checkObj(input);
  return {
    data: c.readOpt(obj["data"], c.identity),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    revision: c.checkNum(obj["revision"]),
  }}
export function toControllerRevision(input: c.JSONValue): ControllerRevision {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "apps/v1") throw new Error("Type apiv mis 2");
  if (kind !== "ControllerRevision") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toControllerRevisionFields(fields),
  }}
export function fromControllerRevision(input: ControllerRevision): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
  }}

/** ControllerRevisionList is a resource containing a list of ControllerRevision objects. */
export type ControllerRevisionList = Kind<"ControllerRevisionList"> & ListOf<ControllerRevisionFields>;
export function toControllerRevisionList(input: c.JSONValue): ControllerRevisionList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "apps/v1") throw new Error("Type apiv mis 2");
  if (kind !== "ControllerRevisionList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toControllerRevisionFields),
  }}

/** DaemonSet represents the configuration of a daemon set. */
export type DaemonSet = Kind<"DaemonSet"> & DaemonSetFields;
export interface DaemonSetFields {
  metadata?: MetaV1.ObjectMeta | null;
  spec?: DaemonSetSpec | null;
  status?: DaemonSetStatus | null;
}
export function toDaemonSetFields(input: c.JSONValue): DaemonSetFields {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toDaemonSetSpec),
    status: c.readOpt(obj["status"], toDaemonSetStatus),
  }}
export function toDaemonSet(input: c.JSONValue): DaemonSet {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "apps/v1") throw new Error("Type apiv mis 2");
  if (kind !== "DaemonSet") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toDaemonSetFields(fields),
  }}
export function fromDaemonSet(input: DaemonSet): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromDaemonSetSpec(input.spec) : undefined,
    status: input.status != null ? fromDaemonSetStatus(input.status) : undefined,
  }}

/** DaemonSetSpec is the specification of a daemon set. */
export interface DaemonSetSpec {
  minReadySeconds?: number | null;
  revisionHistoryLimit?: number | null;
  selector: MetaV1.LabelSelector;
  template: CoreV1.PodTemplateSpec;
  updateStrategy?: DaemonSetUpdateStrategy | null;
}
export function toDaemonSetSpec(input: c.JSONValue): DaemonSetSpec {
  const obj = c.checkObj(input);
  return {
    minReadySeconds: c.readOpt(obj["minReadySeconds"], c.checkNum),
    revisionHistoryLimit: c.readOpt(obj["revisionHistoryLimit"], c.checkNum),
    selector: MetaV1.toLabelSelector(obj["selector"]),
    template: CoreV1.toPodTemplateSpec(obj["template"]),
    updateStrategy: c.readOpt(obj["updateStrategy"], toDaemonSetUpdateStrategy),
  }}
export function fromDaemonSetSpec(input: DaemonSetSpec): c.JSONValue {
  return {
    ...input,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
    template: input.template != null ? CoreV1.fromPodTemplateSpec(input.template) : undefined,
    updateStrategy: input.updateStrategy != null ? fromDaemonSetUpdateStrategy(input.updateStrategy) : undefined,
  }}

/** DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet. */
export interface DaemonSetUpdateStrategy {
  rollingUpdate?: RollingUpdateDaemonSet | null;
  type?: string | null;
}
export function toDaemonSetUpdateStrategy(input: c.JSONValue): DaemonSetUpdateStrategy {
  const obj = c.checkObj(input);
  return {
    rollingUpdate: c.readOpt(obj["rollingUpdate"], toRollingUpdateDaemonSet),
    type: c.readOpt(obj["type"], c.checkStr),
  }}
export function fromDaemonSetUpdateStrategy(input: DaemonSetUpdateStrategy): c.JSONValue {
  return {
    ...input,
    rollingUpdate: input.rollingUpdate != null ? fromRollingUpdateDaemonSet(input.rollingUpdate) : undefined,
  }}

/** Spec to control the desired behavior of daemon set rolling update. */
export interface RollingUpdateDaemonSet {
  maxUnavailable?: c.IntOrString | null;
}
export function toRollingUpdateDaemonSet(input: c.JSONValue): RollingUpdateDaemonSet {
  const obj = c.checkObj(input);
  return {
    maxUnavailable: c.readOpt(obj["maxUnavailable"], c.toIntOrString),
  }}
export function fromRollingUpdateDaemonSet(input: RollingUpdateDaemonSet): c.JSONValue {
  return {
    ...input,
  }}

/** DaemonSetStatus represents the current status of a daemon set. */
export interface DaemonSetStatus {
  collisionCount?: number | null;
  conditions?: Array<DaemonSetCondition> | null;
  currentNumberScheduled: number;
  desiredNumberScheduled: number;
  numberAvailable?: number | null;
  numberMisscheduled: number;
  numberReady: number;
  numberUnavailable?: number | null;
  observedGeneration?: number | null;
  updatedNumberScheduled?: number | null;
}
export function toDaemonSetStatus(input: c.JSONValue): DaemonSetStatus {
  const obj = c.checkObj(input);
  return {
    collisionCount: c.readOpt(obj["collisionCount"], c.checkNum),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toDaemonSetCondition)),
    currentNumberScheduled: c.checkNum(obj["currentNumberScheduled"]),
    desiredNumberScheduled: c.checkNum(obj["desiredNumberScheduled"]),
    numberAvailable: c.readOpt(obj["numberAvailable"], c.checkNum),
    numberMisscheduled: c.checkNum(obj["numberMisscheduled"]),
    numberReady: c.checkNum(obj["numberReady"]),
    numberUnavailable: c.readOpt(obj["numberUnavailable"], c.checkNum),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    updatedNumberScheduled: c.readOpt(obj["updatedNumberScheduled"], c.checkNum),
  }}
export function fromDaemonSetStatus(input: DaemonSetStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromDaemonSetCondition),
  }}

/** DaemonSetCondition describes the state of a DaemonSet at a certain point. */
export interface DaemonSetCondition {
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toDaemonSetCondition(input: c.JSONValue): DaemonSetCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromDaemonSetCondition(input: DaemonSetCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** DaemonSetList is a collection of daemon sets. */
export type DaemonSetList = Kind<"DaemonSetList"> & ListOf<DaemonSetFields>;
export function toDaemonSetList(input: c.JSONValue): DaemonSetList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "apps/v1") throw new Error("Type apiv mis 2");
  if (kind !== "DaemonSetList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toDaemonSetFields),
  }}

/** Deployment enables declarative updates for Pods and ReplicaSets. */
export type Deployment = Kind<"Deployment"> & DeploymentFields;
export interface DeploymentFields {
  metadata?: MetaV1.ObjectMeta | null;
  spec?: DeploymentSpec | null;
  status?: DeploymentStatus | null;
}
export function toDeploymentFields(input: c.JSONValue): DeploymentFields {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toDeploymentSpec),
    status: c.readOpt(obj["status"], toDeploymentStatus),
  }}
export function toDeployment(input: c.JSONValue): Deployment {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "apps/v1") throw new Error("Type apiv mis 2");
  if (kind !== "Deployment") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toDeploymentFields(fields),
  }}
export function fromDeployment(input: Deployment): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromDeploymentSpec(input.spec) : undefined,
    status: input.status != null ? fromDeploymentStatus(input.status) : undefined,
  }}

/** DeploymentSpec is the specification of the desired behavior of the Deployment. */
export interface DeploymentSpec {
  minReadySeconds?: number | null;
  paused?: boolean | null;
  progressDeadlineSeconds?: number | null;
  replicas?: number | null;
  revisionHistoryLimit?: number | null;
  selector: MetaV1.LabelSelector;
  strategy?: DeploymentStrategy | null;
  template: CoreV1.PodTemplateSpec;
}
export function toDeploymentSpec(input: c.JSONValue): DeploymentSpec {
  const obj = c.checkObj(input);
  return {
    minReadySeconds: c.readOpt(obj["minReadySeconds"], c.checkNum),
    paused: c.readOpt(obj["paused"], c.checkBool),
    progressDeadlineSeconds: c.readOpt(obj["progressDeadlineSeconds"], c.checkNum),
    replicas: c.readOpt(obj["replicas"], c.checkNum),
    revisionHistoryLimit: c.readOpt(obj["revisionHistoryLimit"], c.checkNum),
    selector: MetaV1.toLabelSelector(obj["selector"]),
    strategy: c.readOpt(obj["strategy"], toDeploymentStrategy),
    template: CoreV1.toPodTemplateSpec(obj["template"]),
  }}
export function fromDeploymentSpec(input: DeploymentSpec): c.JSONValue {
  return {
    ...input,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
    strategy: input.strategy != null ? fromDeploymentStrategy(input.strategy) : undefined,
    template: input.template != null ? CoreV1.fromPodTemplateSpec(input.template) : undefined,
  }}

/** DeploymentStrategy describes how to replace existing pods with new ones. */
export interface DeploymentStrategy {
  rollingUpdate?: RollingUpdateDeployment | null;
  type?: string | null;
}
export function toDeploymentStrategy(input: c.JSONValue): DeploymentStrategy {
  const obj = c.checkObj(input);
  return {
    rollingUpdate: c.readOpt(obj["rollingUpdate"], toRollingUpdateDeployment),
    type: c.readOpt(obj["type"], c.checkStr),
  }}
export function fromDeploymentStrategy(input: DeploymentStrategy): c.JSONValue {
  return {
    ...input,
    rollingUpdate: input.rollingUpdate != null ? fromRollingUpdateDeployment(input.rollingUpdate) : undefined,
  }}

/** Spec to control the desired behavior of rolling update. */
export interface RollingUpdateDeployment {
  maxSurge?: c.IntOrString | null;
  maxUnavailable?: c.IntOrString | null;
}
export function toRollingUpdateDeployment(input: c.JSONValue): RollingUpdateDeployment {
  const obj = c.checkObj(input);
  return {
    maxSurge: c.readOpt(obj["maxSurge"], c.toIntOrString),
    maxUnavailable: c.readOpt(obj["maxUnavailable"], c.toIntOrString),
  }}
export function fromRollingUpdateDeployment(input: RollingUpdateDeployment): c.JSONValue {
  return {
    ...input,
  }}

/** DeploymentStatus is the most recently observed status of the Deployment. */
export interface DeploymentStatus {
  availableReplicas?: number | null;
  collisionCount?: number | null;
  conditions?: Array<DeploymentCondition> | null;
  observedGeneration?: number | null;
  readyReplicas?: number | null;
  replicas?: number | null;
  unavailableReplicas?: number | null;
  updatedReplicas?: number | null;
}
export function toDeploymentStatus(input: c.JSONValue): DeploymentStatus {
  const obj = c.checkObj(input);
  return {
    availableReplicas: c.readOpt(obj["availableReplicas"], c.checkNum),
    collisionCount: c.readOpt(obj["collisionCount"], c.checkNum),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toDeploymentCondition)),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    readyReplicas: c.readOpt(obj["readyReplicas"], c.checkNum),
    replicas: c.readOpt(obj["replicas"], c.checkNum),
    unavailableReplicas: c.readOpt(obj["unavailableReplicas"], c.checkNum),
    updatedReplicas: c.readOpt(obj["updatedReplicas"], c.checkNum),
  }}
export function fromDeploymentStatus(input: DeploymentStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromDeploymentCondition),
  }}

/** DeploymentCondition describes the state of a deployment at a certain point. */
export interface DeploymentCondition {
  lastTransitionTime?: c.Time | null;
  lastUpdateTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toDeploymentCondition(input: c.JSONValue): DeploymentCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    lastUpdateTime: c.readOpt(obj["lastUpdateTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromDeploymentCondition(input: DeploymentCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
    lastUpdateTime: input.lastUpdateTime != null ? c.fromTime(input.lastUpdateTime) : undefined,
  }}

/** DeploymentList is a list of Deployments. */
export type DeploymentList = Kind<"DeploymentList"> & ListOf<DeploymentFields>;
export function toDeploymentList(input: c.JSONValue): DeploymentList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "apps/v1") throw new Error("Type apiv mis 2");
  if (kind !== "DeploymentList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toDeploymentFields),
  }}

/** ReplicaSet ensures that a specified number of pod replicas are running at any given time. */
export type ReplicaSet = Kind<"ReplicaSet"> & ReplicaSetFields;
export interface ReplicaSetFields {
  metadata?: MetaV1.ObjectMeta | null;
  spec?: ReplicaSetSpec | null;
  status?: ReplicaSetStatus | null;
}
export function toReplicaSetFields(input: c.JSONValue): ReplicaSetFields {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toReplicaSetSpec),
    status: c.readOpt(obj["status"], toReplicaSetStatus),
  }}
export function toReplicaSet(input: c.JSONValue): ReplicaSet {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "apps/v1") throw new Error("Type apiv mis 2");
  if (kind !== "ReplicaSet") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toReplicaSetFields(fields),
  }}
export function fromReplicaSet(input: ReplicaSet): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromReplicaSetSpec(input.spec) : undefined,
    status: input.status != null ? fromReplicaSetStatus(input.status) : undefined,
  }}

/** ReplicaSetSpec is the specification of a ReplicaSet. */
export interface ReplicaSetSpec {
  minReadySeconds?: number | null;
  replicas?: number | null;
  selector: MetaV1.LabelSelector;
  template?: CoreV1.PodTemplateSpec | null;
}
export function toReplicaSetSpec(input: c.JSONValue): ReplicaSetSpec {
  const obj = c.checkObj(input);
  return {
    minReadySeconds: c.readOpt(obj["minReadySeconds"], c.checkNum),
    replicas: c.readOpt(obj["replicas"], c.checkNum),
    selector: MetaV1.toLabelSelector(obj["selector"]),
    template: c.readOpt(obj["template"], CoreV1.toPodTemplateSpec),
  }}
export function fromReplicaSetSpec(input: ReplicaSetSpec): c.JSONValue {
  return {
    ...input,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
    template: input.template != null ? CoreV1.fromPodTemplateSpec(input.template) : undefined,
  }}

/** ReplicaSetStatus represents the current status of a ReplicaSet. */
export interface ReplicaSetStatus {
  availableReplicas?: number | null;
  conditions?: Array<ReplicaSetCondition> | null;
  fullyLabeledReplicas?: number | null;
  observedGeneration?: number | null;
  readyReplicas?: number | null;
  replicas: number;
}
export function toReplicaSetStatus(input: c.JSONValue): ReplicaSetStatus {
  const obj = c.checkObj(input);
  return {
    availableReplicas: c.readOpt(obj["availableReplicas"], c.checkNum),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toReplicaSetCondition)),
    fullyLabeledReplicas: c.readOpt(obj["fullyLabeledReplicas"], c.checkNum),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    readyReplicas: c.readOpt(obj["readyReplicas"], c.checkNum),
    replicas: c.checkNum(obj["replicas"]),
  }}
export function fromReplicaSetStatus(input: ReplicaSetStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromReplicaSetCondition),
  }}

/** ReplicaSetCondition describes the state of a replica set at a certain point. */
export interface ReplicaSetCondition {
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toReplicaSetCondition(input: c.JSONValue): ReplicaSetCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromReplicaSetCondition(input: ReplicaSetCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** ReplicaSetList is a collection of ReplicaSets. */
export type ReplicaSetList = Kind<"ReplicaSetList"> & ListOf<ReplicaSetFields>;
export function toReplicaSetList(input: c.JSONValue): ReplicaSetList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "apps/v1") throw new Error("Type apiv mis 2");
  if (kind !== "ReplicaSetList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toReplicaSetFields),
  }}

/** RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType. */
export interface RollingUpdateStatefulSetStrategy {
  partition?: number | null;
}
export function toRollingUpdateStatefulSetStrategy(input: c.JSONValue): RollingUpdateStatefulSetStrategy {
  const obj = c.checkObj(input);
  return {
    partition: c.readOpt(obj["partition"], c.checkNum),
  }}
export function fromRollingUpdateStatefulSetStrategy(input: RollingUpdateStatefulSetStrategy): c.JSONValue {
  return {
    ...input,
  }}

/** StatefulSet represents a set of pods with consistent identities. Identities are defined as:
 - Network: A single stable DNS and hostname.
 - Storage: As many VolumeClaims as requested.
The StatefulSet guarantees that a given network identity will always map to the same storage identity. */
export type StatefulSet = Kind<"StatefulSet"> & StatefulSetFields;
export interface StatefulSetFields {
  metadata?: MetaV1.ObjectMeta | null;
  spec?: StatefulSetSpec | null;
  status?: StatefulSetStatus | null;
}
export function toStatefulSetFields(input: c.JSONValue): StatefulSetFields {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toStatefulSetSpec),
    status: c.readOpt(obj["status"], toStatefulSetStatus),
  }}
export function toStatefulSet(input: c.JSONValue): StatefulSet {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "apps/v1") throw new Error("Type apiv mis 2");
  if (kind !== "StatefulSet") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toStatefulSetFields(fields),
  }}
export function fromStatefulSet(input: StatefulSet): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromStatefulSetSpec(input.spec) : undefined,
    status: input.status != null ? fromStatefulSetStatus(input.status) : undefined,
  }}

/** A StatefulSetSpec is the specification of a StatefulSet. */
export interface StatefulSetSpec {
  podManagementPolicy?: string | null;
  replicas?: number | null;
  revisionHistoryLimit?: number | null;
  selector: MetaV1.LabelSelector;
  serviceName: string;
  template: CoreV1.PodTemplateSpec;
  updateStrategy?: StatefulSetUpdateStrategy | null;
  volumeClaimTemplates?: Array<CoreV1.PersistentVolumeClaim> | null;
}
export function toStatefulSetSpec(input: c.JSONValue): StatefulSetSpec {
  const obj = c.checkObj(input);
  return {
    podManagementPolicy: c.readOpt(obj["podManagementPolicy"], c.checkStr),
    replicas: c.readOpt(obj["replicas"], c.checkNum),
    revisionHistoryLimit: c.readOpt(obj["revisionHistoryLimit"], c.checkNum),
    selector: MetaV1.toLabelSelector(obj["selector"]),
    serviceName: c.checkStr(obj["serviceName"]),
    template: CoreV1.toPodTemplateSpec(obj["template"]),
    updateStrategy: c.readOpt(obj["updateStrategy"], toStatefulSetUpdateStrategy),
    volumeClaimTemplates: c.readOpt(obj["volumeClaimTemplates"], x => c.readList(x, CoreV1.toPersistentVolumeClaim)),
  }}
export function fromStatefulSetSpec(input: StatefulSetSpec): c.JSONValue {
  return {
    ...input,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
    template: input.template != null ? CoreV1.fromPodTemplateSpec(input.template) : undefined,
    updateStrategy: input.updateStrategy != null ? fromStatefulSetUpdateStrategy(input.updateStrategy) : undefined,
    volumeClaimTemplates: input.volumeClaimTemplates?.map(CoreV1.fromPersistentVolumeClaim),
  }}

/** StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy. */
export interface StatefulSetUpdateStrategy {
  rollingUpdate?: RollingUpdateStatefulSetStrategy | null;
  type?: string | null;
}
export function toStatefulSetUpdateStrategy(input: c.JSONValue): StatefulSetUpdateStrategy {
  const obj = c.checkObj(input);
  return {
    rollingUpdate: c.readOpt(obj["rollingUpdate"], toRollingUpdateStatefulSetStrategy),
    type: c.readOpt(obj["type"], c.checkStr),
  }}
export function fromStatefulSetUpdateStrategy(input: StatefulSetUpdateStrategy): c.JSONValue {
  return {
    ...input,
    rollingUpdate: input.rollingUpdate != null ? fromRollingUpdateStatefulSetStrategy(input.rollingUpdate) : undefined,
  }}

/** StatefulSetStatus represents the current state of a StatefulSet. */
export interface StatefulSetStatus {
  collisionCount?: number | null;
  conditions?: Array<StatefulSetCondition> | null;
  currentReplicas?: number | null;
  currentRevision?: string | null;
  observedGeneration?: number | null;
  readyReplicas?: number | null;
  replicas: number;
  updateRevision?: string | null;
  updatedReplicas?: number | null;
}
export function toStatefulSetStatus(input: c.JSONValue): StatefulSetStatus {
  const obj = c.checkObj(input);
  return {
    collisionCount: c.readOpt(obj["collisionCount"], c.checkNum),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toStatefulSetCondition)),
    currentReplicas: c.readOpt(obj["currentReplicas"], c.checkNum),
    currentRevision: c.readOpt(obj["currentRevision"], c.checkStr),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    readyReplicas: c.readOpt(obj["readyReplicas"], c.checkNum),
    replicas: c.checkNum(obj["replicas"]),
    updateRevision: c.readOpt(obj["updateRevision"], c.checkStr),
    updatedReplicas: c.readOpt(obj["updatedReplicas"], c.checkNum),
  }}
export function fromStatefulSetStatus(input: StatefulSetStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(fromStatefulSetCondition),
  }}

/** StatefulSetCondition describes the state of a statefulset at a certain point. */
export interface StatefulSetCondition {
  lastTransitionTime?: c.Time | null;
  message?: string | null;
  reason?: string | null;
  status: string;
  type: string;
}
export function toStatefulSetCondition(input: c.JSONValue): StatefulSetCondition {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function fromStatefulSetCondition(input: StatefulSetCondition): c.JSONValue {
  return {
    ...input,
    lastTransitionTime: input.lastTransitionTime != null ? c.fromTime(input.lastTransitionTime) : undefined,
  }}

/** StatefulSetList is a collection of StatefulSets. */
export type StatefulSetList = Kind<"StatefulSetList"> & ListOf<StatefulSetFields>;
export function toStatefulSetList(input: c.JSONValue): StatefulSetList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "apps/v1") throw new Error("Type apiv mis 2");
  if (kind !== "StatefulSetList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toStatefulSetFields),
  }}
