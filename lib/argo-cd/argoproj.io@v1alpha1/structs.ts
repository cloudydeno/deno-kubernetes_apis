// Autogenerated Schema file for ArgoprojIoV1alpha1
import * as c from "../../common.ts";

import * as MetaV1 from "../../builtin/meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** Source overrides the source definition set in the application.
This is typically set in a Rollback operation and is nil during a Sync operation */
export interface ApplicationSource {
  chart?: string | null;
  directory?: {
    exclude?: string | null;
    include?: string | null;
    jsonnet?: {
      extVars?: Array<{
        code?: boolean | null;
        name: string;
        value: string;
      }> | null;
      libs?: Array<string> | null;
      tlas?: Array<{
        code?: boolean | null;
        name: string;
        value: string;
      }> | null;
    } | null;
    recurse?: boolean | null;
  } | null;
  helm?: {
    apiVersions?: Array<string> | null;
    fileParameters?: Array<{
      name?: string | null;
      path?: string | null;
    }> | null;
    ignoreMissingValueFiles?: boolean | null;
    kubeVersion?: string | null;
    namespace?: string | null;
    parameters?: Array<{
      forceString?: boolean | null;
      name?: string | null;
      value?: string | null;
    }> | null;
    passCredentials?: boolean | null;
    releaseName?: string | null;
    skipCrds?: boolean | null;
    valueFiles?: Array<string> | null;
    values?: string | null;
    valuesObject?: c.JSONValue | null;
    version?: string | null;
  } | null;
  kustomize?: {
    apiVersions?: Array<string> | null;
    commonAnnotations?: Record<string,string> | null;
    commonAnnotationsEnvsubst?: boolean | null;
    commonLabels?: Record<string,string> | null;
    components?: Array<string> | null;
    forceCommonAnnotations?: boolean | null;
    forceCommonLabels?: boolean | null;
    images?: Array<string> | null;
    kubeVersion?: string | null;
    labelWithoutSelector?: boolean | null;
    namePrefix?: string | null;
    nameSuffix?: string | null;
    namespace?: string | null;
    patches?: Array<{
      options?: Record<string,boolean> | null;
      patch?: string | null;
      path?: string | null;
      target?: {
        annotationSelector?: string | null;
        group?: string | null;
        kind?: string | null;
        labelSelector?: string | null;
        name?: string | null;
        namespace?: string | null;
        version?: string | null;
      } | null;
    }> | null;
    replicas?: Array<{
      count: c.IntOrString;
      name: string;
    }> | null;
    version?: string | null;
  } | null;
  path?: string | null;
  plugin?: {
    env?: Array<{
      name: string;
      value: string;
    }> | null;
    name?: string | null;
    parameters?: Array<{
      array?: Array<string> | null;
      map?: Record<string,string> | null;
      name?: string | null;
      string?: string | null;
    }> | null;
  } | null;
  ref?: string | null;
  repoURL: string;
  targetRevision?: string | null;
}
export function toApplicationSource(input: c.JSONValue): ApplicationSource {
  const obj = c.checkObj(input);
  return {
    chart: c.readOpt(obj["chart"], c.checkStr),
    directory: c.readOpt(obj["directory"], toApplicationSource_directory),
    helm: c.readOpt(obj["helm"], toApplicationSource_helm),
    kustomize: c.readOpt(obj["kustomize"], toApplicationSource_kustomize),
    path: c.readOpt(obj["path"], c.checkStr),
    plugin: c.readOpt(obj["plugin"], toApplicationSource_plugin),
    ref: c.readOpt(obj["ref"], c.checkStr),
    repoURL: c.checkStr(obj["repoURL"]),
    targetRevision: c.readOpt(obj["targetRevision"], c.checkStr),
  }}
export function fromApplicationSource(input: ApplicationSource): c.JSONValue {
  return {
    ...input,
  }}
function toApplicationSource_directory(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    exclude: c.readOpt(obj["exclude"], c.checkStr),
    include: c.readOpt(obj["include"], c.checkStr),
    jsonnet: c.readOpt(obj["jsonnet"], toApplicationSource_directory_jsonnet),
    recurse: c.readOpt(obj["recurse"], c.checkBool),
  }}
function toApplicationSource_helm(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    apiVersions: c.readOpt(obj["apiVersions"], x => c.readList(x, c.checkStr)),
    fileParameters: c.readOpt(obj["fileParameters"], x => c.readList(x, toApplicationSource_helm_fileParameters)),
    ignoreMissingValueFiles: c.readOpt(obj["ignoreMissingValueFiles"], c.checkBool),
    kubeVersion: c.readOpt(obj["kubeVersion"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    parameters: c.readOpt(obj["parameters"], x => c.readList(x, toApplicationSource_helm_parameters)),
    passCredentials: c.readOpt(obj["passCredentials"], c.checkBool),
    releaseName: c.readOpt(obj["releaseName"], c.checkStr),
    skipCrds: c.readOpt(obj["skipCrds"], c.checkBool),
    valueFiles: c.readOpt(obj["valueFiles"], x => c.readList(x, c.checkStr)),
    values: c.readOpt(obj["values"], c.checkStr),
    valuesObject: c.readOpt(obj["valuesObject"], c.identity),
    version: c.readOpt(obj["version"], c.checkStr),
  }}
function toApplicationSource_kustomize(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    apiVersions: c.readOpt(obj["apiVersions"], x => c.readList(x, c.checkStr)),
    commonAnnotations: c.readOpt(obj["commonAnnotations"], x => c.readMap(x, c.checkStr)),
    commonAnnotationsEnvsubst: c.readOpt(obj["commonAnnotationsEnvsubst"], c.checkBool),
    commonLabels: c.readOpt(obj["commonLabels"], x => c.readMap(x, c.checkStr)),
    components: c.readOpt(obj["components"], x => c.readList(x, c.checkStr)),
    forceCommonAnnotations: c.readOpt(obj["forceCommonAnnotations"], c.checkBool),
    forceCommonLabels: c.readOpt(obj["forceCommonLabels"], c.checkBool),
    images: c.readOpt(obj["images"], x => c.readList(x, c.checkStr)),
    kubeVersion: c.readOpt(obj["kubeVersion"], c.checkStr),
    labelWithoutSelector: c.readOpt(obj["labelWithoutSelector"], c.checkBool),
    namePrefix: c.readOpt(obj["namePrefix"], c.checkStr),
    nameSuffix: c.readOpt(obj["nameSuffix"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    patches: c.readOpt(obj["patches"], x => c.readList(x, toApplicationSource_kustomize_patches)),
    replicas: c.readOpt(obj["replicas"], x => c.readList(x, toApplicationSource_kustomize_replicas)),
    version: c.readOpt(obj["version"], c.checkStr),
  }}
function toApplicationSource_plugin(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    env: c.readOpt(obj["env"], x => c.readList(x, toApplicationSource_plugin_env)),
    name: c.readOpt(obj["name"], c.checkStr),
    parameters: c.readOpt(obj["parameters"], x => c.readList(x, toApplicationSource_plugin_parameters)),
  }}
function toApplicationSource_directory_jsonnet(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    extVars: c.readOpt(obj["extVars"], x => c.readList(x, toApplicationSource_directory_jsonnet_extVars)),
    libs: c.readOpt(obj["libs"], x => c.readList(x, c.checkStr)),
    tlas: c.readOpt(obj["tlas"], x => c.readList(x, toApplicationSource_directory_jsonnet_tlas)),
  }}
function toApplicationSource_helm_fileParameters(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    path: c.readOpt(obj["path"], c.checkStr),
  }}
function toApplicationSource_helm_parameters(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    forceString: c.readOpt(obj["forceString"], c.checkBool),
    name: c.readOpt(obj["name"], c.checkStr),
    value: c.readOpt(obj["value"], c.checkStr),
  }}
function toApplicationSource_kustomize_patches(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    options: c.readOpt(obj["options"], x => c.readMap(x, c.checkBool)),
    patch: c.readOpt(obj["patch"], c.checkStr),
    path: c.readOpt(obj["path"], c.checkStr),
    target: c.readOpt(obj["target"], toApplicationSource_kustomize_patches_target),
  }}
function toApplicationSource_kustomize_replicas(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    count: c.toIntOrString(obj["count"]),
    name: c.checkStr(obj["name"]),
  }}
function toApplicationSource_plugin_env(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    value: c.checkStr(obj["value"]),
  }}
function toApplicationSource_plugin_parameters(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    array: c.readOpt(obj["array"], x => c.readList(x, c.checkStr)),
    map: c.readOpt(obj["map"], x => c.readMap(x, c.checkStr)),
    name: c.readOpt(obj["name"], c.checkStr),
    string: c.readOpt(obj["string"], c.checkStr),
  }}
function toApplicationSource_directory_jsonnet_extVars(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    code: c.readOpt(obj["code"], c.checkBool),
    name: c.checkStr(obj["name"]),
    value: c.checkStr(obj["value"]),
  }}
function toApplicationSource_directory_jsonnet_tlas(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    code: c.readOpt(obj["code"], c.checkBool),
    name: c.checkStr(obj["name"]),
    value: c.checkStr(obj["value"]),
  }}
function toApplicationSource_kustomize_patches_target(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotationSelector: c.readOpt(obj["annotationSelector"], c.checkStr),
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    labelSelector: c.readOpt(obj["labelSelector"], c.checkStr),
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    version: c.readOpt(obj["version"], c.checkStr),
  }}

/** Application is a definition of Application resource. */
export interface Application {
  apiVersion?: "argoproj.io/v1alpha1";
  kind?: "Application";
  metadata: MetaV1.ObjectMeta;
  operation?: {
    info?: Array<{
      name: string;
      value: string;
    }> | null;
    initiatedBy?: {
      automated?: boolean | null;
      username?: string | null;
    } | null;
    retry?: {
      backoff?: {
        duration?: string | null;
        factor?: number | null;
        maxDuration?: string | null;
      } | null;
      limit?: number | null;
    } | null;
    sync?: {
      autoHealAttemptsCount?: number | null;
      dryRun?: boolean | null;
      manifests?: Array<string> | null;
      prune?: boolean | null;
      resources?: Array<{
        group?: string | null;
        kind: string;
        name: string;
        namespace?: string | null;
      }> | null;
      revision?: string | null;
      revisions?: Array<string> | null;
      source?: ApplicationSource | null;
      sources?: Array<ApplicationSource> | null;
      syncOptions?: Array<string> | null;
      syncStrategy?: {
        apply?: {
          force?: boolean | null;
        } | null;
        hook?: {
          force?: boolean | null;
        } | null;
      } | null;
    } | null;
  } | null;
  spec: {
    destination: {
      name?: string | null;
      namespace?: string | null;
      server?: string | null;
    };
    ignoreDifferences?: Array<{
      group?: string | null;
      jqPathExpressions?: Array<string> | null;
      jsonPointers?: Array<string> | null;
      kind: string;
      managedFieldsManagers?: Array<string> | null;
      name?: string | null;
      namespace?: string | null;
    }> | null;
    info?: Array<{
      name: string;
      value: string;
    }> | null;
    project: string;
    revisionHistoryLimit?: number | null;
    source?: ApplicationSource | null;
    sources?: Array<ApplicationSource> | null;
    syncPolicy?: {
      automated?: {
        allowEmpty?: boolean | null;
        prune?: boolean | null;
        selfHeal?: boolean | null;
      } | null;
      managedNamespaceMetadata?: {
        annotations?: Record<string,string> | null;
        labels?: Record<string,string> | null;
      } | null;
      retry?: {
        backoff?: {
          duration?: string | null;
          factor?: number | null;
          maxDuration?: string | null;
        } | null;
        limit?: number | null;
      } | null;
      syncOptions?: Array<string> | null;
    } | null;
  };
  status?: {
    conditions?: Array<{
      lastTransitionTime?: c.Time | null;
      message: string;
      type: string;
    }> | null;
    controllerNamespace?: string | null;
    health?: {
      message?: string | null;
      status?: string | null;
    } | null;
    history?: Array<{
      deployStartedAt?: c.Time | null;
      deployedAt: c.Time;
      id: number;
      initiatedBy?: {
        automated?: boolean | null;
        username?: string | null;
      } | null;
      revision?: string | null;
      revisions?: Array<string> | null;
      source?: ApplicationSource | null;
      sources?: Array<ApplicationSource> | null;
    }> | null;
    observedAt?: c.Time | null;
    operationState?: {
      finishedAt?: c.Time | null;
      message?: string | null;
      operation: {
        info?: Array<{
          name: string;
          value: string;
        }> | null;
        initiatedBy?: {
          automated?: boolean | null;
          username?: string | null;
        } | null;
        retry?: {
          backoff?: {
            duration?: string | null;
            factor?: number | null;
            maxDuration?: string | null;
          } | null;
          limit?: number | null;
        } | null;
        sync?: {
          autoHealAttemptsCount?: number | null;
          dryRun?: boolean | null;
          manifests?: Array<string> | null;
          prune?: boolean | null;
          resources?: Array<{
            group?: string | null;
            kind: string;
            name: string;
            namespace?: string | null;
          }> | null;
          revision?: string | null;
          revisions?: Array<string> | null;
          source?: ApplicationSource | null;
          sources?: Array<ApplicationSource> | null;
          syncOptions?: Array<string> | null;
          syncStrategy?: {
            apply?: {
              force?: boolean | null;
            } | null;
            hook?: {
              force?: boolean | null;
            } | null;
          } | null;
        } | null;
      };
      phase: string;
      retryCount?: number | null;
      startedAt: c.Time;
      syncResult?: {
        managedNamespaceMetadata?: {
          annotations?: Record<string,string> | null;
          labels?: Record<string,string> | null;
        } | null;
        resources?: Array<{
          group: string;
          hookPhase?: string | null;
          hookType?: string | null;
          kind: string;
          message?: string | null;
          name: string;
          namespace: string;
          status?: string | null;
          syncPhase?: string | null;
          version: string;
        }> | null;
        revision: string;
        revisions?: Array<string> | null;
        source?: ApplicationSource | null;
        sources?: Array<ApplicationSource> | null;
      } | null;
    } | null;
    reconciledAt?: c.Time | null;
    resourceHealthSource?: string | null;
    resources?: Array<{
      group?: string | null;
      health?: {
        message?: string | null;
        status?: string | null;
      } | null;
      hook?: boolean | null;
      kind?: string | null;
      name?: string | null;
      namespace?: string | null;
      requiresPruning?: boolean | null;
      status?: string | null;
      syncWave?: number | null;
      version?: string | null;
    }> | null;
    sourceType?: string | null;
    sourceTypes?: Array<string> | null;
    summary?: {
      externalURLs?: Array<string> | null;
      images?: Array<string> | null;
    } | null;
    sync?: {
      comparedTo?: {
        destination: {
          name?: string | null;
          namespace?: string | null;
          server?: string | null;
        };
        ignoreDifferences?: Array<{
          group?: string | null;
          jqPathExpressions?: Array<string> | null;
          jsonPointers?: Array<string> | null;
          kind: string;
          managedFieldsManagers?: Array<string> | null;
          name?: string | null;
          namespace?: string | null;
        }> | null;
        source?: ApplicationSource | null;
        sources?: Array<ApplicationSource> | null;
      } | null;
      revision?: string | null;
      revisions?: Array<string> | null;
      status: string;
    } | null;
  } | null;
}
export function toApplication(input: c.JSONValue): Application & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "argoproj.io/v1alpha1", "Application"),
    metadata: MetaV1.toObjectMeta(obj["metadata"]),
    operation: c.readOpt(obj["operation"], toApplication_operation),
    spec: toApplication_spec(obj["spec"]),
    status: c.readOpt(obj["status"], toApplication_status),
  }}
export function fromApplication(input: Application): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "argoproj.io/v1alpha1", "Application"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    operation: input.operation != null ? {
      ...input.operation,
      sync: input.operation.sync != null ? {
        ...input.operation.sync,
        source: input.operation.sync.source != null ? fromApplicationSource(input.operation.sync.source) : undefined,
        sources: input.operation.sync.sources?.map(fromApplicationSource),
      } : undefined,
    } : undefined,
    spec: input.spec != null ? {
      ...input.spec,
      source: input.spec.source != null ? fromApplicationSource(input.spec.source) : undefined,
      sources: input.spec.sources?.map(fromApplicationSource),
    } : undefined,
    status: input.status != null ? {
      ...input.status,
      conditions: input.status.conditions?.map(x => ({
        ...x,
        lastTransitionTime: x.lastTransitionTime != null ? c.fromTime(x.lastTransitionTime) : undefined,
      })),
      history: input.status.history?.map(x => ({
        ...x,
        deployStartedAt: x.deployStartedAt != null ? c.fromTime(x.deployStartedAt) : undefined,
        deployedAt: x.deployedAt != null ? c.fromTime(x.deployedAt) : undefined,
        source: x.source != null ? fromApplicationSource(x.source) : undefined,
        sources: x.sources?.map(fromApplicationSource),
      })),
      observedAt: input.status.observedAt != null ? c.fromTime(input.status.observedAt) : undefined,
      operationState: input.status.operationState != null ? {
        ...input.status.operationState,
        finishedAt: input.status.operationState.finishedAt != null ? c.fromTime(input.status.operationState.finishedAt) : undefined,
        operation: input.status.operationState.operation != null ? {
          ...input.status.operationState.operation,
          sync: input.status.operationState.operation.sync != null ? {
            ...input.status.operationState.operation.sync,
            source: input.status.operationState.operation.sync.source != null ? fromApplicationSource(input.status.operationState.operation.sync.source) : undefined,
            sources: input.status.operationState.operation.sync.sources?.map(fromApplicationSource),
          } : undefined,
        } : undefined,
        startedAt: input.status.operationState.startedAt != null ? c.fromTime(input.status.operationState.startedAt) : undefined,
        syncResult: input.status.operationState.syncResult != null ? {
          ...input.status.operationState.syncResult,
          source: input.status.operationState.syncResult.source != null ? fromApplicationSource(input.status.operationState.syncResult.source) : undefined,
          sources: input.status.operationState.syncResult.sources?.map(fromApplicationSource),
        } : undefined,
      } : undefined,
      reconciledAt: input.status.reconciledAt != null ? c.fromTime(input.status.reconciledAt) : undefined,
      sync: input.status.sync != null ? {
        ...input.status.sync,
        comparedTo: input.status.sync.comparedTo != null ? {
          ...input.status.sync.comparedTo,
          source: input.status.sync.comparedTo.source != null ? fromApplicationSource(input.status.sync.comparedTo.source) : undefined,
          sources: input.status.sync.comparedTo.sources?.map(fromApplicationSource),
        } : undefined,
      } : undefined,
    } : undefined,
  }}
function toApplication_operation(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    info: c.readOpt(obj["info"], x => c.readList(x, toApplication_operation_info)),
    initiatedBy: c.readOpt(obj["initiatedBy"], toApplication_operation_initiatedBy),
    retry: c.readOpt(obj["retry"], toApplication_operation_retry),
    sync: c.readOpt(obj["sync"], toApplication_operation_sync),
  }}
function toApplication_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    destination: toApplication_spec_destination(obj["destination"]),
    ignoreDifferences: c.readOpt(obj["ignoreDifferences"], x => c.readList(x, toApplication_spec_ignoreDifferences)),
    info: c.readOpt(obj["info"], x => c.readList(x, toApplication_spec_info)),
    project: c.checkStr(obj["project"]),
    revisionHistoryLimit: c.readOpt(obj["revisionHistoryLimit"], c.checkNum),
    source: c.readOpt(obj["source"], toApplicationSource),
    sources: c.readOpt(obj["sources"], x => c.readList(x, toApplicationSource)),
    syncPolicy: c.readOpt(obj["syncPolicy"], toApplication_spec_syncPolicy),
  }}
function toApplication_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toApplication_status_conditions)),
    controllerNamespace: c.readOpt(obj["controllerNamespace"], c.checkStr),
    health: c.readOpt(obj["health"], toApplication_status_health),
    history: c.readOpt(obj["history"], x => c.readList(x, toApplication_status_history)),
    observedAt: c.readOpt(obj["observedAt"], c.toTime),
    operationState: c.readOpt(obj["operationState"], toApplication_status_operationState),
    reconciledAt: c.readOpt(obj["reconciledAt"], c.toTime),
    resourceHealthSource: c.readOpt(obj["resourceHealthSource"], c.checkStr),
    resources: c.readOpt(obj["resources"], x => c.readList(x, toApplication_status_resources)),
    sourceType: c.readOpt(obj["sourceType"], c.checkStr),
    sourceTypes: c.readOpt(obj["sourceTypes"], x => c.readList(x, c.checkStr)),
    summary: c.readOpt(obj["summary"], toApplication_status_summary),
    sync: c.readOpt(obj["sync"], toApplication_status_sync),
  }}
function toApplication_operation_info(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    value: c.checkStr(obj["value"]),
  }}
function toApplication_operation_initiatedBy(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    automated: c.readOpt(obj["automated"], c.checkBool),
    username: c.readOpt(obj["username"], c.checkStr),
  }}
function toApplication_operation_retry(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    backoff: c.readOpt(obj["backoff"], toApplication_operation_retry_backoff),
    limit: c.readOpt(obj["limit"], c.checkNum),
  }}
function toApplication_operation_sync(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    autoHealAttemptsCount: c.readOpt(obj["autoHealAttemptsCount"], c.checkNum),
    dryRun: c.readOpt(obj["dryRun"], c.checkBool),
    manifests: c.readOpt(obj["manifests"], x => c.readList(x, c.checkStr)),
    prune: c.readOpt(obj["prune"], c.checkBool),
    resources: c.readOpt(obj["resources"], x => c.readList(x, toApplication_operation_sync_resources)),
    revision: c.readOpt(obj["revision"], c.checkStr),
    revisions: c.readOpt(obj["revisions"], x => c.readList(x, c.checkStr)),
    source: c.readOpt(obj["source"], toApplicationSource),
    sources: c.readOpt(obj["sources"], x => c.readList(x, toApplicationSource)),
    syncOptions: c.readOpt(obj["syncOptions"], x => c.readList(x, c.checkStr)),
    syncStrategy: c.readOpt(obj["syncStrategy"], toApplication_operation_sync_syncStrategy),
  }}
function toApplication_spec_destination(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    server: c.readOpt(obj["server"], c.checkStr),
  }}
function toApplication_spec_ignoreDifferences(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    jqPathExpressions: c.readOpt(obj["jqPathExpressions"], x => c.readList(x, c.checkStr)),
    jsonPointers: c.readOpt(obj["jsonPointers"], x => c.readList(x, c.checkStr)),
    kind: c.checkStr(obj["kind"]),
    managedFieldsManagers: c.readOpt(obj["managedFieldsManagers"], x => c.readList(x, c.checkStr)),
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
  }}
function toApplication_spec_info(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    value: c.checkStr(obj["value"]),
  }}
function toApplication_spec_syncPolicy(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    automated: c.readOpt(obj["automated"], toApplication_spec_syncPolicy_automated),
    managedNamespaceMetadata: c.readOpt(obj["managedNamespaceMetadata"], toApplication_spec_syncPolicy_managedNamespaceMetadata),
    retry: c.readOpt(obj["retry"], toApplication_spec_syncPolicy_retry),
    syncOptions: c.readOpt(obj["syncOptions"], x => c.readList(x, c.checkStr)),
  }}
function toApplication_status_conditions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.checkStr(obj["message"]),
    type: c.checkStr(obj["type"]),
  }}
function toApplication_status_health(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    message: c.readOpt(obj["message"], c.checkStr),
    status: c.readOpt(obj["status"], c.checkStr),
  }}
function toApplication_status_history(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    deployStartedAt: c.readOpt(obj["deployStartedAt"], c.toTime),
    deployedAt: c.toTime(obj["deployedAt"]),
    id: c.checkNum(obj["id"]),
    initiatedBy: c.readOpt(obj["initiatedBy"], toApplication_status_history_initiatedBy),
    revision: c.readOpt(obj["revision"], c.checkStr),
    revisions: c.readOpt(obj["revisions"], x => c.readList(x, c.checkStr)),
    source: c.readOpt(obj["source"], toApplicationSource),
    sources: c.readOpt(obj["sources"], x => c.readList(x, toApplicationSource)),
  }}
function toApplication_status_operationState(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    finishedAt: c.readOpt(obj["finishedAt"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    operation: toApplication_status_operationState_operation(obj["operation"]),
    phase: c.checkStr(obj["phase"]),
    retryCount: c.readOpt(obj["retryCount"], c.checkNum),
    startedAt: c.toTime(obj["startedAt"]),
    syncResult: c.readOpt(obj["syncResult"], toApplication_status_operationState_syncResult),
  }}
function toApplication_status_resources(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    health: c.readOpt(obj["health"], toApplication_status_resources_health),
    hook: c.readOpt(obj["hook"], c.checkBool),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    requiresPruning: c.readOpt(obj["requiresPruning"], c.checkBool),
    status: c.readOpt(obj["status"], c.checkStr),
    syncWave: c.readOpt(obj["syncWave"], c.checkNum),
    version: c.readOpt(obj["version"], c.checkStr),
  }}
function toApplication_status_summary(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    externalURLs: c.readOpt(obj["externalURLs"], x => c.readList(x, c.checkStr)),
    images: c.readOpt(obj["images"], x => c.readList(x, c.checkStr)),
  }}
function toApplication_status_sync(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    comparedTo: c.readOpt(obj["comparedTo"], toApplication_status_sync_comparedTo),
    revision: c.readOpt(obj["revision"], c.checkStr),
    revisions: c.readOpt(obj["revisions"], x => c.readList(x, c.checkStr)),
    status: c.checkStr(obj["status"]),
  }}
function toApplication_operation_retry_backoff(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    duration: c.readOpt(obj["duration"], c.checkStr),
    factor: c.readOpt(obj["factor"], c.checkNum),
    maxDuration: c.readOpt(obj["maxDuration"], c.checkStr),
  }}
function toApplication_operation_sync_resources(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
  }}
function toApplication_operation_sync_syncStrategy(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    apply: c.readOpt(obj["apply"], toApplication_operation_sync_syncStrategy_apply),
    hook: c.readOpt(obj["hook"], toApplication_operation_sync_syncStrategy_hook),
  }}
function toApplication_spec_syncPolicy_automated(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    allowEmpty: c.readOpt(obj["allowEmpty"], c.checkBool),
    prune: c.readOpt(obj["prune"], c.checkBool),
    selfHeal: c.readOpt(obj["selfHeal"], c.checkBool),
  }}
function toApplication_spec_syncPolicy_managedNamespaceMetadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
function toApplication_spec_syncPolicy_retry(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    backoff: c.readOpt(obj["backoff"], toApplication_spec_syncPolicy_retry_backoff),
    limit: c.readOpt(obj["limit"], c.checkNum),
  }}
function toApplication_status_history_initiatedBy(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    automated: c.readOpt(obj["automated"], c.checkBool),
    username: c.readOpt(obj["username"], c.checkStr),
  }}
function toApplication_status_operationState_operation(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    info: c.readOpt(obj["info"], x => c.readList(x, toApplication_status_operationState_operation_info)),
    initiatedBy: c.readOpt(obj["initiatedBy"], toApplication_status_operationState_operation_initiatedBy),
    retry: c.readOpt(obj["retry"], toApplication_status_operationState_operation_retry),
    sync: c.readOpt(obj["sync"], toApplication_status_operationState_operation_sync),
  }}
function toApplication_status_operationState_syncResult(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    managedNamespaceMetadata: c.readOpt(obj["managedNamespaceMetadata"], toApplication_status_operationState_syncResult_managedNamespaceMetadata),
    resources: c.readOpt(obj["resources"], x => c.readList(x, toApplication_status_operationState_syncResult_resources)),
    revision: c.checkStr(obj["revision"]),
    revisions: c.readOpt(obj["revisions"], x => c.readList(x, c.checkStr)),
    source: c.readOpt(obj["source"], toApplicationSource),
    sources: c.readOpt(obj["sources"], x => c.readList(x, toApplicationSource)),
  }}
function toApplication_status_resources_health(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    message: c.readOpt(obj["message"], c.checkStr),
    status: c.readOpt(obj["status"], c.checkStr),
  }}
function toApplication_status_sync_comparedTo(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    destination: toApplication_status_sync_comparedTo_destination(obj["destination"]),
    ignoreDifferences: c.readOpt(obj["ignoreDifferences"], x => c.readList(x, toApplication_status_sync_comparedTo_ignoreDifferences)),
    source: c.readOpt(obj["source"], toApplicationSource),
    sources: c.readOpt(obj["sources"], x => c.readList(x, toApplicationSource)),
  }}
function toApplication_operation_sync_syncStrategy_apply(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    force: c.readOpt(obj["force"], c.checkBool),
  }}
function toApplication_operation_sync_syncStrategy_hook(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    force: c.readOpt(obj["force"], c.checkBool),
  }}
function toApplication_spec_syncPolicy_retry_backoff(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    duration: c.readOpt(obj["duration"], c.checkStr),
    factor: c.readOpt(obj["factor"], c.checkNum),
    maxDuration: c.readOpt(obj["maxDuration"], c.checkStr),
  }}
function toApplication_status_operationState_operation_info(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    value: c.checkStr(obj["value"]),
  }}
function toApplication_status_operationState_operation_initiatedBy(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    automated: c.readOpt(obj["automated"], c.checkBool),
    username: c.readOpt(obj["username"], c.checkStr),
  }}
function toApplication_status_operationState_operation_retry(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    backoff: c.readOpt(obj["backoff"], toApplication_status_operationState_operation_retry_backoff),
    limit: c.readOpt(obj["limit"], c.checkNum),
  }}
function toApplication_status_operationState_operation_sync(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    autoHealAttemptsCount: c.readOpt(obj["autoHealAttemptsCount"], c.checkNum),
    dryRun: c.readOpt(obj["dryRun"], c.checkBool),
    manifests: c.readOpt(obj["manifests"], x => c.readList(x, c.checkStr)),
    prune: c.readOpt(obj["prune"], c.checkBool),
    resources: c.readOpt(obj["resources"], x => c.readList(x, toApplication_status_operationState_operation_sync_resources)),
    revision: c.readOpt(obj["revision"], c.checkStr),
    revisions: c.readOpt(obj["revisions"], x => c.readList(x, c.checkStr)),
    source: c.readOpt(obj["source"], toApplicationSource),
    sources: c.readOpt(obj["sources"], x => c.readList(x, toApplicationSource)),
    syncOptions: c.readOpt(obj["syncOptions"], x => c.readList(x, c.checkStr)),
    syncStrategy: c.readOpt(obj["syncStrategy"], toApplication_status_operationState_operation_sync_syncStrategy),
  }}
function toApplication_status_operationState_syncResult_managedNamespaceMetadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
function toApplication_status_operationState_syncResult_resources(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.checkStr(obj["group"]),
    hookPhase: c.readOpt(obj["hookPhase"], c.checkStr),
    hookType: c.readOpt(obj["hookType"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    message: c.readOpt(obj["message"], c.checkStr),
    name: c.checkStr(obj["name"]),
    namespace: c.checkStr(obj["namespace"]),
    status: c.readOpt(obj["status"], c.checkStr),
    syncPhase: c.readOpt(obj["syncPhase"], c.checkStr),
    version: c.checkStr(obj["version"]),
  }}
function toApplication_status_sync_comparedTo_destination(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    server: c.readOpt(obj["server"], c.checkStr),
  }}
function toApplication_status_sync_comparedTo_ignoreDifferences(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    jqPathExpressions: c.readOpt(obj["jqPathExpressions"], x => c.readList(x, c.checkStr)),
    jsonPointers: c.readOpt(obj["jsonPointers"], x => c.readList(x, c.checkStr)),
    kind: c.checkStr(obj["kind"]),
    managedFieldsManagers: c.readOpt(obj["managedFieldsManagers"], x => c.readList(x, c.checkStr)),
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
  }}
function toApplication_status_operationState_operation_retry_backoff(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    duration: c.readOpt(obj["duration"], c.checkStr),
    factor: c.readOpt(obj["factor"], c.checkNum),
    maxDuration: c.readOpt(obj["maxDuration"], c.checkStr),
  }}
function toApplication_status_operationState_operation_sync_resources(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.checkStr(obj["kind"]),
    name: c.checkStr(obj["name"]),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
  }}
function toApplication_status_operationState_operation_sync_syncStrategy(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    apply: c.readOpt(obj["apply"], toApplication_status_operationState_operation_sync_syncStrategy_apply),
    hook: c.readOpt(obj["hook"], toApplication_status_operationState_operation_sync_syncStrategy_hook),
  }}
function toApplication_status_operationState_operation_sync_syncStrategy_apply(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    force: c.readOpt(obj["force"], c.checkBool),
  }}
function toApplication_status_operationState_operation_sync_syncStrategy_hook(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    force: c.readOpt(obj["force"], c.checkBool),
  }}

export interface ApplicationList extends ListOf<Application> {
  apiVersion?: "argoproj.io/v1alpha1";
  kind?: "ApplicationList";
};
export function toApplicationList(input: c.JSONValue): ApplicationList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "argoproj.io/v1alpha1", "ApplicationList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toApplication),
  }}

export interface ApplicationSetGenerator {
  clusterDecisionResource?: {
    configMapRef: string;
    labelSelector?: MetaV1.LabelSelector | null;
    name?: string | null;
    requeueAfterSeconds?: number | null;
    template?: ApplicationTemplate | null;
    values?: Record<string,string> | null;
  } | null;
  clusters?: {
    selector?: MetaV1.LabelSelector | null;
    template?: ApplicationTemplate | null;
    values?: Record<string,string> | null;
  } | null;
  git?: {
    directories?: Array<{
      exclude?: boolean | null;
      path: string;
    }> | null;
    files?: Array<{
      path: string;
    }> | null;
    pathParamPrefix?: string | null;
    repoURL: string;
    requeueAfterSeconds?: number | null;
    revision: string;
    template?: ApplicationTemplate | null;
    values?: Record<string,string> | null;
  } | null;
  list?: {
    elements?: Array<c.JSONValue> | null;
    elementsYaml?: string | null;
    template?: ApplicationTemplate | null;
  } | null;
  matrix?: {
    generators: Array<ApplicationSetGenerator>;
    template?: ApplicationTemplate | null;
  } | null;
  merge?: {
    generators: Array<ApplicationSetGenerator>;
    mergeKeys: Array<string>;
    template?: ApplicationTemplate | null;
  } | null;
  plugin?: {
    configMapRef: {
      name: string;
    };
    input?: {
      parameters?: Record<string,c.JSONValue> | null;
    } | null;
    requeueAfterSeconds?: number | null;
    template?: ApplicationTemplate | null;
    values?: Record<string,string> | null;
  } | null;
  pullRequest?: {
    azuredevops?: {
      api?: string | null;
      labels?: Array<string> | null;
      organization: string;
      project: string;
      repo: string;
      tokenRef?: {
        key: string;
        secretName: string;
      } | null;
    } | null;
    bitbucket?: {
      api?: string | null;
      basicAuth?: {
        passwordRef: {
          key: string;
          secretName: string;
        };
        username: string;
      } | null;
      bearerToken?: {
        tokenRef: {
          key: string;
          secretName: string;
        };
      } | null;
      owner: string;
      repo: string;
    } | null;
    bitbucketServer?: {
      api: string;
      basicAuth?: {
        passwordRef: {
          key: string;
          secretName: string;
        };
        username: string;
      } | null;
      bearerToken?: {
        tokenRef: {
          key: string;
          secretName: string;
        };
      } | null;
      caRef?: {
        configMapName: string;
        key: string;
      } | null;
      insecure?: boolean | null;
      project: string;
      repo: string;
    } | null;
    filters?: Array<{
      branchMatch?: string | null;
      targetBranchMatch?: string | null;
    }> | null;
    gitea?: {
      api: string;
      insecure?: boolean | null;
      owner: string;
      repo: string;
      tokenRef?: {
        key: string;
        secretName: string;
      } | null;
    } | null;
    github?: {
      api?: string | null;
      appSecretName?: string | null;
      labels?: Array<string> | null;
      owner: string;
      repo: string;
      tokenRef?: {
        key: string;
        secretName: string;
      } | null;
    } | null;
    gitlab?: {
      api?: string | null;
      caRef?: {
        configMapName: string;
        key: string;
      } | null;
      insecure?: boolean | null;
      labels?: Array<string> | null;
      project: string;
      pullRequestState?: string | null;
      tokenRef?: {
        key: string;
        secretName: string;
      } | null;
    } | null;
    requeueAfterSeconds?: number | null;
    template?: ApplicationTemplate | null;
  } | null;
  scmProvider?: {
    awsCodeCommit?: {
      allBranches?: boolean | null;
      region?: string | null;
      role?: string | null;
      tagFilters?: Array<{
        key: string;
        value?: string | null;
      }> | null;
    } | null;
    azureDevOps?: {
      accessTokenRef: {
        key: string;
        secretName: string;
      };
      allBranches?: boolean | null;
      api?: string | null;
      organization: string;
      teamProject: string;
    } | null;
    bitbucket?: {
      allBranches?: boolean | null;
      appPasswordRef: {
        key: string;
        secretName: string;
      };
      owner: string;
      user: string;
    } | null;
    bitbucketServer?: {
      allBranches?: boolean | null;
      api: string;
      basicAuth?: {
        passwordRef: {
          key: string;
          secretName: string;
        };
        username: string;
      } | null;
      bearerToken?: {
        tokenRef: {
          key: string;
          secretName: string;
        };
      } | null;
      caRef?: {
        configMapName: string;
        key: string;
      } | null;
      insecure?: boolean | null;
      project: string;
    } | null;
    cloneProtocol?: string | null;
    filters?: Array<{
      branchMatch?: string | null;
      labelMatch?: string | null;
      pathsDoNotExist?: Array<string> | null;
      pathsExist?: Array<string> | null;
      repositoryMatch?: string | null;
    }> | null;
    gitea?: {
      allBranches?: boolean | null;
      api: string;
      insecure?: boolean | null;
      owner: string;
      tokenRef?: {
        key: string;
        secretName: string;
      } | null;
    } | null;
    github?: {
      allBranches?: boolean | null;
      api?: string | null;
      appSecretName?: string | null;
      organization: string;
      tokenRef?: {
        key: string;
        secretName: string;
      } | null;
    } | null;
    gitlab?: {
      allBranches?: boolean | null;
      api?: string | null;
      caRef?: {
        configMapName: string;
        key: string;
      } | null;
      group: string;
      includeSharedProjects?: boolean | null;
      includeSubgroups?: boolean | null;
      insecure?: boolean | null;
      tokenRef?: {
        key: string;
        secretName: string;
      } | null;
      topic?: string | null;
    } | null;
    requeueAfterSeconds?: number | null;
    template?: ApplicationTemplate | null;
    values?: Record<string,string> | null;
  } | null;
  selector?: MetaV1.LabelSelector | null;
}
export function toApplicationSetGenerator(input: c.JSONValue): ApplicationSetGenerator {
  const obj = c.checkObj(input);
  return {
    clusterDecisionResource: c.readOpt(obj["clusterDecisionResource"], toApplicationSetGenerator_clusterDecisionResource),
    clusters: c.readOpt(obj["clusters"], toApplicationSetGenerator_clusters),
    git: c.readOpt(obj["git"], toApplicationSetGenerator_git),
    list: c.readOpt(obj["list"], toApplicationSetGenerator_list),
    matrix: c.readOpt(obj["matrix"], toApplicationSetGenerator_matrix),
    merge: c.readOpt(obj["merge"], toApplicationSetGenerator_merge),
    plugin: c.readOpt(obj["plugin"], toApplicationSetGenerator_plugin),
    pullRequest: c.readOpt(obj["pullRequest"], toApplicationSetGenerator_pullRequest),
    scmProvider: c.readOpt(obj["scmProvider"], toApplicationSetGenerator_scmProvider),
    selector: c.readOpt(obj["selector"], MetaV1.toLabelSelector),
  }}
export function fromApplicationSetGenerator(input: ApplicationSetGenerator): c.JSONValue {
  return {
    ...input,
    clusterDecisionResource: input.clusterDecisionResource != null ? {
      ...input.clusterDecisionResource,
      labelSelector: input.clusterDecisionResource.labelSelector != null ? MetaV1.fromLabelSelector(input.clusterDecisionResource.labelSelector) : undefined,
      template: input.clusterDecisionResource.template != null ? fromApplicationTemplate(input.clusterDecisionResource.template) : undefined,
    } : undefined,
    clusters: input.clusters != null ? {
      ...input.clusters,
      selector: input.clusters.selector != null ? MetaV1.fromLabelSelector(input.clusters.selector) : undefined,
      template: input.clusters.template != null ? fromApplicationTemplate(input.clusters.template) : undefined,
    } : undefined,
    git: input.git != null ? {
      ...input.git,
      template: input.git.template != null ? fromApplicationTemplate(input.git.template) : undefined,
    } : undefined,
    list: input.list != null ? {
      ...input.list,
      template: input.list.template != null ? fromApplicationTemplate(input.list.template) : undefined,
    } : undefined,
    matrix: input.matrix != null ? {
      ...input.matrix,
      generators: input.matrix.generators?.map(fromApplicationSetGenerator),
      template: input.matrix.template != null ? fromApplicationTemplate(input.matrix.template) : undefined,
    } : undefined,
    merge: input.merge != null ? {
      ...input.merge,
      generators: input.merge.generators?.map(fromApplicationSetGenerator),
      template: input.merge.template != null ? fromApplicationTemplate(input.merge.template) : undefined,
    } : undefined,
    plugin: input.plugin != null ? {
      ...input.plugin,
      template: input.plugin.template != null ? fromApplicationTemplate(input.plugin.template) : undefined,
    } : undefined,
    pullRequest: input.pullRequest != null ? {
      ...input.pullRequest,
      template: input.pullRequest.template != null ? fromApplicationTemplate(input.pullRequest.template) : undefined,
    } : undefined,
    scmProvider: input.scmProvider != null ? {
      ...input.scmProvider,
      template: input.scmProvider.template != null ? fromApplicationTemplate(input.scmProvider.template) : undefined,
    } : undefined,
    selector: input.selector != null ? MetaV1.fromLabelSelector(input.selector) : undefined,
  }}
function toApplicationSetGenerator_clusterDecisionResource(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    configMapRef: c.checkStr(obj["configMapRef"]),
    labelSelector: c.readOpt(obj["labelSelector"], MetaV1.toLabelSelector),
    name: c.readOpt(obj["name"], c.checkStr),
    requeueAfterSeconds: c.readOpt(obj["requeueAfterSeconds"], c.checkNum),
    template: c.readOpt(obj["template"], toApplicationTemplate),
    values: c.readOpt(obj["values"], x => c.readMap(x, c.checkStr)),
  }}
function toApplicationSetGenerator_clusters(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    selector: c.readOpt(obj["selector"], MetaV1.toLabelSelector),
    template: c.readOpt(obj["template"], toApplicationTemplate),
    values: c.readOpt(obj["values"], x => c.readMap(x, c.checkStr)),
  }}
function toApplicationSetGenerator_git(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    directories: c.readOpt(obj["directories"], x => c.readList(x, toApplicationSetGenerator_git_directories)),
    files: c.readOpt(obj["files"], x => c.readList(x, toApplicationSetGenerator_git_files)),
    pathParamPrefix: c.readOpt(obj["pathParamPrefix"], c.checkStr),
    repoURL: c.checkStr(obj["repoURL"]),
    requeueAfterSeconds: c.readOpt(obj["requeueAfterSeconds"], c.checkNum),
    revision: c.checkStr(obj["revision"]),
    template: c.readOpt(obj["template"], toApplicationTemplate),
    values: c.readOpt(obj["values"], x => c.readMap(x, c.checkStr)),
  }}
function toApplicationSetGenerator_list(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    elements: c.readOpt(obj["elements"], x => c.readList(x, c.identity)),
    elementsYaml: c.readOpt(obj["elementsYaml"], c.checkStr),
    template: c.readOpt(obj["template"], toApplicationTemplate),
  }}
function toApplicationSetGenerator_matrix(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    generators: c.readList(obj["generators"], toApplicationSetGenerator),
    template: c.readOpt(obj["template"], toApplicationTemplate),
  }}
function toApplicationSetGenerator_merge(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    generators: c.readList(obj["generators"], toApplicationSetGenerator),
    mergeKeys: c.readList(obj["mergeKeys"], c.checkStr),
    template: c.readOpt(obj["template"], toApplicationTemplate),
  }}
function toApplicationSetGenerator_plugin(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    configMapRef: toApplicationSetGenerator_plugin_configMapRef(obj["configMapRef"]),
    input: c.readOpt(obj["input"], toApplicationSetGenerator_plugin_input),
    requeueAfterSeconds: c.readOpt(obj["requeueAfterSeconds"], c.checkNum),
    template: c.readOpt(obj["template"], toApplicationTemplate),
    values: c.readOpt(obj["values"], x => c.readMap(x, c.checkStr)),
  }}
function toApplicationSetGenerator_pullRequest(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    azuredevops: c.readOpt(obj["azuredevops"], toApplicationSetGenerator_pullRequest_azuredevops),
    bitbucket: c.readOpt(obj["bitbucket"], toApplicationSetGenerator_pullRequest_bitbucket),
    bitbucketServer: c.readOpt(obj["bitbucketServer"], toApplicationSetGenerator_pullRequest_bitbucketServer),
    filters: c.readOpt(obj["filters"], x => c.readList(x, toApplicationSetGenerator_pullRequest_filters)),
    gitea: c.readOpt(obj["gitea"], toApplicationSetGenerator_pullRequest_gitea),
    github: c.readOpt(obj["github"], toApplicationSetGenerator_pullRequest_github),
    gitlab: c.readOpt(obj["gitlab"], toApplicationSetGenerator_pullRequest_gitlab),
    requeueAfterSeconds: c.readOpt(obj["requeueAfterSeconds"], c.checkNum),
    template: c.readOpt(obj["template"], toApplicationTemplate),
  }}
function toApplicationSetGenerator_scmProvider(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    awsCodeCommit: c.readOpt(obj["awsCodeCommit"], toApplicationSetGenerator_scmProvider_awsCodeCommit),
    azureDevOps: c.readOpt(obj["azureDevOps"], toApplicationSetGenerator_scmProvider_azureDevOps),
    bitbucket: c.readOpt(obj["bitbucket"], toApplicationSetGenerator_scmProvider_bitbucket),
    bitbucketServer: c.readOpt(obj["bitbucketServer"], toApplicationSetGenerator_scmProvider_bitbucketServer),
    cloneProtocol: c.readOpt(obj["cloneProtocol"], c.checkStr),
    filters: c.readOpt(obj["filters"], x => c.readList(x, toApplicationSetGenerator_scmProvider_filters)),
    gitea: c.readOpt(obj["gitea"], toApplicationSetGenerator_scmProvider_gitea),
    github: c.readOpt(obj["github"], toApplicationSetGenerator_scmProvider_github),
    gitlab: c.readOpt(obj["gitlab"], toApplicationSetGenerator_scmProvider_gitlab),
    requeueAfterSeconds: c.readOpt(obj["requeueAfterSeconds"], c.checkNum),
    template: c.readOpt(obj["template"], toApplicationTemplate),
    values: c.readOpt(obj["values"], x => c.readMap(x, c.checkStr)),
  }}
function toApplicationSetGenerator_git_directories(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    exclude: c.readOpt(obj["exclude"], c.checkBool),
    path: c.checkStr(obj["path"]),
  }}
function toApplicationSetGenerator_git_files(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    path: c.checkStr(obj["path"]),
  }}
function toApplicationSetGenerator_plugin_configMapRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
  }}
function toApplicationSetGenerator_plugin_input(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    parameters: c.readOpt(obj["parameters"], x => c.readMap(x, c.identity)),
  }}
function toApplicationSetGenerator_pullRequest_azuredevops(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    api: c.readOpt(obj["api"], c.checkStr),
    labels: c.readOpt(obj["labels"], x => c.readList(x, c.checkStr)),
    organization: c.checkStr(obj["organization"]),
    project: c.checkStr(obj["project"]),
    repo: c.checkStr(obj["repo"]),
    tokenRef: c.readOpt(obj["tokenRef"], toApplicationSetGenerator_pullRequest_azuredevops_tokenRef),
  }}
function toApplicationSetGenerator_pullRequest_bitbucket(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    api: c.readOpt(obj["api"], c.checkStr),
    basicAuth: c.readOpt(obj["basicAuth"], toApplicationSetGenerator_pullRequest_bitbucket_basicAuth),
    bearerToken: c.readOpt(obj["bearerToken"], toApplicationSetGenerator_pullRequest_bitbucket_bearerToken),
    owner: c.checkStr(obj["owner"]),
    repo: c.checkStr(obj["repo"]),
  }}
function toApplicationSetGenerator_pullRequest_bitbucketServer(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    api: c.checkStr(obj["api"]),
    basicAuth: c.readOpt(obj["basicAuth"], toApplicationSetGenerator_pullRequest_bitbucketServer_basicAuth),
    bearerToken: c.readOpt(obj["bearerToken"], toApplicationSetGenerator_pullRequest_bitbucketServer_bearerToken),
    caRef: c.readOpt(obj["caRef"], toApplicationSetGenerator_pullRequest_bitbucketServer_caRef),
    insecure: c.readOpt(obj["insecure"], c.checkBool),
    project: c.checkStr(obj["project"]),
    repo: c.checkStr(obj["repo"]),
  }}
function toApplicationSetGenerator_pullRequest_filters(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    branchMatch: c.readOpt(obj["branchMatch"], c.checkStr),
    targetBranchMatch: c.readOpt(obj["targetBranchMatch"], c.checkStr),
  }}
function toApplicationSetGenerator_pullRequest_gitea(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    api: c.checkStr(obj["api"]),
    insecure: c.readOpt(obj["insecure"], c.checkBool),
    owner: c.checkStr(obj["owner"]),
    repo: c.checkStr(obj["repo"]),
    tokenRef: c.readOpt(obj["tokenRef"], toApplicationSetGenerator_pullRequest_gitea_tokenRef),
  }}
function toApplicationSetGenerator_pullRequest_github(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    api: c.readOpt(obj["api"], c.checkStr),
    appSecretName: c.readOpt(obj["appSecretName"], c.checkStr),
    labels: c.readOpt(obj["labels"], x => c.readList(x, c.checkStr)),
    owner: c.checkStr(obj["owner"]),
    repo: c.checkStr(obj["repo"]),
    tokenRef: c.readOpt(obj["tokenRef"], toApplicationSetGenerator_pullRequest_github_tokenRef),
  }}
function toApplicationSetGenerator_pullRequest_gitlab(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    api: c.readOpt(obj["api"], c.checkStr),
    caRef: c.readOpt(obj["caRef"], toApplicationSetGenerator_pullRequest_gitlab_caRef),
    insecure: c.readOpt(obj["insecure"], c.checkBool),
    labels: c.readOpt(obj["labels"], x => c.readList(x, c.checkStr)),
    project: c.checkStr(obj["project"]),
    pullRequestState: c.readOpt(obj["pullRequestState"], c.checkStr),
    tokenRef: c.readOpt(obj["tokenRef"], toApplicationSetGenerator_pullRequest_gitlab_tokenRef),
  }}
function toApplicationSetGenerator_scmProvider_awsCodeCommit(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    allBranches: c.readOpt(obj["allBranches"], c.checkBool),
    region: c.readOpt(obj["region"], c.checkStr),
    role: c.readOpt(obj["role"], c.checkStr),
    tagFilters: c.readOpt(obj["tagFilters"], x => c.readList(x, toApplicationSetGenerator_scmProvider_awsCodeCommit_tagFilters)),
  }}
function toApplicationSetGenerator_scmProvider_azureDevOps(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accessTokenRef: toApplicationSetGenerator_scmProvider_azureDevOps_accessTokenRef(obj["accessTokenRef"]),
    allBranches: c.readOpt(obj["allBranches"], c.checkBool),
    api: c.readOpt(obj["api"], c.checkStr),
    organization: c.checkStr(obj["organization"]),
    teamProject: c.checkStr(obj["teamProject"]),
  }}
function toApplicationSetGenerator_scmProvider_bitbucket(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    allBranches: c.readOpt(obj["allBranches"], c.checkBool),
    appPasswordRef: toApplicationSetGenerator_scmProvider_bitbucket_appPasswordRef(obj["appPasswordRef"]),
    owner: c.checkStr(obj["owner"]),
    user: c.checkStr(obj["user"]),
  }}
function toApplicationSetGenerator_scmProvider_bitbucketServer(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    allBranches: c.readOpt(obj["allBranches"], c.checkBool),
    api: c.checkStr(obj["api"]),
    basicAuth: c.readOpt(obj["basicAuth"], toApplicationSetGenerator_scmProvider_bitbucketServer_basicAuth),
    bearerToken: c.readOpt(obj["bearerToken"], toApplicationSetGenerator_scmProvider_bitbucketServer_bearerToken),
    caRef: c.readOpt(obj["caRef"], toApplicationSetGenerator_scmProvider_bitbucketServer_caRef),
    insecure: c.readOpt(obj["insecure"], c.checkBool),
    project: c.checkStr(obj["project"]),
  }}
function toApplicationSetGenerator_scmProvider_filters(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    branchMatch: c.readOpt(obj["branchMatch"], c.checkStr),
    labelMatch: c.readOpt(obj["labelMatch"], c.checkStr),
    pathsDoNotExist: c.readOpt(obj["pathsDoNotExist"], x => c.readList(x, c.checkStr)),
    pathsExist: c.readOpt(obj["pathsExist"], x => c.readList(x, c.checkStr)),
    repositoryMatch: c.readOpt(obj["repositoryMatch"], c.checkStr),
  }}
function toApplicationSetGenerator_scmProvider_gitea(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    allBranches: c.readOpt(obj["allBranches"], c.checkBool),
    api: c.checkStr(obj["api"]),
    insecure: c.readOpt(obj["insecure"], c.checkBool),
    owner: c.checkStr(obj["owner"]),
    tokenRef: c.readOpt(obj["tokenRef"], toApplicationSetGenerator_scmProvider_gitea_tokenRef),
  }}
function toApplicationSetGenerator_scmProvider_github(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    allBranches: c.readOpt(obj["allBranches"], c.checkBool),
    api: c.readOpt(obj["api"], c.checkStr),
    appSecretName: c.readOpt(obj["appSecretName"], c.checkStr),
    organization: c.checkStr(obj["organization"]),
    tokenRef: c.readOpt(obj["tokenRef"], toApplicationSetGenerator_scmProvider_github_tokenRef),
  }}
function toApplicationSetGenerator_scmProvider_gitlab(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    allBranches: c.readOpt(obj["allBranches"], c.checkBool),
    api: c.readOpt(obj["api"], c.checkStr),
    caRef: c.readOpt(obj["caRef"], toApplicationSetGenerator_scmProvider_gitlab_caRef),
    group: c.checkStr(obj["group"]),
    includeSharedProjects: c.readOpt(obj["includeSharedProjects"], c.checkBool),
    includeSubgroups: c.readOpt(obj["includeSubgroups"], c.checkBool),
    insecure: c.readOpt(obj["insecure"], c.checkBool),
    tokenRef: c.readOpt(obj["tokenRef"], toApplicationSetGenerator_scmProvider_gitlab_tokenRef),
    topic: c.readOpt(obj["topic"], c.checkStr),
  }}
function toApplicationSetGenerator_pullRequest_azuredevops_tokenRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_pullRequest_bitbucket_basicAuth(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    passwordRef: toApplicationSetGenerator_pullRequest_bitbucket_basicAuth_passwordRef(obj["passwordRef"]),
    username: c.checkStr(obj["username"]),
  }}
function toApplicationSetGenerator_pullRequest_bitbucket_bearerToken(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    tokenRef: toApplicationSetGenerator_pullRequest_bitbucket_bearerToken_tokenRef(obj["tokenRef"]),
  }}
function toApplicationSetGenerator_pullRequest_bitbucketServer_basicAuth(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    passwordRef: toApplicationSetGenerator_pullRequest_bitbucketServer_basicAuth_passwordRef(obj["passwordRef"]),
    username: c.checkStr(obj["username"]),
  }}
function toApplicationSetGenerator_pullRequest_bitbucketServer_bearerToken(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    tokenRef: toApplicationSetGenerator_pullRequest_bitbucketServer_bearerToken_tokenRef(obj["tokenRef"]),
  }}
function toApplicationSetGenerator_pullRequest_bitbucketServer_caRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    configMapName: c.checkStr(obj["configMapName"]),
    key: c.checkStr(obj["key"]),
  }}
function toApplicationSetGenerator_pullRequest_gitea_tokenRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_pullRequest_github_tokenRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_pullRequest_gitlab_caRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    configMapName: c.checkStr(obj["configMapName"]),
    key: c.checkStr(obj["key"]),
  }}
function toApplicationSetGenerator_pullRequest_gitlab_tokenRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_scmProvider_awsCodeCommit_tagFilters(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    value: c.readOpt(obj["value"], c.checkStr),
  }}
function toApplicationSetGenerator_scmProvider_azureDevOps_accessTokenRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_scmProvider_bitbucket_appPasswordRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_scmProvider_bitbucketServer_basicAuth(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    passwordRef: toApplicationSetGenerator_scmProvider_bitbucketServer_basicAuth_passwordRef(obj["passwordRef"]),
    username: c.checkStr(obj["username"]),
  }}
function toApplicationSetGenerator_scmProvider_bitbucketServer_bearerToken(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    tokenRef: toApplicationSetGenerator_scmProvider_bitbucketServer_bearerToken_tokenRef(obj["tokenRef"]),
  }}
function toApplicationSetGenerator_scmProvider_bitbucketServer_caRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    configMapName: c.checkStr(obj["configMapName"]),
    key: c.checkStr(obj["key"]),
  }}
function toApplicationSetGenerator_scmProvider_gitea_tokenRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_scmProvider_github_tokenRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_scmProvider_gitlab_caRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    configMapName: c.checkStr(obj["configMapName"]),
    key: c.checkStr(obj["key"]),
  }}
function toApplicationSetGenerator_scmProvider_gitlab_tokenRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_pullRequest_bitbucket_basicAuth_passwordRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_pullRequest_bitbucket_bearerToken_tokenRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_pullRequest_bitbucketServer_basicAuth_passwordRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_pullRequest_bitbucketServer_bearerToken_tokenRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_scmProvider_bitbucketServer_basicAuth_passwordRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}
function toApplicationSetGenerator_scmProvider_bitbucketServer_bearerToken_tokenRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    secretName: c.checkStr(obj["secretName"]),
  }}

export interface ApplicationTemplate {
  metadata: {
    annotations?: Record<string,string> | null;
    finalizers?: Array<string> | null;
    labels?: Record<string,string> | null;
    name?: string | null;
    namespace?: string | null;
  };
  spec: {
    destination: {
      name?: string | null;
      namespace?: string | null;
      server?: string | null;
    };
    ignoreDifferences?: Array<{
      group?: string | null;
      jqPathExpressions?: Array<string> | null;
      jsonPointers?: Array<string> | null;
      kind: string;
      managedFieldsManagers?: Array<string> | null;
      name?: string | null;
      namespace?: string | null;
    }> | null;
    info?: Array<{
      name: string;
      value: string;
    }> | null;
    project: string;
    revisionHistoryLimit?: number | null;
    source?: ApplicationSource | null;
    sources?: Array<ApplicationSource> | null;
    syncPolicy?: {
      automated?: {
        allowEmpty?: boolean | null;
        prune?: boolean | null;
        selfHeal?: boolean | null;
      } | null;
      managedNamespaceMetadata?: {
        annotations?: Record<string,string> | null;
        labels?: Record<string,string> | null;
      } | null;
      retry?: {
        backoff?: {
          duration?: string | null;
          factor?: number | null;
          maxDuration?: string | null;
        } | null;
        limit?: number | null;
      } | null;
      syncOptions?: Array<string> | null;
    } | null;
  };
}
export function toApplicationTemplate(input: c.JSONValue): ApplicationTemplate {
  const obj = c.checkObj(input);
  return {
    metadata: toApplicationTemplate_metadata(obj["metadata"]),
    spec: toApplicationTemplate_spec(obj["spec"]),
  }}
export function fromApplicationTemplate(input: ApplicationTemplate): c.JSONValue {
  return {
    ...input,
    spec: input.spec != null ? {
      ...input.spec,
      source: input.spec.source != null ? fromApplicationSource(input.spec.source) : undefined,
      sources: input.spec.sources?.map(fromApplicationSource),
    } : undefined,
  }}
function toApplicationTemplate_metadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    finalizers: c.readOpt(obj["finalizers"], x => c.readList(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
  }}
function toApplicationTemplate_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    destination: toApplicationTemplate_spec_destination(obj["destination"]),
    ignoreDifferences: c.readOpt(obj["ignoreDifferences"], x => c.readList(x, toApplicationTemplate_spec_ignoreDifferences)),
    info: c.readOpt(obj["info"], x => c.readList(x, toApplicationTemplate_spec_info)),
    project: c.checkStr(obj["project"]),
    revisionHistoryLimit: c.readOpt(obj["revisionHistoryLimit"], c.checkNum),
    source: c.readOpt(obj["source"], toApplicationSource),
    sources: c.readOpt(obj["sources"], x => c.readList(x, toApplicationSource)),
    syncPolicy: c.readOpt(obj["syncPolicy"], toApplicationTemplate_spec_syncPolicy),
  }}
function toApplicationTemplate_spec_destination(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    server: c.readOpt(obj["server"], c.checkStr),
  }}
function toApplicationTemplate_spec_ignoreDifferences(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    jqPathExpressions: c.readOpt(obj["jqPathExpressions"], x => c.readList(x, c.checkStr)),
    jsonPointers: c.readOpt(obj["jsonPointers"], x => c.readList(x, c.checkStr)),
    kind: c.checkStr(obj["kind"]),
    managedFieldsManagers: c.readOpt(obj["managedFieldsManagers"], x => c.readList(x, c.checkStr)),
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
  }}
function toApplicationTemplate_spec_info(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    value: c.checkStr(obj["value"]),
  }}
function toApplicationTemplate_spec_syncPolicy(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    automated: c.readOpt(obj["automated"], toApplicationTemplate_spec_syncPolicy_automated),
    managedNamespaceMetadata: c.readOpt(obj["managedNamespaceMetadata"], toApplicationTemplate_spec_syncPolicy_managedNamespaceMetadata),
    retry: c.readOpt(obj["retry"], toApplicationTemplate_spec_syncPolicy_retry),
    syncOptions: c.readOpt(obj["syncOptions"], x => c.readList(x, c.checkStr)),
  }}
function toApplicationTemplate_spec_syncPolicy_automated(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    allowEmpty: c.readOpt(obj["allowEmpty"], c.checkBool),
    prune: c.readOpt(obj["prune"], c.checkBool),
    selfHeal: c.readOpt(obj["selfHeal"], c.checkBool),
  }}
function toApplicationTemplate_spec_syncPolicy_managedNamespaceMetadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
function toApplicationTemplate_spec_syncPolicy_retry(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    backoff: c.readOpt(obj["backoff"], toApplicationTemplate_spec_syncPolicy_retry_backoff),
    limit: c.readOpt(obj["limit"], c.checkNum),
  }}
function toApplicationTemplate_spec_syncPolicy_retry_backoff(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    duration: c.readOpt(obj["duration"], c.checkStr),
    factor: c.readOpt(obj["factor"], c.checkNum),
    maxDuration: c.readOpt(obj["maxDuration"], c.checkStr),
  }}

export interface ApplicationSet {
  apiVersion?: "argoproj.io/v1alpha1";
  kind?: "ApplicationSet";
  metadata: MetaV1.ObjectMeta;
  spec: {
    applyNestedSelectors?: boolean | null;
    generators: Array<ApplicationSetGenerator>;
    goTemplate?: boolean | null;
    goTemplateOptions?: Array<string> | null;
    ignoreApplicationDifferences?: Array<{
      jqPathExpressions?: Array<string> | null;
      jsonPointers?: Array<string> | null;
      name?: string | null;
    }> | null;
    preservedFields?: {
      annotations?: Array<string> | null;
      labels?: Array<string> | null;
    } | null;
    strategy?: {
      rollingSync?: {
        steps?: Array<{
          matchExpressions?: Array<{
            key?: string | null;
            operator?: string | null;
            values?: Array<string> | null;
          }> | null;
          maxUpdate?: c.IntOrString | null;
        }> | null;
      } | null;
      type?: string | null;
    } | null;
    syncPolicy?: {
      applicationsSync?: "create-only" | "create-update" | "create-delete" | "sync" | c.UnexpectedEnumValue | null;
      preserveResourcesOnDeletion?: boolean | null;
    } | null;
    template: ApplicationTemplate;
    templatePatch?: string | null;
  };
  status?: {
    applicationStatus?: Array<{
      application: string;
      lastTransitionTime?: c.Time | null;
      message: string;
      status: string;
      step: string;
      targetRevisions: Array<string>;
    }> | null;
    conditions?: Array<{
      lastTransitionTime?: c.Time | null;
      message: string;
      reason: string;
      status: string;
      type: string;
    }> | null;
    resources?: Array<{
      group?: string | null;
      health?: {
        message?: string | null;
        status?: string | null;
      } | null;
      hook?: boolean | null;
      kind?: string | null;
      name?: string | null;
      namespace?: string | null;
      requiresPruning?: boolean | null;
      status?: string | null;
      syncWave?: number | null;
      version?: string | null;
    }> | null;
  } | null;
}
export function toApplicationSet(input: c.JSONValue): ApplicationSet & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "argoproj.io/v1alpha1", "ApplicationSet"),
    metadata: MetaV1.toObjectMeta(obj["metadata"]),
    spec: toApplicationSet_spec(obj["spec"]),
    status: c.readOpt(obj["status"], toApplicationSet_status),
  }}
export function fromApplicationSet(input: ApplicationSet): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "argoproj.io/v1alpha1", "ApplicationSet"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? {
      ...input.spec,
      generators: input.spec.generators?.map(fromApplicationSetGenerator),
      template: input.spec.template != null ? fromApplicationTemplate(input.spec.template) : undefined,
    } : undefined,
    status: input.status != null ? {
      ...input.status,
      applicationStatus: input.status.applicationStatus?.map(x => ({
        ...x,
        lastTransitionTime: x.lastTransitionTime != null ? c.fromTime(x.lastTransitionTime) : undefined,
      })),
      conditions: input.status.conditions?.map(x => ({
        ...x,
        lastTransitionTime: x.lastTransitionTime != null ? c.fromTime(x.lastTransitionTime) : undefined,
      })),
    } : undefined,
  }}
function toApplicationSet_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    applyNestedSelectors: c.readOpt(obj["applyNestedSelectors"], c.checkBool),
    generators: c.readList(obj["generators"], toApplicationSetGenerator),
    goTemplate: c.readOpt(obj["goTemplate"], c.checkBool),
    goTemplateOptions: c.readOpt(obj["goTemplateOptions"], x => c.readList(x, c.checkStr)),
    ignoreApplicationDifferences: c.readOpt(obj["ignoreApplicationDifferences"], x => c.readList(x, toApplicationSet_spec_ignoreApplicationDifferences)),
    preservedFields: c.readOpt(obj["preservedFields"], toApplicationSet_spec_preservedFields),
    strategy: c.readOpt(obj["strategy"], toApplicationSet_spec_strategy),
    syncPolicy: c.readOpt(obj["syncPolicy"], toApplicationSet_spec_syncPolicy),
    template: toApplicationTemplate(obj["template"]),
    templatePatch: c.readOpt(obj["templatePatch"], c.checkStr),
  }}
function toApplicationSet_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    applicationStatus: c.readOpt(obj["applicationStatus"], x => c.readList(x, toApplicationSet_status_applicationStatus)),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toApplicationSet_status_conditions)),
    resources: c.readOpt(obj["resources"], x => c.readList(x, toApplicationSet_status_resources)),
  }}
function toApplicationSet_spec_ignoreApplicationDifferences(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    jqPathExpressions: c.readOpt(obj["jqPathExpressions"], x => c.readList(x, c.checkStr)),
    jsonPointers: c.readOpt(obj["jsonPointers"], x => c.readList(x, c.checkStr)),
    name: c.readOpt(obj["name"], c.checkStr),
  }}
function toApplicationSet_spec_preservedFields(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readList(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readList(x, c.checkStr)),
  }}
function toApplicationSet_spec_strategy(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    rollingSync: c.readOpt(obj["rollingSync"], toApplicationSet_spec_strategy_rollingSync),
    type: c.readOpt(obj["type"], c.checkStr),
  }}
function toApplicationSet_spec_syncPolicy(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    applicationsSync: c.readOpt(obj["applicationsSync"], (x => c.readEnum<"create-only" | "create-update" | "create-delete" | "sync" | c.UnexpectedEnumValue>(x))),
    preserveResourcesOnDeletion: c.readOpt(obj["preserveResourcesOnDeletion"], c.checkBool),
  }}
function toApplicationSet_status_applicationStatus(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    application: c.checkStr(obj["application"]),
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.checkStr(obj["message"]),
    status: c.checkStr(obj["status"]),
    step: c.checkStr(obj["step"]),
    targetRevisions: c.readList(obj["targetRevisions"], c.checkStr),
  }}
function toApplicationSet_status_conditions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.checkStr(obj["message"]),
    reason: c.checkStr(obj["reason"]),
    status: c.checkStr(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
function toApplicationSet_status_resources(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    health: c.readOpt(obj["health"], toApplicationSet_status_resources_health),
    hook: c.readOpt(obj["hook"], c.checkBool),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    requiresPruning: c.readOpt(obj["requiresPruning"], c.checkBool),
    status: c.readOpt(obj["status"], c.checkStr),
    syncWave: c.readOpt(obj["syncWave"], c.checkNum),
    version: c.readOpt(obj["version"], c.checkStr),
  }}
function toApplicationSet_spec_strategy_rollingSync(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    steps: c.readOpt(obj["steps"], x => c.readList(x, toApplicationSet_spec_strategy_rollingSync_steps)),
  }}
function toApplicationSet_status_resources_health(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    message: c.readOpt(obj["message"], c.checkStr),
    status: c.readOpt(obj["status"], c.checkStr),
  }}
function toApplicationSet_spec_strategy_rollingSync_steps(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toApplicationSet_spec_strategy_rollingSync_steps_matchExpressions)),
    maxUpdate: c.readOpt(obj["maxUpdate"], c.toIntOrString),
  }}
function toApplicationSet_spec_strategy_rollingSync_steps_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    operator: c.readOpt(obj["operator"], c.checkStr),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}

export interface ApplicationSetList extends ListOf<ApplicationSet> {
  apiVersion?: "argoproj.io/v1alpha1";
  kind?: "ApplicationSetList";
};
export function toApplicationSetList(input: c.JSONValue): ApplicationSetList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "argoproj.io/v1alpha1", "ApplicationSetList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toApplicationSet),
  }}

/** AppProject provides a logical grouping of applications, providing controls for:
* where the apps may deploy to (cluster whitelist)
* what may be deployed (repository whitelist, resource whitelist/blacklist)
* who can access these applications (roles, OIDC group claims bindings)
* and what they can do (RBAC policies)
* automation access to these roles (JWT tokens) */
export interface AppProject {
  apiVersion?: "argoproj.io/v1alpha1";
  kind?: "AppProject";
  metadata: MetaV1.ObjectMeta;
  spec: {
    clusterResourceBlacklist?: Array<{
      group: string;
      kind: string;
    }> | null;
    clusterResourceWhitelist?: Array<{
      group: string;
      kind: string;
    }> | null;
    description?: string | null;
    destinationServiceAccounts?: Array<{
      defaultServiceAccount: string;
      namespace?: string | null;
      server: string;
    }> | null;
    destinations?: Array<{
      name?: string | null;
      namespace?: string | null;
      server?: string | null;
    }> | null;
    namespaceResourceBlacklist?: Array<{
      group: string;
      kind: string;
    }> | null;
    namespaceResourceWhitelist?: Array<{
      group: string;
      kind: string;
    }> | null;
    orphanedResources?: {
      ignore?: Array<{
        group?: string | null;
        kind?: string | null;
        name?: string | null;
      }> | null;
      warn?: boolean | null;
    } | null;
    permitOnlyProjectScopedClusters?: boolean | null;
    roles?: Array<{
      description?: string | null;
      groups?: Array<string> | null;
      jwtTokens?: Array<{
        exp?: number | null;
        iat: number;
        id?: string | null;
      }> | null;
      name: string;
      policies?: Array<string> | null;
    }> | null;
    signatureKeys?: Array<{
      keyID: string;
    }> | null;
    sourceNamespaces?: Array<string> | null;
    sourceRepos?: Array<string> | null;
    syncWindows?: Array<{
      applications?: Array<string> | null;
      clusters?: Array<string> | null;
      duration?: string | null;
      kind?: string | null;
      manualSync?: boolean | null;
      namespaces?: Array<string> | null;
      schedule?: string | null;
      timeZone?: string | null;
    }> | null;
  };
  status?: {
    jwtTokensByRole?: Record<string,{
      items?: Array<{
        exp?: number | null;
        iat: number;
        id?: string | null;
      }> | null;
    }> | null;
  } | null;
}
export function toAppProject(input: c.JSONValue): AppProject & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "argoproj.io/v1alpha1", "AppProject"),
    metadata: MetaV1.toObjectMeta(obj["metadata"]),
    spec: toAppProject_spec(obj["spec"]),
    status: c.readOpt(obj["status"], toAppProject_status),
  }}
export function fromAppProject(input: AppProject): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "argoproj.io/v1alpha1", "AppProject"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
  }}
function toAppProject_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    clusterResourceBlacklist: c.readOpt(obj["clusterResourceBlacklist"], x => c.readList(x, toAppProject_spec_clusterResourceBlacklist)),
    clusterResourceWhitelist: c.readOpt(obj["clusterResourceWhitelist"], x => c.readList(x, toAppProject_spec_clusterResourceWhitelist)),
    description: c.readOpt(obj["description"], c.checkStr),
    destinationServiceAccounts: c.readOpt(obj["destinationServiceAccounts"], x => c.readList(x, toAppProject_spec_destinationServiceAccounts)),
    destinations: c.readOpt(obj["destinations"], x => c.readList(x, toAppProject_spec_destinations)),
    namespaceResourceBlacklist: c.readOpt(obj["namespaceResourceBlacklist"], x => c.readList(x, toAppProject_spec_namespaceResourceBlacklist)),
    namespaceResourceWhitelist: c.readOpt(obj["namespaceResourceWhitelist"], x => c.readList(x, toAppProject_spec_namespaceResourceWhitelist)),
    orphanedResources: c.readOpt(obj["orphanedResources"], toAppProject_spec_orphanedResources),
    permitOnlyProjectScopedClusters: c.readOpt(obj["permitOnlyProjectScopedClusters"], c.checkBool),
    roles: c.readOpt(obj["roles"], x => c.readList(x, toAppProject_spec_roles)),
    signatureKeys: c.readOpt(obj["signatureKeys"], x => c.readList(x, toAppProject_spec_signatureKeys)),
    sourceNamespaces: c.readOpt(obj["sourceNamespaces"], x => c.readList(x, c.checkStr)),
    sourceRepos: c.readOpt(obj["sourceRepos"], x => c.readList(x, c.checkStr)),
    syncWindows: c.readOpt(obj["syncWindows"], x => c.readList(x, toAppProject_spec_syncWindows)),
  }}
function toAppProject_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    jwtTokensByRole: c.readOpt(obj["jwtTokensByRole"], x => c.readMap(x, toAppProject_status_jwtTokensByRole)),
  }}
function toAppProject_spec_clusterResourceBlacklist(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.checkStr(obj["group"]),
    kind: c.checkStr(obj["kind"]),
  }}
function toAppProject_spec_clusterResourceWhitelist(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.checkStr(obj["group"]),
    kind: c.checkStr(obj["kind"]),
  }}
function toAppProject_spec_destinationServiceAccounts(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    defaultServiceAccount: c.checkStr(obj["defaultServiceAccount"]),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    server: c.checkStr(obj["server"]),
  }}
function toAppProject_spec_destinations(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    server: c.readOpt(obj["server"], c.checkStr),
  }}
function toAppProject_spec_namespaceResourceBlacklist(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.checkStr(obj["group"]),
    kind: c.checkStr(obj["kind"]),
  }}
function toAppProject_spec_namespaceResourceWhitelist(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.checkStr(obj["group"]),
    kind: c.checkStr(obj["kind"]),
  }}
function toAppProject_spec_orphanedResources(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    ignore: c.readOpt(obj["ignore"], x => c.readList(x, toAppProject_spec_orphanedResources_ignore)),
    warn: c.readOpt(obj["warn"], c.checkBool),
  }}
function toAppProject_spec_roles(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    description: c.readOpt(obj["description"], c.checkStr),
    groups: c.readOpt(obj["groups"], x => c.readList(x, c.checkStr)),
    jwtTokens: c.readOpt(obj["jwtTokens"], x => c.readList(x, toAppProject_spec_roles_jwtTokens)),
    name: c.checkStr(obj["name"]),
    policies: c.readOpt(obj["policies"], x => c.readList(x, c.checkStr)),
  }}
function toAppProject_spec_signatureKeys(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    keyID: c.checkStr(obj["keyID"]),
  }}
function toAppProject_spec_syncWindows(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    applications: c.readOpt(obj["applications"], x => c.readList(x, c.checkStr)),
    clusters: c.readOpt(obj["clusters"], x => c.readList(x, c.checkStr)),
    duration: c.readOpt(obj["duration"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    manualSync: c.readOpt(obj["manualSync"], c.checkBool),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    schedule: c.readOpt(obj["schedule"], c.checkStr),
    timeZone: c.readOpt(obj["timeZone"], c.checkStr),
  }}
function toAppProject_status_jwtTokensByRole(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    items: c.readOpt(obj["items"], x => c.readList(x, toAppProject_status_jwtTokensByRole_items)),
  }}
function toAppProject_spec_orphanedResources_ignore(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.readOpt(obj["name"], c.checkStr),
  }}
function toAppProject_spec_roles_jwtTokens(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    exp: c.readOpt(obj["exp"], c.checkNum),
    iat: c.checkNum(obj["iat"]),
    id: c.readOpt(obj["id"], c.checkStr),
  }}
function toAppProject_status_jwtTokensByRole_items(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    exp: c.readOpt(obj["exp"], c.checkNum),
    iat: c.checkNum(obj["iat"]),
    id: c.readOpt(obj["id"], c.checkStr),
  }}

export interface AppProjectList extends ListOf<AppProject> {
  apiVersion?: "argoproj.io/v1alpha1";
  kind?: "AppProjectList";
};
export function toAppProjectList(input: c.JSONValue): AppProjectList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "argoproj.io/v1alpha1", "AppProjectList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toAppProject),
  }}
