// Autogenerated Schema file for AcmeCertManagerIoV1alpha3
import * as c from "../../common.ts";

import * as MetaV1 from "../../builtin/meta@v1/structs.ts";
type Kind<T extends string> = {
  apiVersion: "acme.cert-manager.io/v1alpha3";
  kind: T;
};
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** Challenge is a type to represent a Challenge request with an ACME server */
export type Challenge = Kind<"Challenge"> & ChallengeFields;
export interface ChallengeFields {
  spec?: {
    issuerRef: {
      kind?: string | null;
      name: string;
      group?: string | null;
    };
    url: string;
    type: "http-01" | "dns-01" | c.UnexpectedEnumValue;
    wildcard?: boolean | null;
    authzURL: string;
    dnsName: string;
    token: string;
    solver: {
      dns01?: {
        cnameStrategy?: "None" | "Follow" | c.UnexpectedEnumValue | null;
        akamai?: {
          clientSecretSecretRef: {
            name: string;
            key?: string | null;
          };
          serviceConsumerDomain: string;
          clientTokenSecretRef: {
            key?: string | null;
            name: string;
          };
          accessTokenSecretRef: {
            name: string;
            key?: string | null;
          };
        } | null;
        clouddns?: {
          project: string;
          hostedZoneName?: string | null;
          serviceAccountSecretRef?: {
            name: string;
            key?: string | null;
          } | null;
        } | null;
        azuredns?: {
          clientID?: string | null;
          subscriptionID: string;
          tenantID?: string | null;
          clientSecretSecretRef?: {
            name: string;
            key?: string | null;
          } | null;
          resourceGroupName: string;
          environment?: "AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud" | c.UnexpectedEnumValue | null;
          hostedZoneName?: string | null;
        } | null;
        cloudflare?: {
          email?: string | null;
          apiTokenSecretRef?: {
            key?: string | null;
            name: string;
          } | null;
          apiKeySecretRef?: {
            name: string;
            key?: string | null;
          } | null;
        } | null;
        digitalocean?: {
          tokenSecretRef: {
            name: string;
            key?: string | null;
          };
        } | null;
        route53?: {
          hostedZoneID?: string | null;
          region: string;
          accessKeyID?: string | null;
          role?: string | null;
          secretAccessKeySecretRef?: {
            key?: string | null;
            name: string;
          } | null;
        } | null;
        acmedns?: {
          accountSecretRef: {
            key?: string | null;
            name: string;
          };
          host: string;
        } | null;
        rfc2136?: {
          tsigAlgorithm?: string | null;
          tsigSecretSecretRef?: {
            name: string;
            key?: string | null;
          } | null;
          nameserver: string;
          tsigKeyName?: string | null;
        } | null;
        webhook?: {
          config?: c.JSONValue | null;
          solverName: string;
          groupName: string;
        } | null;
      } | null;
      http01?: {
        ingress?: {
          name?: string | null;
          class?: string | null;
          ingressTemplate?: {
            metadata?: {
              labels?: Record<string,string> | null;
              annotations?: Record<string,string> | null;
            } | null;
          } | null;
          serviceType?: string | null;
          podTemplate?: {
            spec?: {
              tolerations?: Array<{
                tolerationSeconds?: number | null;
                value?: string | null;
                effect?: string | null;
                key?: string | null;
                operator?: string | null;
              }> | null;
              affinity?: {
                nodeAffinity?: {
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    nodeSelectorTerms: Array<{
                      matchExpressions?: Array<{
                        operator: string;
                        values?: Array<string> | null;
                        key: string;
                      }> | null;
                      matchFields?: Array<{
                        key: string;
                        values?: Array<string> | null;
                        operator: string;
                      }> | null;
                    }>;
                  } | null;
                  preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                    weight: number;
                    preference: {
                      matchFields?: Array<{
                        operator: string;
                        values?: Array<string> | null;
                        key: string;
                      }> | null;
                      matchExpressions?: Array<{
                        operator: string;
                        values?: Array<string> | null;
                        key: string;
                      }> | null;
                    };
                  }> | null;
                } | null;
                podAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                    podAffinityTerm: {
                      labelSelector?: {
                        matchLabels?: Record<string,string> | null;
                        matchExpressions?: Array<{
                          key: string;
                          values?: Array<string> | null;
                          operator: string;
                        }> | null;
                      } | null;
                      namespaces?: Array<string> | null;
                      topologyKey: string;
                    };
                    weight: number;
                  }> | null;
                  requiredDuringSchedulingIgnoredDuringExecution?: Array<{
                    labelSelector?: {
                      matchExpressions?: Array<{
                        key: string;
                        values?: Array<string> | null;
                        operator: string;
                      }> | null;
                      matchLabels?: Record<string,string> | null;
                    } | null;
                    namespaces?: Array<string> | null;
                    topologyKey: string;
                  }> | null;
                } | null;
                podAntiAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                    podAffinityTerm: {
                      labelSelector?: {
                        matchLabels?: Record<string,string> | null;
                        matchExpressions?: Array<{
                          operator: string;
                          values?: Array<string> | null;
                          key: string;
                        }> | null;
                      } | null;
                      namespaces?: Array<string> | null;
                      topologyKey: string;
                    };
                    weight: number;
                  }> | null;
                  requiredDuringSchedulingIgnoredDuringExecution?: Array<{
                    namespaces?: Array<string> | null;
                    labelSelector?: {
                      matchExpressions?: Array<{
                        values?: Array<string> | null;
                        operator: string;
                        key: string;
                      }> | null;
                      matchLabels?: Record<string,string> | null;
                    } | null;
                    topologyKey: string;
                  }> | null;
                } | null;
              } | null;
              nodeSelector?: Record<string,string> | null;
            } | null;
            metadata?: {
              annotations?: Record<string,string> | null;
              labels?: Record<string,string> | null;
            } | null;
          } | null;
        } | null;
      } | null;
      selector?: {
        dnsNames?: Array<string> | null;
        matchLabels?: Record<string,string> | null;
        dnsZones?: Array<string> | null;
      } | null;
    };
    key: string;
  } | null;
  status?: {
    presented?: boolean | null;
    processing?: boolean | null;
    state?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue | null;
    reason?: string | null;
  } | null;
  metadata: MetaV1.ObjectMeta;
}
export function toChallengeFields(input: c.JSONValue): ChallengeFields {
  const obj = c.checkObj(input);
  return {
    spec: c.readOpt(obj["spec"], toChallengeFields_spec),
    status: c.readOpt(obj["status"], toChallengeFields_status),
    metadata: MetaV1.toObjectMeta(obj["metadata"]),
  }}
export function toChallenge(input: c.JSONValue): Challenge {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "acme.cert-manager.io/v1alpha3") throw new Error("Type apiv mis 2");
  if (kind !== "Challenge") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toChallengeFields(fields),
  }}
export function fromChallenge(input: Challenge): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
  }}
export function toChallengeFields_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    issuerRef: toChallengeFields_spec_issuerRef(obj["issuerRef"]),
    url: c.checkStr(obj["url"]),
    type: (x => c.readEnum<"http-01" | "dns-01" | c.UnexpectedEnumValue>(x))(obj["type"]),
    wildcard: c.readOpt(obj["wildcard"], c.checkBool),
    authzURL: c.checkStr(obj["authzURL"]),
    dnsName: c.checkStr(obj["dnsName"]),
    token: c.checkStr(obj["token"]),
    solver: toChallengeFields_spec_solver(obj["solver"]),
    key: c.checkStr(obj["key"]),
  }}
export function toChallengeFields_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    presented: c.readOpt(obj["presented"], c.checkBool),
    processing: c.readOpt(obj["processing"], c.checkBool),
    state: c.readOpt(obj["state"], (x => c.readEnum<"valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue>(x))),
    reason: c.readOpt(obj["reason"], c.checkStr),
  }}
export function toChallengeFields_spec_issuerRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.checkStr(obj["name"]),
    group: c.readOpt(obj["group"], c.checkStr),
  }}
export function toChallengeFields_spec_solver(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    dns01: c.readOpt(obj["dns01"], toChallengeFields_spec_solver_dns01),
    http01: c.readOpt(obj["http01"], toChallengeFields_spec_solver_http01),
    selector: c.readOpt(obj["selector"], toChallengeFields_spec_solver_selector),
  }}
export function toChallengeFields_spec_solver_dns01(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    cnameStrategy: c.readOpt(obj["cnameStrategy"], (x => c.readEnum<"None" | "Follow" | c.UnexpectedEnumValue>(x))),
    akamai: c.readOpt(obj["akamai"], toChallengeFields_spec_solver_dns01_akamai),
    clouddns: c.readOpt(obj["clouddns"], toChallengeFields_spec_solver_dns01_clouddns),
    azuredns: c.readOpt(obj["azuredns"], toChallengeFields_spec_solver_dns01_azuredns),
    cloudflare: c.readOpt(obj["cloudflare"], toChallengeFields_spec_solver_dns01_cloudflare),
    digitalocean: c.readOpt(obj["digitalocean"], toChallengeFields_spec_solver_dns01_digitalocean),
    route53: c.readOpt(obj["route53"], toChallengeFields_spec_solver_dns01_route53),
    acmedns: c.readOpt(obj["acmedns"], toChallengeFields_spec_solver_dns01_acmedns),
    rfc2136: c.readOpt(obj["rfc2136"], toChallengeFields_spec_solver_dns01_rfc2136),
    webhook: c.readOpt(obj["webhook"], toChallengeFields_spec_solver_dns01_webhook),
  }}
export function toChallengeFields_spec_solver_http01(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    ingress: c.readOpt(obj["ingress"], toChallengeFields_spec_solver_http01_ingress),
  }}
export function toChallengeFields_spec_solver_selector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    dnsNames: c.readOpt(obj["dnsNames"], x => c.readList(x, c.checkStr)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
    dnsZones: c.readOpt(obj["dnsZones"], x => c.readList(x, c.checkStr)),
  }}
export function toChallengeFields_spec_solver_dns01_akamai(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    clientSecretSecretRef: toChallengeFields_spec_solver_dns01_akamai_clientSecretSecretRef(obj["clientSecretSecretRef"]),
    serviceConsumerDomain: c.checkStr(obj["serviceConsumerDomain"]),
    clientTokenSecretRef: toChallengeFields_spec_solver_dns01_akamai_clientTokenSecretRef(obj["clientTokenSecretRef"]),
    accessTokenSecretRef: toChallengeFields_spec_solver_dns01_akamai_accessTokenSecretRef(obj["accessTokenSecretRef"]),
  }}
export function toChallengeFields_spec_solver_dns01_clouddns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    project: c.checkStr(obj["project"]),
    hostedZoneName: c.readOpt(obj["hostedZoneName"], c.checkStr),
    serviceAccountSecretRef: c.readOpt(obj["serviceAccountSecretRef"], toChallengeFields_spec_solver_dns01_clouddns_serviceAccountSecretRef),
  }}
export function toChallengeFields_spec_solver_dns01_azuredns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    clientID: c.readOpt(obj["clientID"], c.checkStr),
    subscriptionID: c.checkStr(obj["subscriptionID"]),
    tenantID: c.readOpt(obj["tenantID"], c.checkStr),
    clientSecretSecretRef: c.readOpt(obj["clientSecretSecretRef"], toChallengeFields_spec_solver_dns01_azuredns_clientSecretSecretRef),
    resourceGroupName: c.checkStr(obj["resourceGroupName"]),
    environment: c.readOpt(obj["environment"], (x => c.readEnum<"AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud" | c.UnexpectedEnumValue>(x))),
    hostedZoneName: c.readOpt(obj["hostedZoneName"], c.checkStr),
  }}
export function toChallengeFields_spec_solver_dns01_cloudflare(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    email: c.readOpt(obj["email"], c.checkStr),
    apiTokenSecretRef: c.readOpt(obj["apiTokenSecretRef"], toChallengeFields_spec_solver_dns01_cloudflare_apiTokenSecretRef),
    apiKeySecretRef: c.readOpt(obj["apiKeySecretRef"], toChallengeFields_spec_solver_dns01_cloudflare_apiKeySecretRef),
  }}
export function toChallengeFields_spec_solver_dns01_digitalocean(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    tokenSecretRef: toChallengeFields_spec_solver_dns01_digitalocean_tokenSecretRef(obj["tokenSecretRef"]),
  }}
export function toChallengeFields_spec_solver_dns01_route53(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    hostedZoneID: c.readOpt(obj["hostedZoneID"], c.checkStr),
    region: c.checkStr(obj["region"]),
    accessKeyID: c.readOpt(obj["accessKeyID"], c.checkStr),
    role: c.readOpt(obj["role"], c.checkStr),
    secretAccessKeySecretRef: c.readOpt(obj["secretAccessKeySecretRef"], toChallengeFields_spec_solver_dns01_route53_secretAccessKeySecretRef),
  }}
export function toChallengeFields_spec_solver_dns01_acmedns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accountSecretRef: toChallengeFields_spec_solver_dns01_acmedns_accountSecretRef(obj["accountSecretRef"]),
    host: c.checkStr(obj["host"]),
  }}
export function toChallengeFields_spec_solver_dns01_rfc2136(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    tsigAlgorithm: c.readOpt(obj["tsigAlgorithm"], c.checkStr),
    tsigSecretSecretRef: c.readOpt(obj["tsigSecretSecretRef"], toChallengeFields_spec_solver_dns01_rfc2136_tsigSecretSecretRef),
    nameserver: c.checkStr(obj["nameserver"]),
    tsigKeyName: c.readOpt(obj["tsigKeyName"], c.checkStr),
  }}
export function toChallengeFields_spec_solver_dns01_webhook(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    config: c.readOpt(obj["config"], c.identity),
    solverName: c.checkStr(obj["solverName"]),
    groupName: c.checkStr(obj["groupName"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.readOpt(obj["name"], c.checkStr),
    class: c.readOpt(obj["class"], c.checkStr),
    ingressTemplate: c.readOpt(obj["ingressTemplate"], toChallengeFields_spec_solver_http01_ingress_ingressTemplate),
    serviceType: c.readOpt(obj["serviceType"], c.checkStr),
    podTemplate: c.readOpt(obj["podTemplate"], toChallengeFields_spec_solver_http01_ingress_podTemplate),
  }}
export function toChallengeFields_spec_solver_dns01_akamai_clientSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    key: c.readOpt(obj["key"], c.checkStr),
  }}
export function toChallengeFields_spec_solver_dns01_akamai_clientTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallengeFields_spec_solver_dns01_akamai_accessTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    key: c.readOpt(obj["key"], c.checkStr),
  }}
export function toChallengeFields_spec_solver_dns01_clouddns_serviceAccountSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    key: c.readOpt(obj["key"], c.checkStr),
  }}
export function toChallengeFields_spec_solver_dns01_azuredns_clientSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    key: c.readOpt(obj["key"], c.checkStr),
  }}
export function toChallengeFields_spec_solver_dns01_cloudflare_apiTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallengeFields_spec_solver_dns01_cloudflare_apiKeySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    key: c.readOpt(obj["key"], c.checkStr),
  }}
export function toChallengeFields_spec_solver_dns01_digitalocean_tokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    key: c.readOpt(obj["key"], c.checkStr),
  }}
export function toChallengeFields_spec_solver_dns01_route53_secretAccessKeySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallengeFields_spec_solver_dns01_acmedns_accountSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallengeFields_spec_solver_dns01_rfc2136_tsigSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    key: c.readOpt(obj["key"], c.checkStr),
  }}
export function toChallengeFields_spec_solver_http01_ingress_ingressTemplate(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], toChallengeFields_spec_solver_http01_ingress_ingressTemplate_metadata),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    spec: c.readOpt(obj["spec"], toChallengeFields_spec_solver_http01_ingress_podTemplate_spec),
    metadata: c.readOpt(obj["metadata"], toChallengeFields_spec_solver_http01_ingress_podTemplate_metadata),
  }}
export function toChallengeFields_spec_solver_http01_ingress_ingressTemplate_metadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    tolerations: c.readOpt(obj["tolerations"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_tolerations)),
    affinity: c.readOpt(obj["affinity"], toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity),
    nodeSelector: c.readOpt(obj["nodeSelector"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_metadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_tolerations(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    tolerationSeconds: c.readOpt(obj["tolerationSeconds"], c.checkNum),
    value: c.readOpt(obj["value"], c.checkStr),
    effect: c.readOpt(obj["effect"], c.checkStr),
    key: c.readOpt(obj["key"], c.checkStr),
    operator: c.readOpt(obj["operator"], c.checkStr),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nodeAffinity: c.readOpt(obj["nodeAffinity"], toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity),
    podAffinity: c.readOpt(obj["podAffinity"], toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity),
    podAntiAffinity: c.readOpt(obj["podAntiAffinity"], toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution),
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nodeSelectorTerms: c.readList(obj["nodeSelectorTerms"], toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    weight: c.checkNum(obj["weight"]),
    preference: toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference(obj["preference"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    podAffinityTerm: toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(obj["podAffinityTerm"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    podAffinityTerm: toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(obj["podAffinityTerm"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    labelSelector: c.readOpt(obj["labelSelector"], toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchExpressions)),
    matchFields: c.readOpt(obj["matchFields"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchFields)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchFields: c.readOpt(obj["matchFields"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchFields)),
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchExpressions)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
    key: c.checkStr(obj["key"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchFields(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
    operator: c.checkStr(obj["operator"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchFields(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
    key: c.checkStr(obj["key"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
    key: c.checkStr(obj["key"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
    operator: c.checkStr(obj["operator"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions)),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
    operator: c.checkStr(obj["operator"]),
    key: c.checkStr(obj["key"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
    operator: c.checkStr(obj["operator"]),
  }}
export function toChallengeFields_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
    key: c.checkStr(obj["key"]),
  }}

/** Order is a type to represent an Order with an ACME server */
export type Order = Kind<"Order"> & OrderFields;
export interface OrderFields {
  spec?: {
    csr: string;
    commonName?: string | null;
    issuerRef: {
      name: string;
      group?: string | null;
      kind?: string | null;
    };
    dnsNames: Array<string>;
  } | null;
  metadata: MetaV1.ObjectMeta;
  status?: {
    reason?: string | null;
    state?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue | null;
    authorizations?: Array<{
      wildcard?: boolean | null;
      identifier?: string | null;
      challenges?: Array<{
        token: string;
        url: string;
        type: string;
      }> | null;
      url: string;
      initialState?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue | null;
    }> | null;
    url?: string | null;
    failureTime?: c.Time | null;
    certificate?: string | null;
    finalizeURL?: string | null;
  } | null;
}
export function toOrderFields(input: c.JSONValue): OrderFields {
  const obj = c.checkObj(input);
  return {
    spec: c.readOpt(obj["spec"], toOrderFields_spec),
    metadata: MetaV1.toObjectMeta(obj["metadata"]),
    status: c.readOpt(obj["status"], toOrderFields_status),
  }}
export function toOrder(input: c.JSONValue): Order {
  const {apiVersion, kind, ...fields} = c.checkObj(input);
  if (apiVersion !== "acme.cert-manager.io/v1alpha3") throw new Error("Type apiv mis 2");
  if (kind !== "Order") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    ...toOrderFields(fields),
  }}
export function fromOrder(input: Order): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    status: input.status != null ? {
      ...input.status,
      failureTime: input.status.failureTime != null ? c.fromTime(input.status.failureTime) : undefined,
    } : undefined,
  }}
export function toOrderFields_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    csr: c.checkStr(obj["csr"]),
    commonName: c.readOpt(obj["commonName"], c.checkStr),
    issuerRef: toOrderFields_spec_issuerRef(obj["issuerRef"]),
    dnsNames: c.readList(obj["dnsNames"], c.checkStr),
  }}
export function toOrderFields_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    reason: c.readOpt(obj["reason"], c.checkStr),
    state: c.readOpt(obj["state"], (x => c.readEnum<"valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue>(x))),
    authorizations: c.readOpt(obj["authorizations"], x => c.readList(x, toOrderFields_status_authorizations)),
    url: c.readOpt(obj["url"], c.checkStr),
    failureTime: c.readOpt(obj["failureTime"], c.toTime),
    certificate: c.readOpt(obj["certificate"], c.checkStr),
    finalizeURL: c.readOpt(obj["finalizeURL"], c.checkStr),
  }}
export function toOrderFields_spec_issuerRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
  }}
export function toOrderFields_status_authorizations(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    wildcard: c.readOpt(obj["wildcard"], c.checkBool),
    identifier: c.readOpt(obj["identifier"], c.checkStr),
    challenges: c.readOpt(obj["challenges"], x => c.readList(x, toOrderFields_status_authorizations_challenges)),
    url: c.checkStr(obj["url"]),
    initialState: c.readOpt(obj["initialState"], (x => c.readEnum<"valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue>(x))),
  }}
export function toOrderFields_status_authorizations_challenges(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    token: c.checkStr(obj["token"]),
    url: c.checkStr(obj["url"]),
    type: c.checkStr(obj["type"]),
  }}

/** OrderList is a list of Order */
export type OrderList = Kind<"OrderList"> & ListOf<OrderFields>;
export function toOrderList(input: c.JSONValue): OrderList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "acme.cert-manager.io/v1alpha3") throw new Error("Type apiv mis 2");
  if (kind !== "OrderList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toOrderFields),
  }}

/** ChallengeList is a list of Challenge */
export type ChallengeList = Kind<"ChallengeList"> & ListOf<ChallengeFields>;
export function toChallengeList(input: c.JSONValue): ChallengeList {
  const {apiVersion, kind, metadata, items} = c.checkObj(input);
  if (apiVersion !== "acme.cert-manager.io/v1alpha3") throw new Error("Type apiv mis 2");
  if (kind !== "ChallengeList") throw new Error("Type kind mis 2");
  return {
    apiVersion, kind,
    metadata: MetaV1.toListMeta(metadata),
    items: c.readList(items, toChallengeFields),
  }}
