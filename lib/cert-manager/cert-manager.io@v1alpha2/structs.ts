// Autogenerated Schema file for CertManagerIoV1alpha2
import * as c from "../../common.ts";

import * as MetaV1 from "../../builtin/meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** A CertificateRequest is used to request a signed certificate from one of the configured issuers. 
 All fields within the CertificateRequest's `spec` are immutable after creation. A CertificateRequest will either succeed or fail, as denoted by its `status.state` field. 
 A CertificateRequest is a 'one-shot' resource, meaning it represents a single point in time request for a certificate and cannot be re-used. */
export interface CertificateRequest {
  apiVersion?: "cert-manager.io/v1alpha2";
  kind?: "CertificateRequest";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: {
    csr: string;
    duration?: string | null;
    isCA?: boolean | null;
    issuerRef: {
      group?: string | null;
      kind?: string | null;
      name: string;
    };
    usages?: Array<"signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc" | c.UnexpectedEnumValue> | null;
  } | null;
  status?: {
    ca?: string | null;
    certificate?: string | null;
    conditions?: Array<{
      lastTransitionTime?: c.Time | null;
      message?: string | null;
      reason?: string | null;
      status: "True" | "False" | "Unknown" | c.UnexpectedEnumValue;
      type: string;
    }> | null;
    failureTime?: c.Time | null;
  } | null;
}
export function toCertificateRequest(input: c.JSONValue): CertificateRequest & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha2", "CertificateRequest"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toCertificateRequest_spec),
    status: c.readOpt(obj["status"], toCertificateRequest_status),
  }}
export function fromCertificateRequest(input: CertificateRequest): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "cert-manager.io/v1alpha2", "CertificateRequest"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    status: input.status != null ? {
      ...input.status,
      conditions: input.status.conditions?.map(x => ({
        ...x,
        lastTransitionTime: x.lastTransitionTime != null ? c.fromTime(x.lastTransitionTime) : undefined,
      })),
      failureTime: input.status.failureTime != null ? c.fromTime(input.status.failureTime) : undefined,
    } : undefined,
  }}
export function toCertificateRequest_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    csr: c.checkStr(obj["csr"]),
    duration: c.readOpt(obj["duration"], c.checkStr),
    isCA: c.readOpt(obj["isCA"], c.checkBool),
    issuerRef: toCertificateRequest_spec_issuerRef(obj["issuerRef"]),
    usages: c.readOpt(obj["usages"], x => c.readList(x, (x => c.readEnum<"signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc" | c.UnexpectedEnumValue>(x)))),
  }}
export function toCertificateRequest_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    ca: c.readOpt(obj["ca"], c.checkStr),
    certificate: c.readOpt(obj["certificate"], c.checkStr),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toCertificateRequest_status_conditions)),
    failureTime: c.readOpt(obj["failureTime"], c.toTime),
  }}
export function toCertificateRequest_spec_issuerRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toCertificateRequest_status_conditions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: (x => c.readEnum<"True" | "False" | "Unknown" | c.UnexpectedEnumValue>(x))(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}

export interface CertificateRequestList extends ListOf<CertificateRequest> {
  apiVersion?: "cert-manager.io/v1alpha2";
  kind?: "CertificateRequestList";
};
export function toCertificateRequestList(input: c.JSONValue): CertificateRequestList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha2", "CertificateRequestList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toCertificateRequest),
  }}

/** A Certificate resource should be created to ensure an up to date and signed x509 certificate is stored in the Kubernetes Secret resource named in `spec.secretName`. 
 The stored certificate will be renewed before it expires (as configured by `spec.renewBefore`). */
export interface Certificate {
  apiVersion?: "cert-manager.io/v1alpha2";
  kind?: "Certificate";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: {
    commonName?: string | null;
    dnsNames?: Array<string> | null;
    duration?: string | null;
    emailSANs?: Array<string> | null;
    encodeUsagesInRequest?: boolean | null;
    ipAddresses?: Array<string> | null;
    isCA?: boolean | null;
    issuerRef: {
      group?: string | null;
      kind?: string | null;
      name: string;
    };
    keyAlgorithm?: "rsa" | "ecdsa" | c.UnexpectedEnumValue | null;
    keyEncoding?: "pkcs1" | "pkcs8" | c.UnexpectedEnumValue | null;
    keySize?: number | null;
    keystores?: {
      jks?: {
        create: boolean;
        passwordSecretRef: {
          key?: string | null;
          name: string;
        };
      } | null;
      pkcs12?: {
        create: boolean;
        passwordSecretRef: {
          key?: string | null;
          name: string;
        };
      } | null;
    } | null;
    organization?: Array<string> | null;
    privateKey?: {
      rotationPolicy?: string | null;
    } | null;
    renewBefore?: string | null;
    secretName: string;
    subject?: {
      countries?: Array<string> | null;
      localities?: Array<string> | null;
      organizationalUnits?: Array<string> | null;
      postalCodes?: Array<string> | null;
      provinces?: Array<string> | null;
      serialNumber?: string | null;
      streetAddresses?: Array<string> | null;
    } | null;
    uriSANs?: Array<string> | null;
    usages?: Array<"signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc" | c.UnexpectedEnumValue> | null;
  } | null;
  status?: {
    conditions?: Array<{
      lastTransitionTime?: c.Time | null;
      message?: string | null;
      reason?: string | null;
      status: "True" | "False" | "Unknown" | c.UnexpectedEnumValue;
      type: string;
    }> | null;
    lastFailureTime?: c.Time | null;
    nextPrivateKeySecretName?: string | null;
    notAfter?: c.Time | null;
    notBefore?: c.Time | null;
    renewalTime?: c.Time | null;
    revision?: number | null;
  } | null;
}
export function toCertificate(input: c.JSONValue): Certificate & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha2", "Certificate"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toCertificate_spec),
    status: c.readOpt(obj["status"], toCertificate_status),
  }}
export function fromCertificate(input: Certificate): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "cert-manager.io/v1alpha2", "Certificate"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    status: input.status != null ? {
      ...input.status,
      conditions: input.status.conditions?.map(x => ({
        ...x,
        lastTransitionTime: x.lastTransitionTime != null ? c.fromTime(x.lastTransitionTime) : undefined,
      })),
      lastFailureTime: input.status.lastFailureTime != null ? c.fromTime(input.status.lastFailureTime) : undefined,
      notAfter: input.status.notAfter != null ? c.fromTime(input.status.notAfter) : undefined,
      notBefore: input.status.notBefore != null ? c.fromTime(input.status.notBefore) : undefined,
      renewalTime: input.status.renewalTime != null ? c.fromTime(input.status.renewalTime) : undefined,
    } : undefined,
  }}
export function toCertificate_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    commonName: c.readOpt(obj["commonName"], c.checkStr),
    dnsNames: c.readOpt(obj["dnsNames"], x => c.readList(x, c.checkStr)),
    duration: c.readOpt(obj["duration"], c.checkStr),
    emailSANs: c.readOpt(obj["emailSANs"], x => c.readList(x, c.checkStr)),
    encodeUsagesInRequest: c.readOpt(obj["encodeUsagesInRequest"], c.checkBool),
    ipAddresses: c.readOpt(obj["ipAddresses"], x => c.readList(x, c.checkStr)),
    isCA: c.readOpt(obj["isCA"], c.checkBool),
    issuerRef: toCertificate_spec_issuerRef(obj["issuerRef"]),
    keyAlgorithm: c.readOpt(obj["keyAlgorithm"], (x => c.readEnum<"rsa" | "ecdsa" | c.UnexpectedEnumValue>(x))),
    keyEncoding: c.readOpt(obj["keyEncoding"], (x => c.readEnum<"pkcs1" | "pkcs8" | c.UnexpectedEnumValue>(x))),
    keySize: c.readOpt(obj["keySize"], c.checkNum),
    keystores: c.readOpt(obj["keystores"], toCertificate_spec_keystores),
    organization: c.readOpt(obj["organization"], x => c.readList(x, c.checkStr)),
    privateKey: c.readOpt(obj["privateKey"], toCertificate_spec_privateKey),
    renewBefore: c.readOpt(obj["renewBefore"], c.checkStr),
    secretName: c.checkStr(obj["secretName"]),
    subject: c.readOpt(obj["subject"], toCertificate_spec_subject),
    uriSANs: c.readOpt(obj["uriSANs"], x => c.readList(x, c.checkStr)),
    usages: c.readOpt(obj["usages"], x => c.readList(x, (x => c.readEnum<"signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc" | c.UnexpectedEnumValue>(x)))),
  }}
export function toCertificate_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toCertificate_status_conditions)),
    lastFailureTime: c.readOpt(obj["lastFailureTime"], c.toTime),
    nextPrivateKeySecretName: c.readOpt(obj["nextPrivateKeySecretName"], c.checkStr),
    notAfter: c.readOpt(obj["notAfter"], c.toTime),
    notBefore: c.readOpt(obj["notBefore"], c.toTime),
    renewalTime: c.readOpt(obj["renewalTime"], c.toTime),
    revision: c.readOpt(obj["revision"], c.checkNum),
  }}
export function toCertificate_spec_issuerRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toCertificate_spec_keystores(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    jks: c.readOpt(obj["jks"], toCertificate_spec_keystores_jks),
    pkcs12: c.readOpt(obj["pkcs12"], toCertificate_spec_keystores_pkcs12),
  }}
export function toCertificate_spec_privateKey(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    rotationPolicy: c.readOpt(obj["rotationPolicy"], c.checkStr),
  }}
export function toCertificate_spec_subject(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    countries: c.readOpt(obj["countries"], x => c.readList(x, c.checkStr)),
    localities: c.readOpt(obj["localities"], x => c.readList(x, c.checkStr)),
    organizationalUnits: c.readOpt(obj["organizationalUnits"], x => c.readList(x, c.checkStr)),
    postalCodes: c.readOpt(obj["postalCodes"], x => c.readList(x, c.checkStr)),
    provinces: c.readOpt(obj["provinces"], x => c.readList(x, c.checkStr)),
    serialNumber: c.readOpt(obj["serialNumber"], c.checkStr),
    streetAddresses: c.readOpt(obj["streetAddresses"], x => c.readList(x, c.checkStr)),
  }}
export function toCertificate_status_conditions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: (x => c.readEnum<"True" | "False" | "Unknown" | c.UnexpectedEnumValue>(x))(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function toCertificate_spec_keystores_jks(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    create: c.checkBool(obj["create"]),
    passwordSecretRef: toCertificate_spec_keystores_jks_passwordSecretRef(obj["passwordSecretRef"]),
  }}
export function toCertificate_spec_keystores_pkcs12(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    create: c.checkBool(obj["create"]),
    passwordSecretRef: toCertificate_spec_keystores_pkcs12_passwordSecretRef(obj["passwordSecretRef"]),
  }}
export function toCertificate_spec_keystores_jks_passwordSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toCertificate_spec_keystores_pkcs12_passwordSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}

export interface CertificateList extends ListOf<Certificate> {
  apiVersion?: "cert-manager.io/v1alpha2";
  kind?: "CertificateList";
};
export function toCertificateList(input: c.JSONValue): CertificateList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha2", "CertificateList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toCertificate),
  }}

/** A ClusterIssuer represents a certificate issuing authority which can be referenced as part of `issuerRef` fields. It is similar to an Issuer, however it is cluster-scoped and therefore can be referenced by resources that exist in *any* namespace, not just the same namespace as the referent. */
export interface ClusterIssuer {
  apiVersion?: "cert-manager.io/v1alpha2";
  kind?: "ClusterIssuer";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: {
    acme?: {
      disableAccountKeyGeneration?: boolean | null;
      email?: string | null;
      enableDurationFeature?: boolean | null;
      externalAccountBinding?: {
        keyAlgorithm: "HS256" | "HS384" | "HS512" | c.UnexpectedEnumValue;
        keyID: string;
        keySecretRef: {
          key?: string | null;
          name: string;
        };
      } | null;
      preferredChain?: string | null;
      privateKeySecretRef: {
        key?: string | null;
        name: string;
      };
      server: string;
      skipTLSVerify?: boolean | null;
      solvers?: Array<{
        dns01?: {
          acmedns?: {
            accountSecretRef: {
              key?: string | null;
              name: string;
            };
            host: string;
          } | null;
          akamai?: {
            accessTokenSecretRef: {
              key?: string | null;
              name: string;
            };
            clientSecretSecretRef: {
              key?: string | null;
              name: string;
            };
            clientTokenSecretRef: {
              key?: string | null;
              name: string;
            };
            serviceConsumerDomain: string;
          } | null;
          azuredns?: {
            clientID?: string | null;
            clientSecretSecretRef?: {
              key?: string | null;
              name: string;
            } | null;
            environment?: "AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud" | c.UnexpectedEnumValue | null;
            hostedZoneName?: string | null;
            resourceGroupName: string;
            subscriptionID: string;
            tenantID?: string | null;
          } | null;
          clouddns?: {
            hostedZoneName?: string | null;
            project: string;
            serviceAccountSecretRef?: {
              key?: string | null;
              name: string;
            } | null;
          } | null;
          cloudflare?: {
            apiKeySecretRef?: {
              key?: string | null;
              name: string;
            } | null;
            apiTokenSecretRef?: {
              key?: string | null;
              name: string;
            } | null;
            email?: string | null;
          } | null;
          cnameStrategy?: "None" | "Follow" | c.UnexpectedEnumValue | null;
          digitalocean?: {
            tokenSecretRef: {
              key?: string | null;
              name: string;
            };
          } | null;
          rfc2136?: {
            nameserver: string;
            tsigAlgorithm?: string | null;
            tsigKeyName?: string | null;
            tsigSecretSecretRef?: {
              key?: string | null;
              name: string;
            } | null;
          } | null;
          route53?: {
            accessKeyID?: string | null;
            hostedZoneID?: string | null;
            region: string;
            role?: string | null;
            secretAccessKeySecretRef?: {
              key?: string | null;
              name: string;
            } | null;
          } | null;
          webhook?: {
            config?: c.JSONValue | null;
            groupName: string;
            solverName: string;
          } | null;
        } | null;
        http01?: {
          ingress?: {
            class?: string | null;
            ingressTemplate?: {
              metadata?: {
                annotations?: Record<string,string> | null;
                labels?: Record<string,string> | null;
              } | null;
            } | null;
            name?: string | null;
            podTemplate?: {
              metadata?: {
                annotations?: Record<string,string> | null;
                labels?: Record<string,string> | null;
              } | null;
              spec?: {
                affinity?: {
                  nodeAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                      preference: {
                        matchExpressions?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                        matchFields?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                      };
                      weight: number;
                    }> | null;
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      nodeSelectorTerms: Array<{
                        matchExpressions?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                        matchFields?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                      }>;
                    } | null;
                  } | null;
                  podAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: Array<{
                            key: string;
                            operator: string;
                            values?: Array<string> | null;
                          }> | null;
                          matchLabels?: Record<string,string> | null;
                        } | null;
                        namespaces?: Array<string> | null;
                        topologyKey: string;
                      };
                      weight: number;
                    }> | null;
                    requiredDuringSchedulingIgnoredDuringExecution?: Array<{
                      labelSelector?: {
                        matchExpressions?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                        matchLabels?: Record<string,string> | null;
                      } | null;
                      namespaces?: Array<string> | null;
                      topologyKey: string;
                    }> | null;
                  } | null;
                  podAntiAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: Array<{
                            key: string;
                            operator: string;
                            values?: Array<string> | null;
                          }> | null;
                          matchLabels?: Record<string,string> | null;
                        } | null;
                        namespaces?: Array<string> | null;
                        topologyKey: string;
                      };
                      weight: number;
                    }> | null;
                    requiredDuringSchedulingIgnoredDuringExecution?: Array<{
                      labelSelector?: {
                        matchExpressions?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                        matchLabels?: Record<string,string> | null;
                      } | null;
                      namespaces?: Array<string> | null;
                      topologyKey: string;
                    }> | null;
                  } | null;
                } | null;
                nodeSelector?: Record<string,string> | null;
                priorityClassName?: string | null;
                serviceAccountName?: string | null;
                tolerations?: Array<{
                  effect?: string | null;
                  key?: string | null;
                  operator?: string | null;
                  tolerationSeconds?: number | null;
                  value?: string | null;
                }> | null;
              } | null;
            } | null;
            serviceType?: string | null;
          } | null;
        } | null;
        selector?: {
          dnsNames?: Array<string> | null;
          dnsZones?: Array<string> | null;
          matchLabels?: Record<string,string> | null;
        } | null;
      }> | null;
    } | null;
    ca?: {
      crlDistributionPoints?: Array<string> | null;
      secretName: string;
    } | null;
    selfSigned?: {
      crlDistributionPoints?: Array<string> | null;
    } | null;
    vault?: {
      auth: {
        appRole?: {
          path: string;
          roleId: string;
          secretRef: {
            key?: string | null;
            name: string;
          };
        } | null;
        kubernetes?: {
          mountPath?: string | null;
          role: string;
          secretRef: {
            key?: string | null;
            name: string;
          };
        } | null;
        tokenSecretRef?: {
          key?: string | null;
          name: string;
        } | null;
      };
      caBundle?: string | null;
      namespace?: string | null;
      path: string;
      server: string;
    } | null;
    venafi?: {
      cloud?: {
        apiTokenSecretRef: {
          key?: string | null;
          name: string;
        };
        url?: string | null;
      } | null;
      tpp?: {
        caBundle?: string | null;
        credentialsRef: {
          name: string;
        };
        url: string;
      } | null;
      zone: string;
    } | null;
  } | null;
  status?: {
    acme?: {
      lastRegisteredEmail?: string | null;
      uri?: string | null;
    } | null;
    conditions?: Array<{
      lastTransitionTime?: c.Time | null;
      message?: string | null;
      reason?: string | null;
      status: "True" | "False" | "Unknown" | c.UnexpectedEnumValue;
      type: string;
    }> | null;
  } | null;
}
export function toClusterIssuer(input: c.JSONValue): ClusterIssuer & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha2", "ClusterIssuer"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toClusterIssuer_spec),
    status: c.readOpt(obj["status"], toClusterIssuer_status),
  }}
export function fromClusterIssuer(input: ClusterIssuer): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "cert-manager.io/v1alpha2", "ClusterIssuer"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    status: input.status != null ? {
      ...input.status,
      conditions: input.status.conditions?.map(x => ({
        ...x,
        lastTransitionTime: x.lastTransitionTime != null ? c.fromTime(x.lastTransitionTime) : undefined,
      })),
    } : undefined,
  }}
export function toClusterIssuer_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    acme: c.readOpt(obj["acme"], toClusterIssuer_spec_acme),
    ca: c.readOpt(obj["ca"], toClusterIssuer_spec_ca),
    selfSigned: c.readOpt(obj["selfSigned"], toClusterIssuer_spec_selfSigned),
    vault: c.readOpt(obj["vault"], toClusterIssuer_spec_vault),
    venafi: c.readOpt(obj["venafi"], toClusterIssuer_spec_venafi),
  }}
export function toClusterIssuer_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    acme: c.readOpt(obj["acme"], toClusterIssuer_status_acme),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toClusterIssuer_status_conditions)),
  }}
export function toClusterIssuer_spec_acme(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    disableAccountKeyGeneration: c.readOpt(obj["disableAccountKeyGeneration"], c.checkBool),
    email: c.readOpt(obj["email"], c.checkStr),
    enableDurationFeature: c.readOpt(obj["enableDurationFeature"], c.checkBool),
    externalAccountBinding: c.readOpt(obj["externalAccountBinding"], toClusterIssuer_spec_acme_externalAccountBinding),
    preferredChain: c.readOpt(obj["preferredChain"], c.checkStr),
    privateKeySecretRef: toClusterIssuer_spec_acme_privateKeySecretRef(obj["privateKeySecretRef"]),
    server: c.checkStr(obj["server"]),
    skipTLSVerify: c.readOpt(obj["skipTLSVerify"], c.checkBool),
    solvers: c.readOpt(obj["solvers"], x => c.readList(x, toClusterIssuer_spec_acme_solvers)),
  }}
export function toClusterIssuer_spec_ca(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    crlDistributionPoints: c.readOpt(obj["crlDistributionPoints"], x => c.readList(x, c.checkStr)),
    secretName: c.checkStr(obj["secretName"]),
  }}
export function toClusterIssuer_spec_selfSigned(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    crlDistributionPoints: c.readOpt(obj["crlDistributionPoints"], x => c.readList(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_vault(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    auth: toClusterIssuer_spec_vault_auth(obj["auth"]),
    caBundle: c.readOpt(obj["caBundle"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    path: c.checkStr(obj["path"]),
    server: c.checkStr(obj["server"]),
  }}
export function toClusterIssuer_spec_venafi(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    cloud: c.readOpt(obj["cloud"], toClusterIssuer_spec_venafi_cloud),
    tpp: c.readOpt(obj["tpp"], toClusterIssuer_spec_venafi_tpp),
    zone: c.checkStr(obj["zone"]),
  }}
export function toClusterIssuer_status_acme(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastRegisteredEmail: c.readOpt(obj["lastRegisteredEmail"], c.checkStr),
    uri: c.readOpt(obj["uri"], c.checkStr),
  }}
export function toClusterIssuer_status_conditions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: (x => c.readEnum<"True" | "False" | "Unknown" | c.UnexpectedEnumValue>(x))(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function toClusterIssuer_spec_acme_externalAccountBinding(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    keyAlgorithm: (x => c.readEnum<"HS256" | "HS384" | "HS512" | c.UnexpectedEnumValue>(x))(obj["keyAlgorithm"]),
    keyID: c.checkStr(obj["keyID"]),
    keySecretRef: toClusterIssuer_spec_acme_externalAccountBinding_keySecretRef(obj["keySecretRef"]),
  }}
export function toClusterIssuer_spec_acme_privateKeySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    dns01: c.readOpt(obj["dns01"], toClusterIssuer_spec_acme_solvers_dns01),
    http01: c.readOpt(obj["http01"], toClusterIssuer_spec_acme_solvers_http01),
    selector: c.readOpt(obj["selector"], toClusterIssuer_spec_acme_solvers_selector),
  }}
export function toClusterIssuer_spec_vault_auth(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    appRole: c.readOpt(obj["appRole"], toClusterIssuer_spec_vault_auth_appRole),
    kubernetes: c.readOpt(obj["kubernetes"], toClusterIssuer_spec_vault_auth_kubernetes),
    tokenSecretRef: c.readOpt(obj["tokenSecretRef"], toClusterIssuer_spec_vault_auth_tokenSecretRef),
  }}
export function toClusterIssuer_spec_venafi_cloud(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    apiTokenSecretRef: toClusterIssuer_spec_venafi_cloud_apiTokenSecretRef(obj["apiTokenSecretRef"]),
    url: c.readOpt(obj["url"], c.checkStr),
  }}
export function toClusterIssuer_spec_venafi_tpp(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    caBundle: c.readOpt(obj["caBundle"], c.checkStr),
    credentialsRef: toClusterIssuer_spec_venafi_tpp_credentialsRef(obj["credentialsRef"]),
    url: c.checkStr(obj["url"]),
  }}
export function toClusterIssuer_spec_acme_externalAccountBinding_keySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    acmedns: c.readOpt(obj["acmedns"], toClusterIssuer_spec_acme_solvers_dns01_acmedns),
    akamai: c.readOpt(obj["akamai"], toClusterIssuer_spec_acme_solvers_dns01_akamai),
    azuredns: c.readOpt(obj["azuredns"], toClusterIssuer_spec_acme_solvers_dns01_azuredns),
    clouddns: c.readOpt(obj["clouddns"], toClusterIssuer_spec_acme_solvers_dns01_clouddns),
    cloudflare: c.readOpt(obj["cloudflare"], toClusterIssuer_spec_acme_solvers_dns01_cloudflare),
    cnameStrategy: c.readOpt(obj["cnameStrategy"], (x => c.readEnum<"None" | "Follow" | c.UnexpectedEnumValue>(x))),
    digitalocean: c.readOpt(obj["digitalocean"], toClusterIssuer_spec_acme_solvers_dns01_digitalocean),
    rfc2136: c.readOpt(obj["rfc2136"], toClusterIssuer_spec_acme_solvers_dns01_rfc2136),
    route53: c.readOpt(obj["route53"], toClusterIssuer_spec_acme_solvers_dns01_route53),
    webhook: c.readOpt(obj["webhook"], toClusterIssuer_spec_acme_solvers_dns01_webhook),
  }}
export function toClusterIssuer_spec_acme_solvers_http01(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    ingress: c.readOpt(obj["ingress"], toClusterIssuer_spec_acme_solvers_http01_ingress),
  }}
export function toClusterIssuer_spec_acme_solvers_selector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    dnsNames: c.readOpt(obj["dnsNames"], x => c.readList(x, c.checkStr)),
    dnsZones: c.readOpt(obj["dnsZones"], x => c.readList(x, c.checkStr)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_vault_auth_appRole(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    path: c.checkStr(obj["path"]),
    roleId: c.checkStr(obj["roleId"]),
    secretRef: toClusterIssuer_spec_vault_auth_appRole_secretRef(obj["secretRef"]),
  }}
export function toClusterIssuer_spec_vault_auth_kubernetes(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    mountPath: c.readOpt(obj["mountPath"], c.checkStr),
    role: c.checkStr(obj["role"]),
    secretRef: toClusterIssuer_spec_vault_auth_kubernetes_secretRef(obj["secretRef"]),
  }}
export function toClusterIssuer_spec_vault_auth_tokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_venafi_cloud_apiTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_venafi_tpp_credentialsRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_acmedns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accountSecretRef: toClusterIssuer_spec_acme_solvers_dns01_acmedns_accountSecretRef(obj["accountSecretRef"]),
    host: c.checkStr(obj["host"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_akamai(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accessTokenSecretRef: toClusterIssuer_spec_acme_solvers_dns01_akamai_accessTokenSecretRef(obj["accessTokenSecretRef"]),
    clientSecretSecretRef: toClusterIssuer_spec_acme_solvers_dns01_akamai_clientSecretSecretRef(obj["clientSecretSecretRef"]),
    clientTokenSecretRef: toClusterIssuer_spec_acme_solvers_dns01_akamai_clientTokenSecretRef(obj["clientTokenSecretRef"]),
    serviceConsumerDomain: c.checkStr(obj["serviceConsumerDomain"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_azuredns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    clientID: c.readOpt(obj["clientID"], c.checkStr),
    clientSecretSecretRef: c.readOpt(obj["clientSecretSecretRef"], toClusterIssuer_spec_acme_solvers_dns01_azuredns_clientSecretSecretRef),
    environment: c.readOpt(obj["environment"], (x => c.readEnum<"AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud" | c.UnexpectedEnumValue>(x))),
    hostedZoneName: c.readOpt(obj["hostedZoneName"], c.checkStr),
    resourceGroupName: c.checkStr(obj["resourceGroupName"]),
    subscriptionID: c.checkStr(obj["subscriptionID"]),
    tenantID: c.readOpt(obj["tenantID"], c.checkStr),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_clouddns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    hostedZoneName: c.readOpt(obj["hostedZoneName"], c.checkStr),
    project: c.checkStr(obj["project"]),
    serviceAccountSecretRef: c.readOpt(obj["serviceAccountSecretRef"], toClusterIssuer_spec_acme_solvers_dns01_clouddns_serviceAccountSecretRef),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_cloudflare(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    apiKeySecretRef: c.readOpt(obj["apiKeySecretRef"], toClusterIssuer_spec_acme_solvers_dns01_cloudflare_apiKeySecretRef),
    apiTokenSecretRef: c.readOpt(obj["apiTokenSecretRef"], toClusterIssuer_spec_acme_solvers_dns01_cloudflare_apiTokenSecretRef),
    email: c.readOpt(obj["email"], c.checkStr),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_digitalocean(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    tokenSecretRef: toClusterIssuer_spec_acme_solvers_dns01_digitalocean_tokenSecretRef(obj["tokenSecretRef"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_rfc2136(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nameserver: c.checkStr(obj["nameserver"]),
    tsigAlgorithm: c.readOpt(obj["tsigAlgorithm"], c.checkStr),
    tsigKeyName: c.readOpt(obj["tsigKeyName"], c.checkStr),
    tsigSecretSecretRef: c.readOpt(obj["tsigSecretSecretRef"], toClusterIssuer_spec_acme_solvers_dns01_rfc2136_tsigSecretSecretRef),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_route53(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accessKeyID: c.readOpt(obj["accessKeyID"], c.checkStr),
    hostedZoneID: c.readOpt(obj["hostedZoneID"], c.checkStr),
    region: c.checkStr(obj["region"]),
    role: c.readOpt(obj["role"], c.checkStr),
    secretAccessKeySecretRef: c.readOpt(obj["secretAccessKeySecretRef"], toClusterIssuer_spec_acme_solvers_dns01_route53_secretAccessKeySecretRef),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_webhook(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    config: c.readOpt(obj["config"], c.identity),
    groupName: c.checkStr(obj["groupName"]),
    solverName: c.checkStr(obj["solverName"]),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    class: c.readOpt(obj["class"], c.checkStr),
    ingressTemplate: c.readOpt(obj["ingressTemplate"], toClusterIssuer_spec_acme_solvers_http01_ingress_ingressTemplate),
    name: c.readOpt(obj["name"], c.checkStr),
    podTemplate: c.readOpt(obj["podTemplate"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate),
    serviceType: c.readOpt(obj["serviceType"], c.checkStr),
  }}
export function toClusterIssuer_spec_vault_auth_appRole_secretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_vault_auth_kubernetes_secretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_acmedns_accountSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_akamai_accessTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_akamai_clientSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_akamai_clientTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_azuredns_clientSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_clouddns_serviceAccountSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_cloudflare_apiKeySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_cloudflare_apiTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_digitalocean_tokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_rfc2136_tsigSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_dns01_route53_secretAccessKeySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_ingressTemplate(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], toClusterIssuer_spec_acme_solvers_http01_ingress_ingressTemplate_metadata),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_metadata),
    spec: c.readOpt(obj["spec"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_ingressTemplate_metadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_metadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    affinity: c.readOpt(obj["affinity"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity),
    nodeSelector: c.readOpt(obj["nodeSelector"], x => c.readMap(x, c.checkStr)),
    priorityClassName: c.readOpt(obj["priorityClassName"], c.checkStr),
    serviceAccountName: c.readOpt(obj["serviceAccountName"], c.checkStr),
    tolerations: c.readOpt(obj["tolerations"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_tolerations)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nodeAffinity: c.readOpt(obj["nodeAffinity"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity),
    podAffinity: c.readOpt(obj["podAffinity"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity),
    podAntiAffinity: c.readOpt(obj["podAntiAffinity"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_tolerations(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    effect: c.readOpt(obj["effect"], c.checkStr),
    key: c.readOpt(obj["key"], c.checkStr),
    operator: c.readOpt(obj["operator"], c.checkStr),
    tolerationSeconds: c.readOpt(obj["tolerationSeconds"], c.checkNum),
    value: c.readOpt(obj["value"], c.checkStr),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preference: toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference(obj["preference"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nodeSelectorTerms: c.readList(obj["nodeSelectorTerms"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    podAffinityTerm: toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(obj["podAffinityTerm"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    podAffinityTerm: toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(obj["podAffinityTerm"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchExpressions)),
    matchFields: c.readOpt(obj["matchFields"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchFields)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchExpressions)),
    matchFields: c.readOpt(obj["matchFields"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchFields)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchFields(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchFields(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toClusterIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}

export interface ClusterIssuerList extends ListOf<ClusterIssuer> {
  apiVersion?: "cert-manager.io/v1alpha2";
  kind?: "ClusterIssuerList";
};
export function toClusterIssuerList(input: c.JSONValue): ClusterIssuerList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha2", "ClusterIssuerList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toClusterIssuer),
  }}

/** An Issuer represents a certificate issuing authority which can be referenced as part of `issuerRef` fields. It is scoped to a single namespace and can therefore only be referenced by resources within the same namespace. */
export interface Issuer {
  apiVersion?: "cert-manager.io/v1alpha2";
  kind?: "Issuer";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: {
    acme?: {
      disableAccountKeyGeneration?: boolean | null;
      email?: string | null;
      enableDurationFeature?: boolean | null;
      externalAccountBinding?: {
        keyAlgorithm: "HS256" | "HS384" | "HS512" | c.UnexpectedEnumValue;
        keyID: string;
        keySecretRef: {
          key?: string | null;
          name: string;
        };
      } | null;
      preferredChain?: string | null;
      privateKeySecretRef: {
        key?: string | null;
        name: string;
      };
      server: string;
      skipTLSVerify?: boolean | null;
      solvers?: Array<{
        dns01?: {
          acmedns?: {
            accountSecretRef: {
              key?: string | null;
              name: string;
            };
            host: string;
          } | null;
          akamai?: {
            accessTokenSecretRef: {
              key?: string | null;
              name: string;
            };
            clientSecretSecretRef: {
              key?: string | null;
              name: string;
            };
            clientTokenSecretRef: {
              key?: string | null;
              name: string;
            };
            serviceConsumerDomain: string;
          } | null;
          azuredns?: {
            clientID?: string | null;
            clientSecretSecretRef?: {
              key?: string | null;
              name: string;
            } | null;
            environment?: "AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud" | c.UnexpectedEnumValue | null;
            hostedZoneName?: string | null;
            resourceGroupName: string;
            subscriptionID: string;
            tenantID?: string | null;
          } | null;
          clouddns?: {
            hostedZoneName?: string | null;
            project: string;
            serviceAccountSecretRef?: {
              key?: string | null;
              name: string;
            } | null;
          } | null;
          cloudflare?: {
            apiKeySecretRef?: {
              key?: string | null;
              name: string;
            } | null;
            apiTokenSecretRef?: {
              key?: string | null;
              name: string;
            } | null;
            email?: string | null;
          } | null;
          cnameStrategy?: "None" | "Follow" | c.UnexpectedEnumValue | null;
          digitalocean?: {
            tokenSecretRef: {
              key?: string | null;
              name: string;
            };
          } | null;
          rfc2136?: {
            nameserver: string;
            tsigAlgorithm?: string | null;
            tsigKeyName?: string | null;
            tsigSecretSecretRef?: {
              key?: string | null;
              name: string;
            } | null;
          } | null;
          route53?: {
            accessKeyID?: string | null;
            hostedZoneID?: string | null;
            region: string;
            role?: string | null;
            secretAccessKeySecretRef?: {
              key?: string | null;
              name: string;
            } | null;
          } | null;
          webhook?: {
            config?: c.JSONValue | null;
            groupName: string;
            solverName: string;
          } | null;
        } | null;
        http01?: {
          ingress?: {
            class?: string | null;
            ingressTemplate?: {
              metadata?: {
                annotations?: Record<string,string> | null;
                labels?: Record<string,string> | null;
              } | null;
            } | null;
            name?: string | null;
            podTemplate?: {
              metadata?: {
                annotations?: Record<string,string> | null;
                labels?: Record<string,string> | null;
              } | null;
              spec?: {
                affinity?: {
                  nodeAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                      preference: {
                        matchExpressions?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                        matchFields?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                      };
                      weight: number;
                    }> | null;
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      nodeSelectorTerms: Array<{
                        matchExpressions?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                        matchFields?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                      }>;
                    } | null;
                  } | null;
                  podAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: Array<{
                            key: string;
                            operator: string;
                            values?: Array<string> | null;
                          }> | null;
                          matchLabels?: Record<string,string> | null;
                        } | null;
                        namespaces?: Array<string> | null;
                        topologyKey: string;
                      };
                      weight: number;
                    }> | null;
                    requiredDuringSchedulingIgnoredDuringExecution?: Array<{
                      labelSelector?: {
                        matchExpressions?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                        matchLabels?: Record<string,string> | null;
                      } | null;
                      namespaces?: Array<string> | null;
                      topologyKey: string;
                    }> | null;
                  } | null;
                  podAntiAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: Array<{
                            key: string;
                            operator: string;
                            values?: Array<string> | null;
                          }> | null;
                          matchLabels?: Record<string,string> | null;
                        } | null;
                        namespaces?: Array<string> | null;
                        topologyKey: string;
                      };
                      weight: number;
                    }> | null;
                    requiredDuringSchedulingIgnoredDuringExecution?: Array<{
                      labelSelector?: {
                        matchExpressions?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                        matchLabels?: Record<string,string> | null;
                      } | null;
                      namespaces?: Array<string> | null;
                      topologyKey: string;
                    }> | null;
                  } | null;
                } | null;
                nodeSelector?: Record<string,string> | null;
                priorityClassName?: string | null;
                serviceAccountName?: string | null;
                tolerations?: Array<{
                  effect?: string | null;
                  key?: string | null;
                  operator?: string | null;
                  tolerationSeconds?: number | null;
                  value?: string | null;
                }> | null;
              } | null;
            } | null;
            serviceType?: string | null;
          } | null;
        } | null;
        selector?: {
          dnsNames?: Array<string> | null;
          dnsZones?: Array<string> | null;
          matchLabels?: Record<string,string> | null;
        } | null;
      }> | null;
    } | null;
    ca?: {
      crlDistributionPoints?: Array<string> | null;
      secretName: string;
    } | null;
    selfSigned?: {
      crlDistributionPoints?: Array<string> | null;
    } | null;
    vault?: {
      auth: {
        appRole?: {
          path: string;
          roleId: string;
          secretRef: {
            key?: string | null;
            name: string;
          };
        } | null;
        kubernetes?: {
          mountPath?: string | null;
          role: string;
          secretRef: {
            key?: string | null;
            name: string;
          };
        } | null;
        tokenSecretRef?: {
          key?: string | null;
          name: string;
        } | null;
      };
      caBundle?: string | null;
      namespace?: string | null;
      path: string;
      server: string;
    } | null;
    venafi?: {
      cloud?: {
        apiTokenSecretRef: {
          key?: string | null;
          name: string;
        };
        url?: string | null;
      } | null;
      tpp?: {
        caBundle?: string | null;
        credentialsRef: {
          name: string;
        };
        url: string;
      } | null;
      zone: string;
    } | null;
  } | null;
  status?: {
    acme?: {
      lastRegisteredEmail?: string | null;
      uri?: string | null;
    } | null;
    conditions?: Array<{
      lastTransitionTime?: c.Time | null;
      message?: string | null;
      reason?: string | null;
      status: "True" | "False" | "Unknown" | c.UnexpectedEnumValue;
      type: string;
    }> | null;
  } | null;
}
export function toIssuer(input: c.JSONValue): Issuer & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha2", "Issuer"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toIssuer_spec),
    status: c.readOpt(obj["status"], toIssuer_status),
  }}
export function fromIssuer(input: Issuer): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "cert-manager.io/v1alpha2", "Issuer"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    status: input.status != null ? {
      ...input.status,
      conditions: input.status.conditions?.map(x => ({
        ...x,
        lastTransitionTime: x.lastTransitionTime != null ? c.fromTime(x.lastTransitionTime) : undefined,
      })),
    } : undefined,
  }}
export function toIssuer_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    acme: c.readOpt(obj["acme"], toIssuer_spec_acme),
    ca: c.readOpt(obj["ca"], toIssuer_spec_ca),
    selfSigned: c.readOpt(obj["selfSigned"], toIssuer_spec_selfSigned),
    vault: c.readOpt(obj["vault"], toIssuer_spec_vault),
    venafi: c.readOpt(obj["venafi"], toIssuer_spec_venafi),
  }}
export function toIssuer_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    acme: c.readOpt(obj["acme"], toIssuer_status_acme),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toIssuer_status_conditions)),
  }}
export function toIssuer_spec_acme(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    disableAccountKeyGeneration: c.readOpt(obj["disableAccountKeyGeneration"], c.checkBool),
    email: c.readOpt(obj["email"], c.checkStr),
    enableDurationFeature: c.readOpt(obj["enableDurationFeature"], c.checkBool),
    externalAccountBinding: c.readOpt(obj["externalAccountBinding"], toIssuer_spec_acme_externalAccountBinding),
    preferredChain: c.readOpt(obj["preferredChain"], c.checkStr),
    privateKeySecretRef: toIssuer_spec_acme_privateKeySecretRef(obj["privateKeySecretRef"]),
    server: c.checkStr(obj["server"]),
    skipTLSVerify: c.readOpt(obj["skipTLSVerify"], c.checkBool),
    solvers: c.readOpt(obj["solvers"], x => c.readList(x, toIssuer_spec_acme_solvers)),
  }}
export function toIssuer_spec_ca(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    crlDistributionPoints: c.readOpt(obj["crlDistributionPoints"], x => c.readList(x, c.checkStr)),
    secretName: c.checkStr(obj["secretName"]),
  }}
export function toIssuer_spec_selfSigned(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    crlDistributionPoints: c.readOpt(obj["crlDistributionPoints"], x => c.readList(x, c.checkStr)),
  }}
export function toIssuer_spec_vault(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    auth: toIssuer_spec_vault_auth(obj["auth"]),
    caBundle: c.readOpt(obj["caBundle"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    path: c.checkStr(obj["path"]),
    server: c.checkStr(obj["server"]),
  }}
export function toIssuer_spec_venafi(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    cloud: c.readOpt(obj["cloud"], toIssuer_spec_venafi_cloud),
    tpp: c.readOpt(obj["tpp"], toIssuer_spec_venafi_tpp),
    zone: c.checkStr(obj["zone"]),
  }}
export function toIssuer_status_acme(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastRegisteredEmail: c.readOpt(obj["lastRegisteredEmail"], c.checkStr),
    uri: c.readOpt(obj["uri"], c.checkStr),
  }}
export function toIssuer_status_conditions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: (x => c.readEnum<"True" | "False" | "Unknown" | c.UnexpectedEnumValue>(x))(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function toIssuer_spec_acme_externalAccountBinding(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    keyAlgorithm: (x => c.readEnum<"HS256" | "HS384" | "HS512" | c.UnexpectedEnumValue>(x))(obj["keyAlgorithm"]),
    keyID: c.checkStr(obj["keyID"]),
    keySecretRef: toIssuer_spec_acme_externalAccountBinding_keySecretRef(obj["keySecretRef"]),
  }}
export function toIssuer_spec_acme_privateKeySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    dns01: c.readOpt(obj["dns01"], toIssuer_spec_acme_solvers_dns01),
    http01: c.readOpt(obj["http01"], toIssuer_spec_acme_solvers_http01),
    selector: c.readOpt(obj["selector"], toIssuer_spec_acme_solvers_selector),
  }}
export function toIssuer_spec_vault_auth(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    appRole: c.readOpt(obj["appRole"], toIssuer_spec_vault_auth_appRole),
    kubernetes: c.readOpt(obj["kubernetes"], toIssuer_spec_vault_auth_kubernetes),
    tokenSecretRef: c.readOpt(obj["tokenSecretRef"], toIssuer_spec_vault_auth_tokenSecretRef),
  }}
export function toIssuer_spec_venafi_cloud(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    apiTokenSecretRef: toIssuer_spec_venafi_cloud_apiTokenSecretRef(obj["apiTokenSecretRef"]),
    url: c.readOpt(obj["url"], c.checkStr),
  }}
export function toIssuer_spec_venafi_tpp(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    caBundle: c.readOpt(obj["caBundle"], c.checkStr),
    credentialsRef: toIssuer_spec_venafi_tpp_credentialsRef(obj["credentialsRef"]),
    url: c.checkStr(obj["url"]),
  }}
export function toIssuer_spec_acme_externalAccountBinding_keySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    acmedns: c.readOpt(obj["acmedns"], toIssuer_spec_acme_solvers_dns01_acmedns),
    akamai: c.readOpt(obj["akamai"], toIssuer_spec_acme_solvers_dns01_akamai),
    azuredns: c.readOpt(obj["azuredns"], toIssuer_spec_acme_solvers_dns01_azuredns),
    clouddns: c.readOpt(obj["clouddns"], toIssuer_spec_acme_solvers_dns01_clouddns),
    cloudflare: c.readOpt(obj["cloudflare"], toIssuer_spec_acme_solvers_dns01_cloudflare),
    cnameStrategy: c.readOpt(obj["cnameStrategy"], (x => c.readEnum<"None" | "Follow" | c.UnexpectedEnumValue>(x))),
    digitalocean: c.readOpt(obj["digitalocean"], toIssuer_spec_acme_solvers_dns01_digitalocean),
    rfc2136: c.readOpt(obj["rfc2136"], toIssuer_spec_acme_solvers_dns01_rfc2136),
    route53: c.readOpt(obj["route53"], toIssuer_spec_acme_solvers_dns01_route53),
    webhook: c.readOpt(obj["webhook"], toIssuer_spec_acme_solvers_dns01_webhook),
  }}
export function toIssuer_spec_acme_solvers_http01(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    ingress: c.readOpt(obj["ingress"], toIssuer_spec_acme_solvers_http01_ingress),
  }}
export function toIssuer_spec_acme_solvers_selector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    dnsNames: c.readOpt(obj["dnsNames"], x => c.readList(x, c.checkStr)),
    dnsZones: c.readOpt(obj["dnsZones"], x => c.readList(x, c.checkStr)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toIssuer_spec_vault_auth_appRole(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    path: c.checkStr(obj["path"]),
    roleId: c.checkStr(obj["roleId"]),
    secretRef: toIssuer_spec_vault_auth_appRole_secretRef(obj["secretRef"]),
  }}
export function toIssuer_spec_vault_auth_kubernetes(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    mountPath: c.readOpt(obj["mountPath"], c.checkStr),
    role: c.checkStr(obj["role"]),
    secretRef: toIssuer_spec_vault_auth_kubernetes_secretRef(obj["secretRef"]),
  }}
export function toIssuer_spec_vault_auth_tokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_venafi_cloud_apiTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_venafi_tpp_credentialsRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_acmedns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accountSecretRef: toIssuer_spec_acme_solvers_dns01_acmedns_accountSecretRef(obj["accountSecretRef"]),
    host: c.checkStr(obj["host"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_akamai(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accessTokenSecretRef: toIssuer_spec_acme_solvers_dns01_akamai_accessTokenSecretRef(obj["accessTokenSecretRef"]),
    clientSecretSecretRef: toIssuer_spec_acme_solvers_dns01_akamai_clientSecretSecretRef(obj["clientSecretSecretRef"]),
    clientTokenSecretRef: toIssuer_spec_acme_solvers_dns01_akamai_clientTokenSecretRef(obj["clientTokenSecretRef"]),
    serviceConsumerDomain: c.checkStr(obj["serviceConsumerDomain"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_azuredns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    clientID: c.readOpt(obj["clientID"], c.checkStr),
    clientSecretSecretRef: c.readOpt(obj["clientSecretSecretRef"], toIssuer_spec_acme_solvers_dns01_azuredns_clientSecretSecretRef),
    environment: c.readOpt(obj["environment"], (x => c.readEnum<"AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud" | c.UnexpectedEnumValue>(x))),
    hostedZoneName: c.readOpt(obj["hostedZoneName"], c.checkStr),
    resourceGroupName: c.checkStr(obj["resourceGroupName"]),
    subscriptionID: c.checkStr(obj["subscriptionID"]),
    tenantID: c.readOpt(obj["tenantID"], c.checkStr),
  }}
export function toIssuer_spec_acme_solvers_dns01_clouddns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    hostedZoneName: c.readOpt(obj["hostedZoneName"], c.checkStr),
    project: c.checkStr(obj["project"]),
    serviceAccountSecretRef: c.readOpt(obj["serviceAccountSecretRef"], toIssuer_spec_acme_solvers_dns01_clouddns_serviceAccountSecretRef),
  }}
export function toIssuer_spec_acme_solvers_dns01_cloudflare(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    apiKeySecretRef: c.readOpt(obj["apiKeySecretRef"], toIssuer_spec_acme_solvers_dns01_cloudflare_apiKeySecretRef),
    apiTokenSecretRef: c.readOpt(obj["apiTokenSecretRef"], toIssuer_spec_acme_solvers_dns01_cloudflare_apiTokenSecretRef),
    email: c.readOpt(obj["email"], c.checkStr),
  }}
export function toIssuer_spec_acme_solvers_dns01_digitalocean(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    tokenSecretRef: toIssuer_spec_acme_solvers_dns01_digitalocean_tokenSecretRef(obj["tokenSecretRef"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_rfc2136(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nameserver: c.checkStr(obj["nameserver"]),
    tsigAlgorithm: c.readOpt(obj["tsigAlgorithm"], c.checkStr),
    tsigKeyName: c.readOpt(obj["tsigKeyName"], c.checkStr),
    tsigSecretSecretRef: c.readOpt(obj["tsigSecretSecretRef"], toIssuer_spec_acme_solvers_dns01_rfc2136_tsigSecretSecretRef),
  }}
export function toIssuer_spec_acme_solvers_dns01_route53(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accessKeyID: c.readOpt(obj["accessKeyID"], c.checkStr),
    hostedZoneID: c.readOpt(obj["hostedZoneID"], c.checkStr),
    region: c.checkStr(obj["region"]),
    role: c.readOpt(obj["role"], c.checkStr),
    secretAccessKeySecretRef: c.readOpt(obj["secretAccessKeySecretRef"], toIssuer_spec_acme_solvers_dns01_route53_secretAccessKeySecretRef),
  }}
export function toIssuer_spec_acme_solvers_dns01_webhook(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    config: c.readOpt(obj["config"], c.identity),
    groupName: c.checkStr(obj["groupName"]),
    solverName: c.checkStr(obj["solverName"]),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    class: c.readOpt(obj["class"], c.checkStr),
    ingressTemplate: c.readOpt(obj["ingressTemplate"], toIssuer_spec_acme_solvers_http01_ingress_ingressTemplate),
    name: c.readOpt(obj["name"], c.checkStr),
    podTemplate: c.readOpt(obj["podTemplate"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate),
    serviceType: c.readOpt(obj["serviceType"], c.checkStr),
  }}
export function toIssuer_spec_vault_auth_appRole_secretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_vault_auth_kubernetes_secretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_acmedns_accountSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_akamai_accessTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_akamai_clientSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_akamai_clientTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_azuredns_clientSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_clouddns_serviceAccountSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_cloudflare_apiKeySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_cloudflare_apiTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_digitalocean_tokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_rfc2136_tsigSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_dns01_route53_secretAccessKeySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_ingressTemplate(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], toIssuer_spec_acme_solvers_http01_ingress_ingressTemplate_metadata),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_metadata),
    spec: c.readOpt(obj["spec"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_ingressTemplate_metadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_metadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    affinity: c.readOpt(obj["affinity"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity),
    nodeSelector: c.readOpt(obj["nodeSelector"], x => c.readMap(x, c.checkStr)),
    priorityClassName: c.readOpt(obj["priorityClassName"], c.checkStr),
    serviceAccountName: c.readOpt(obj["serviceAccountName"], c.checkStr),
    tolerations: c.readOpt(obj["tolerations"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_tolerations)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nodeAffinity: c.readOpt(obj["nodeAffinity"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity),
    podAffinity: c.readOpt(obj["podAffinity"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity),
    podAntiAffinity: c.readOpt(obj["podAntiAffinity"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_tolerations(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    effect: c.readOpt(obj["effect"], c.checkStr),
    key: c.readOpt(obj["key"], c.checkStr),
    operator: c.readOpt(obj["operator"], c.checkStr),
    tolerationSeconds: c.readOpt(obj["tolerationSeconds"], c.checkNum),
    value: c.readOpt(obj["value"], c.checkStr),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preference: toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference(obj["preference"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nodeSelectorTerms: c.readList(obj["nodeSelectorTerms"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    podAffinityTerm: toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(obj["podAffinityTerm"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    podAffinityTerm: toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(obj["podAffinityTerm"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchExpressions)),
    matchFields: c.readOpt(obj["matchFields"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchFields)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchExpressions)),
    matchFields: c.readOpt(obj["matchFields"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchFields)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchFields(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchFields(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toIssuer_spec_acme_solvers_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}

export interface IssuerList extends ListOf<Issuer> {
  apiVersion?: "cert-manager.io/v1alpha2";
  kind?: "IssuerList";
};
export function toIssuerList(input: c.JSONValue): IssuerList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha2", "IssuerList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toIssuer),
  }}
