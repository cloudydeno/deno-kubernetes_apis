// Autogenerated Schema file for CertManagerIoV1alpha3
import * as c from "../../common.ts";

import * as CoreV1 from "../../builtin/core@v1/structs.ts";
import * as MetaV1 from "../../builtin/meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** A CertificateRequest is used to request a signed certificate from one of the configured issuers. 
 All fields within the CertificateRequest's `spec` are immutable after creation. A CertificateRequest will either succeed or fail, as denoted by its `status.state` field. 
 A CertificateRequest is a one-shot resource, meaning it represents a single point in time request for a certificate and cannot be re-used. */
export interface CertificateRequest {
  apiVersion?: "cert-manager.io/v1alpha3";
  kind?: "CertificateRequest";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: {
    csr: string;
    duration?: string | null;
    extra?: Record<string,Array<string>> | null;
    groups?: Array<string> | null;
    isCA?: boolean | null;
    issuerRef: {
      group?: string | null;
      kind?: string | null;
      name: string;
    };
    uid?: string | null;
    usages?: Array<"signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc" | c.UnexpectedEnumValue> | null;
    username?: string | null;
  } | null;
  status?: {
    ca?: string | null;
    certificate?: string | null;
    conditions?: Array<{
      lastTransitionTime?: c.Time | null;
      message?: string | null;
      reason?: string | null;
      status: "True" | "False" | "Unknown" | c.UnexpectedEnumValue;
      type: string;
    }> | null;
    failureTime?: c.Time | null;
  } | null;
}
export function toCertificateRequest(input: c.JSONValue): CertificateRequest & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha3", "CertificateRequest"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toCertificateRequest_spec),
    status: c.readOpt(obj["status"], toCertificateRequest_status),
  }}
export function fromCertificateRequest(input: CertificateRequest): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "cert-manager.io/v1alpha3", "CertificateRequest"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    status: input.status != null ? {
      ...input.status,
      conditions: input.status.conditions?.map(x => ({
        ...x,
        lastTransitionTime: x.lastTransitionTime != null ? c.fromTime(x.lastTransitionTime) : undefined,
      })),
      failureTime: input.status.failureTime != null ? c.fromTime(input.status.failureTime) : undefined,
    } : undefined,
  }}
export function toCertificateRequest_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    csr: c.checkStr(obj["csr"]),
    duration: c.readOpt(obj["duration"], c.checkStr),
    extra: c.readOpt(obj["extra"], y => c.readMap(y, x => c.readList(x, c.checkStr))),
    groups: c.readOpt(obj["groups"], x => c.readList(x, c.checkStr)),
    isCA: c.readOpt(obj["isCA"], c.checkBool),
    issuerRef: toCertificateRequest_spec_issuerRef(obj["issuerRef"]),
    uid: c.readOpt(obj["uid"], c.checkStr),
    usages: c.readOpt(obj["usages"], x => c.readList(x, (x => c.readEnum<"signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc" | c.UnexpectedEnumValue>(x)))),
    username: c.readOpt(obj["username"], c.checkStr),
  }}
export function toCertificateRequest_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    ca: c.readOpt(obj["ca"], c.checkStr),
    certificate: c.readOpt(obj["certificate"], c.checkStr),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toCertificateRequest_status_conditions)),
    failureTime: c.readOpt(obj["failureTime"], c.toTime),
  }}
export function toCertificateRequest_spec_issuerRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toCertificateRequest_status_conditions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: (x => c.readEnum<"True" | "False" | "Unknown" | c.UnexpectedEnumValue>(x))(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}

export interface CertificateRequestList extends ListOf<CertificateRequest> {
  apiVersion?: "cert-manager.io/v1alpha3";
  kind?: "CertificateRequestList";
};
export function toCertificateRequestList(input: c.JSONValue): CertificateRequestList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha3", "CertificateRequestList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toCertificateRequest),
  }}

/** A reference to a specific 'key' within a Secret resource. In some instances, `key` is a required field. */
export interface SecretRef {
  key?: string | null;
  name: string;
}
export function toSecretRef(input: c.JSONValue): SecretRef {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function fromSecretRef(input: SecretRef): c.JSONValue {
  return {
    ...input,
  }}

/** A Certificate resource should be created to ensure an up to date and signed x509 certificate is stored in the Kubernetes Secret resource named in `spec.secretName`. 
 The stored certificate will be renewed before it expires (as configured by `spec.renewBefore`). */
export interface Certificate {
  apiVersion?: "cert-manager.io/v1alpha3";
  kind?: "Certificate";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: {
    commonName?: string | null;
    dnsNames?: Array<string> | null;
    duration?: string | null;
    emailSANs?: Array<string> | null;
    encodeUsagesInRequest?: boolean | null;
    ipAddresses?: Array<string> | null;
    isCA?: boolean | null;
    issuerRef: {
      group?: string | null;
      kind?: string | null;
      name: string;
    };
    keyAlgorithm?: "rsa" | "ecdsa" | c.UnexpectedEnumValue | null;
    keyEncoding?: "pkcs1" | "pkcs8" | c.UnexpectedEnumValue | null;
    keySize?: number | null;
    keystores?: {
      jks?: {
        create: boolean;
        passwordSecretRef: SecretRef;
      } | null;
      pkcs12?: {
        create: boolean;
        passwordSecretRef: SecretRef;
      } | null;
    } | null;
    privateKey?: {
      rotationPolicy?: string | null;
    } | null;
    renewBefore?: string | null;
    revisionHistoryLimit?: number | null;
    secretName: string;
    secretTemplate?: {
      annotations?: Record<string,string> | null;
      labels?: Record<string,string> | null;
    } | null;
    subject?: {
      countries?: Array<string> | null;
      localities?: Array<string> | null;
      organizationalUnits?: Array<string> | null;
      organizations?: Array<string> | null;
      postalCodes?: Array<string> | null;
      provinces?: Array<string> | null;
      serialNumber?: string | null;
      streetAddresses?: Array<string> | null;
    } | null;
    uriSANs?: Array<string> | null;
    usages?: Array<"signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc" | c.UnexpectedEnumValue> | null;
  } | null;
  status?: {
    conditions?: Array<{
      lastTransitionTime?: c.Time | null;
      message?: string | null;
      observedGeneration?: number | null;
      reason?: string | null;
      status: "True" | "False" | "Unknown" | c.UnexpectedEnumValue;
      type: string;
    }> | null;
    lastFailureTime?: c.Time | null;
    nextPrivateKeySecretName?: string | null;
    notAfter?: c.Time | null;
    notBefore?: c.Time | null;
    renewalTime?: c.Time | null;
    revision?: number | null;
  } | null;
}
export function toCertificate(input: c.JSONValue): Certificate & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha3", "Certificate"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toCertificate_spec),
    status: c.readOpt(obj["status"], toCertificate_status),
  }}
export function fromCertificate(input: Certificate): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "cert-manager.io/v1alpha3", "Certificate"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? {
      ...input.spec,
      keystores: input.spec.keystores != null ? {
        ...input.spec.keystores,
        jks: input.spec.keystores.jks != null ? {
          ...input.spec.keystores.jks,
          passwordSecretRef: input.spec.keystores.jks.passwordSecretRef != null ? fromSecretRef(input.spec.keystores.jks.passwordSecretRef) : undefined,
        } : undefined,
        pkcs12: input.spec.keystores.pkcs12 != null ? {
          ...input.spec.keystores.pkcs12,
          passwordSecretRef: input.spec.keystores.pkcs12.passwordSecretRef != null ? fromSecretRef(input.spec.keystores.pkcs12.passwordSecretRef) : undefined,
        } : undefined,
      } : undefined,
    } : undefined,
    status: input.status != null ? {
      ...input.status,
      conditions: input.status.conditions?.map(x => ({
        ...x,
        lastTransitionTime: x.lastTransitionTime != null ? c.fromTime(x.lastTransitionTime) : undefined,
      })),
      lastFailureTime: input.status.lastFailureTime != null ? c.fromTime(input.status.lastFailureTime) : undefined,
      notAfter: input.status.notAfter != null ? c.fromTime(input.status.notAfter) : undefined,
      notBefore: input.status.notBefore != null ? c.fromTime(input.status.notBefore) : undefined,
      renewalTime: input.status.renewalTime != null ? c.fromTime(input.status.renewalTime) : undefined,
    } : undefined,
  }}
export function toCertificate_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    commonName: c.readOpt(obj["commonName"], c.checkStr),
    dnsNames: c.readOpt(obj["dnsNames"], x => c.readList(x, c.checkStr)),
    duration: c.readOpt(obj["duration"], c.checkStr),
    emailSANs: c.readOpt(obj["emailSANs"], x => c.readList(x, c.checkStr)),
    encodeUsagesInRequest: c.readOpt(obj["encodeUsagesInRequest"], c.checkBool),
    ipAddresses: c.readOpt(obj["ipAddresses"], x => c.readList(x, c.checkStr)),
    isCA: c.readOpt(obj["isCA"], c.checkBool),
    issuerRef: toCertificate_spec_issuerRef(obj["issuerRef"]),
    keyAlgorithm: c.readOpt(obj["keyAlgorithm"], (x => c.readEnum<"rsa" | "ecdsa" | c.UnexpectedEnumValue>(x))),
    keyEncoding: c.readOpt(obj["keyEncoding"], (x => c.readEnum<"pkcs1" | "pkcs8" | c.UnexpectedEnumValue>(x))),
    keySize: c.readOpt(obj["keySize"], c.checkNum),
    keystores: c.readOpt(obj["keystores"], toCertificate_spec_keystores),
    privateKey: c.readOpt(obj["privateKey"], toCertificate_spec_privateKey),
    renewBefore: c.readOpt(obj["renewBefore"], c.checkStr),
    revisionHistoryLimit: c.readOpt(obj["revisionHistoryLimit"], c.checkNum),
    secretName: c.checkStr(obj["secretName"]),
    secretTemplate: c.readOpt(obj["secretTemplate"], toCertificate_spec_secretTemplate),
    subject: c.readOpt(obj["subject"], toCertificate_spec_subject),
    uriSANs: c.readOpt(obj["uriSANs"], x => c.readList(x, c.checkStr)),
    usages: c.readOpt(obj["usages"], x => c.readList(x, (x => c.readEnum<"signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc" | c.UnexpectedEnumValue>(x)))),
  }}
export function toCertificate_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toCertificate_status_conditions)),
    lastFailureTime: c.readOpt(obj["lastFailureTime"], c.toTime),
    nextPrivateKeySecretName: c.readOpt(obj["nextPrivateKeySecretName"], c.checkStr),
    notAfter: c.readOpt(obj["notAfter"], c.toTime),
    notBefore: c.readOpt(obj["notBefore"], c.toTime),
    renewalTime: c.readOpt(obj["renewalTime"], c.toTime),
    revision: c.readOpt(obj["revision"], c.checkNum),
  }}
export function toCertificate_spec_issuerRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toCertificate_spec_keystores(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    jks: c.readOpt(obj["jks"], toCertificate_spec_keystores_jks),
    pkcs12: c.readOpt(obj["pkcs12"], toCertificate_spec_keystores_pkcs12),
  }}
export function toCertificate_spec_privateKey(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    rotationPolicy: c.readOpt(obj["rotationPolicy"], c.checkStr),
  }}
export function toCertificate_spec_secretTemplate(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
export function toCertificate_spec_subject(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    countries: c.readOpt(obj["countries"], x => c.readList(x, c.checkStr)),
    localities: c.readOpt(obj["localities"], x => c.readList(x, c.checkStr)),
    organizationalUnits: c.readOpt(obj["organizationalUnits"], x => c.readList(x, c.checkStr)),
    organizations: c.readOpt(obj["organizations"], x => c.readList(x, c.checkStr)),
    postalCodes: c.readOpt(obj["postalCodes"], x => c.readList(x, c.checkStr)),
    provinces: c.readOpt(obj["provinces"], x => c.readList(x, c.checkStr)),
    serialNumber: c.readOpt(obj["serialNumber"], c.checkStr),
    streetAddresses: c.readOpt(obj["streetAddresses"], x => c.readList(x, c.checkStr)),
  }}
export function toCertificate_status_conditions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: (x => c.readEnum<"True" | "False" | "Unknown" | c.UnexpectedEnumValue>(x))(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}
export function toCertificate_spec_keystores_jks(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    create: c.checkBool(obj["create"]),
    passwordSecretRef: toSecretRef(obj["passwordSecretRef"]),
  }}
export function toCertificate_spec_keystores_pkcs12(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    create: c.checkBool(obj["create"]),
    passwordSecretRef: toSecretRef(obj["passwordSecretRef"]),
  }}

export interface CertificateList extends ListOf<Certificate> {
  apiVersion?: "cert-manager.io/v1alpha3";
  kind?: "CertificateList";
};
export function toCertificateList(input: c.JSONValue): CertificateList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha3", "CertificateList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toCertificate),
  }}

/** Desired state of the Issuer or ClusterIssuer resource. */
export interface IssuerSpec {
  acme?: {
    disableAccountKeyGeneration?: boolean | null;
    email?: string | null;
    enableDurationFeature?: boolean | null;
    externalAccountBinding?: {
      keyAlgorithm?: "HS256" | "HS384" | "HS512" | c.UnexpectedEnumValue | null;
      keyID: string;
      keySecretRef: SecretRef;
    } | null;
    preferredChain?: string | null;
    privateKeySecretRef: SecretRef;
    server: string;
    skipTLSVerify?: boolean | null;
    solvers?: Array<SolverSpec> | null;
  } | null;
  ca?: {
    crlDistributionPoints?: Array<string> | null;
    ocspServers?: Array<string> | null;
    secretName: string;
  } | null;
  selfSigned?: {
    crlDistributionPoints?: Array<string> | null;
  } | null;
  vault?: {
    auth: {
      appRole?: {
        path: string;
        roleId: string;
        secretRef: SecretRef;
      } | null;
      kubernetes?: {
        mountPath?: string | null;
        role: string;
        secretRef: SecretRef;
      } | null;
      tokenSecretRef?: SecretRef | null;
    };
    caBundle?: string | null;
    namespace?: string | null;
    path: string;
    server: string;
  } | null;
  venafi?: {
    cloud?: {
      apiTokenSecretRef: SecretRef;
      url?: string | null;
    } | null;
    tpp?: {
      caBundle?: string | null;
      credentialsRef: {
        name: string;
      };
      url: string;
    } | null;
    zone: string;
  } | null;
}
export function toIssuerSpec(input: c.JSONValue): IssuerSpec {
  const obj = c.checkObj(input);
  return {
    acme: c.readOpt(obj["acme"], toIssuerSpec_acme),
    ca: c.readOpt(obj["ca"], toIssuerSpec_ca),
    selfSigned: c.readOpt(obj["selfSigned"], toIssuerSpec_selfSigned),
    vault: c.readOpt(obj["vault"], toIssuerSpec_vault),
    venafi: c.readOpt(obj["venafi"], toIssuerSpec_venafi),
  }}
export function fromIssuerSpec(input: IssuerSpec): c.JSONValue {
  return {
    ...input,
    acme: input.acme != null ? {
      ...input.acme,
      externalAccountBinding: input.acme.externalAccountBinding != null ? {
        ...input.acme.externalAccountBinding,
        keySecretRef: input.acme.externalAccountBinding.keySecretRef != null ? fromSecretRef(input.acme.externalAccountBinding.keySecretRef) : undefined,
      } : undefined,
      privateKeySecretRef: input.acme.privateKeySecretRef != null ? fromSecretRef(input.acme.privateKeySecretRef) : undefined,
      solvers: input.acme.solvers?.map(fromSolverSpec),
    } : undefined,
    vault: input.vault != null ? {
      ...input.vault,
      auth: input.vault.auth != null ? {
        ...input.vault.auth,
        appRole: input.vault.auth.appRole != null ? {
          ...input.vault.auth.appRole,
          secretRef: input.vault.auth.appRole.secretRef != null ? fromSecretRef(input.vault.auth.appRole.secretRef) : undefined,
        } : undefined,
        kubernetes: input.vault.auth.kubernetes != null ? {
          ...input.vault.auth.kubernetes,
          secretRef: input.vault.auth.kubernetes.secretRef != null ? fromSecretRef(input.vault.auth.kubernetes.secretRef) : undefined,
        } : undefined,
        tokenSecretRef: input.vault.auth.tokenSecretRef != null ? fromSecretRef(input.vault.auth.tokenSecretRef) : undefined,
      } : undefined,
    } : undefined,
    venafi: input.venafi != null ? {
      ...input.venafi,
      cloud: input.venafi.cloud != null ? {
        ...input.venafi.cloud,
        apiTokenSecretRef: input.venafi.cloud.apiTokenSecretRef != null ? fromSecretRef(input.venafi.cloud.apiTokenSecretRef) : undefined,
      } : undefined,
    } : undefined,
  }}
export function toIssuerSpec_acme(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    disableAccountKeyGeneration: c.readOpt(obj["disableAccountKeyGeneration"], c.checkBool),
    email: c.readOpt(obj["email"], c.checkStr),
    enableDurationFeature: c.readOpt(obj["enableDurationFeature"], c.checkBool),
    externalAccountBinding: c.readOpt(obj["externalAccountBinding"], toIssuerSpec_acme_externalAccountBinding),
    preferredChain: c.readOpt(obj["preferredChain"], c.checkStr),
    privateKeySecretRef: toSecretRef(obj["privateKeySecretRef"]),
    server: c.checkStr(obj["server"]),
    skipTLSVerify: c.readOpt(obj["skipTLSVerify"], c.checkBool),
    solvers: c.readOpt(obj["solvers"], x => c.readList(x, toSolverSpec)),
  }}
export function toIssuerSpec_ca(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    crlDistributionPoints: c.readOpt(obj["crlDistributionPoints"], x => c.readList(x, c.checkStr)),
    ocspServers: c.readOpt(obj["ocspServers"], x => c.readList(x, c.checkStr)),
    secretName: c.checkStr(obj["secretName"]),
  }}
export function toIssuerSpec_selfSigned(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    crlDistributionPoints: c.readOpt(obj["crlDistributionPoints"], x => c.readList(x, c.checkStr)),
  }}
export function toIssuerSpec_vault(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    auth: toIssuerSpec_vault_auth(obj["auth"]),
    caBundle: c.readOpt(obj["caBundle"], c.checkStr),
    namespace: c.readOpt(obj["namespace"], c.checkStr),
    path: c.checkStr(obj["path"]),
    server: c.checkStr(obj["server"]),
  }}
export function toIssuerSpec_venafi(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    cloud: c.readOpt(obj["cloud"], toIssuerSpec_venafi_cloud),
    tpp: c.readOpt(obj["tpp"], toIssuerSpec_venafi_tpp),
    zone: c.checkStr(obj["zone"]),
  }}
export function toIssuerSpec_acme_externalAccountBinding(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    keyAlgorithm: c.readOpt(obj["keyAlgorithm"], (x => c.readEnum<"HS256" | "HS384" | "HS512" | c.UnexpectedEnumValue>(x))),
    keyID: c.checkStr(obj["keyID"]),
    keySecretRef: toSecretRef(obj["keySecretRef"]),
  }}
export function toIssuerSpec_vault_auth(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    appRole: c.readOpt(obj["appRole"], toIssuerSpec_vault_auth_appRole),
    kubernetes: c.readOpt(obj["kubernetes"], toIssuerSpec_vault_auth_kubernetes),
    tokenSecretRef: c.readOpt(obj["tokenSecretRef"], toSecretRef),
  }}
export function toIssuerSpec_venafi_cloud(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    apiTokenSecretRef: toSecretRef(obj["apiTokenSecretRef"]),
    url: c.readOpt(obj["url"], c.checkStr),
  }}
export function toIssuerSpec_venafi_tpp(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    caBundle: c.readOpt(obj["caBundle"], c.checkStr),
    credentialsRef: toIssuerSpec_venafi_tpp_credentialsRef(obj["credentialsRef"]),
    url: c.checkStr(obj["url"]),
  }}
export function toIssuerSpec_vault_auth_appRole(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    path: c.checkStr(obj["path"]),
    roleId: c.checkStr(obj["roleId"]),
    secretRef: toSecretRef(obj["secretRef"]),
  }}
export function toIssuerSpec_vault_auth_kubernetes(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    mountPath: c.readOpt(obj["mountPath"], c.checkStr),
    role: c.checkStr(obj["role"]),
    secretRef: toSecretRef(obj["secretRef"]),
  }}
export function toIssuerSpec_venafi_tpp_credentialsRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    name: c.checkStr(obj["name"]),
  }}

/** Configures an issuer to solve challenges using the specified options. Only one of HTTP01 or DNS01 may be provided. */
export interface SolverSpec {
  dns01?: {
    acmedns?: {
      accountSecretRef: SecretRef;
      host: string;
    } | null;
    akamai?: {
      accessTokenSecretRef: SecretRef;
      clientSecretSecretRef: SecretRef;
      clientTokenSecretRef: SecretRef;
      serviceConsumerDomain: string;
    } | null;
    azuredns?: {
      clientID?: string | null;
      clientSecretSecretRef?: SecretRef | null;
      environment?: "AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud" | c.UnexpectedEnumValue | null;
      hostedZoneName?: string | null;
      managedIdentity?: {
        clientID?: string | null;
        resourceID?: string | null;
      } | null;
      resourceGroupName: string;
      subscriptionID: string;
      tenantID?: string | null;
    } | null;
    clouddns?: {
      hostedZoneName?: string | null;
      project: string;
      serviceAccountSecretRef?: SecretRef | null;
    } | null;
    cloudflare?: {
      apiKeySecretRef?: SecretRef | null;
      apiTokenSecretRef?: SecretRef | null;
      email?: string | null;
    } | null;
    cnameStrategy?: "None" | "Follow" | c.UnexpectedEnumValue | null;
    digitalocean?: {
      tokenSecretRef: SecretRef;
    } | null;
    rfc2136?: {
      nameserver: string;
      tsigAlgorithm?: string | null;
      tsigKeyName?: string | null;
      tsigSecretSecretRef?: SecretRef | null;
    } | null;
    route53?: {
      accessKeyID?: string | null;
      hostedZoneID?: string | null;
      region: string;
      role?: string | null;
      secretAccessKeySecretRef?: SecretRef | null;
    } | null;
    webhook?: {
      config?: c.JSONValue | null;
      groupName: string;
      solverName: string;
    } | null;
  } | null;
  http01?: {
    gatewayHTTPRoute?: {
      labels?: Record<string,string> | null;
      serviceType?: string | null;
    } | null;
    ingress?: {
      class?: string | null;
      ingressTemplate?: {
        metadata?: {
          annotations?: Record<string,string> | null;
          labels?: Record<string,string> | null;
        } | null;
      } | null;
      name?: string | null;
      podTemplate?: {
        metadata?: {
          annotations?: Record<string,string> | null;
          labels?: Record<string,string> | null;
        } | null;
        spec?: {
          affinity?: CoreV1.Affinity | null;
          nodeSelector?: Record<string,string> | null;
          priorityClassName?: string | null;
          serviceAccountName?: string | null;
          tolerations?: Array<{
            effect?: string | null;
            key?: string | null;
            operator?: string | null;
            tolerationSeconds?: number | null;
            value?: string | null;
          }> | null;
        } | null;
      } | null;
      serviceType?: string | null;
    } | null;
  } | null;
  selector?: {
    dnsNames?: Array<string> | null;
    dnsZones?: Array<string> | null;
    matchLabels?: Record<string,string> | null;
  } | null;
}
export function toSolverSpec(input: c.JSONValue): SolverSpec {
  const obj = c.checkObj(input);
  return {
    dns01: c.readOpt(obj["dns01"], toSolverSpec_dns01),
    http01: c.readOpt(obj["http01"], toSolverSpec_http01),
    selector: c.readOpt(obj["selector"], toSolverSpec_selector),
  }}
export function fromSolverSpec(input: SolverSpec): c.JSONValue {
  return {
    ...input,
    dns01: input.dns01 != null ? {
      ...input.dns01,
      acmedns: input.dns01.acmedns != null ? {
        ...input.dns01.acmedns,
        accountSecretRef: input.dns01.acmedns.accountSecretRef != null ? fromSecretRef(input.dns01.acmedns.accountSecretRef) : undefined,
      } : undefined,
      akamai: input.dns01.akamai != null ? {
        ...input.dns01.akamai,
        accessTokenSecretRef: input.dns01.akamai.accessTokenSecretRef != null ? fromSecretRef(input.dns01.akamai.accessTokenSecretRef) : undefined,
        clientSecretSecretRef: input.dns01.akamai.clientSecretSecretRef != null ? fromSecretRef(input.dns01.akamai.clientSecretSecretRef) : undefined,
        clientTokenSecretRef: input.dns01.akamai.clientTokenSecretRef != null ? fromSecretRef(input.dns01.akamai.clientTokenSecretRef) : undefined,
      } : undefined,
      azuredns: input.dns01.azuredns != null ? {
        ...input.dns01.azuredns,
        clientSecretSecretRef: input.dns01.azuredns.clientSecretSecretRef != null ? fromSecretRef(input.dns01.azuredns.clientSecretSecretRef) : undefined,
      } : undefined,
      clouddns: input.dns01.clouddns != null ? {
        ...input.dns01.clouddns,
        serviceAccountSecretRef: input.dns01.clouddns.serviceAccountSecretRef != null ? fromSecretRef(input.dns01.clouddns.serviceAccountSecretRef) : undefined,
      } : undefined,
      cloudflare: input.dns01.cloudflare != null ? {
        ...input.dns01.cloudflare,
        apiKeySecretRef: input.dns01.cloudflare.apiKeySecretRef != null ? fromSecretRef(input.dns01.cloudflare.apiKeySecretRef) : undefined,
        apiTokenSecretRef: input.dns01.cloudflare.apiTokenSecretRef != null ? fromSecretRef(input.dns01.cloudflare.apiTokenSecretRef) : undefined,
      } : undefined,
      digitalocean: input.dns01.digitalocean != null ? {
        ...input.dns01.digitalocean,
        tokenSecretRef: input.dns01.digitalocean.tokenSecretRef != null ? fromSecretRef(input.dns01.digitalocean.tokenSecretRef) : undefined,
      } : undefined,
      rfc2136: input.dns01.rfc2136 != null ? {
        ...input.dns01.rfc2136,
        tsigSecretSecretRef: input.dns01.rfc2136.tsigSecretSecretRef != null ? fromSecretRef(input.dns01.rfc2136.tsigSecretSecretRef) : undefined,
      } : undefined,
      route53: input.dns01.route53 != null ? {
        ...input.dns01.route53,
        secretAccessKeySecretRef: input.dns01.route53.secretAccessKeySecretRef != null ? fromSecretRef(input.dns01.route53.secretAccessKeySecretRef) : undefined,
      } : undefined,
    } : undefined,
    http01: input.http01 != null ? {
      ...input.http01,
      ingress: input.http01.ingress != null ? {
        ...input.http01.ingress,
        podTemplate: input.http01.ingress.podTemplate != null ? {
          ...input.http01.ingress.podTemplate,
          spec: input.http01.ingress.podTemplate.spec != null ? {
            ...input.http01.ingress.podTemplate.spec,
            affinity: input.http01.ingress.podTemplate.spec.affinity != null ? CoreV1.fromAffinity(input.http01.ingress.podTemplate.spec.affinity) : undefined,
          } : undefined,
        } : undefined,
      } : undefined,
    } : undefined,
  }}
export function toSolverSpec_dns01(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    acmedns: c.readOpt(obj["acmedns"], toSolverSpec_dns01_acmedns),
    akamai: c.readOpt(obj["akamai"], toSolverSpec_dns01_akamai),
    azuredns: c.readOpt(obj["azuredns"], toSolverSpec_dns01_azuredns),
    clouddns: c.readOpt(obj["clouddns"], toSolverSpec_dns01_clouddns),
    cloudflare: c.readOpt(obj["cloudflare"], toSolverSpec_dns01_cloudflare),
    cnameStrategy: c.readOpt(obj["cnameStrategy"], (x => c.readEnum<"None" | "Follow" | c.UnexpectedEnumValue>(x))),
    digitalocean: c.readOpt(obj["digitalocean"], toSolverSpec_dns01_digitalocean),
    rfc2136: c.readOpt(obj["rfc2136"], toSolverSpec_dns01_rfc2136),
    route53: c.readOpt(obj["route53"], toSolverSpec_dns01_route53),
    webhook: c.readOpt(obj["webhook"], toSolverSpec_dns01_webhook),
  }}
export function toSolverSpec_http01(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    gatewayHTTPRoute: c.readOpt(obj["gatewayHTTPRoute"], toSolverSpec_http01_gatewayHTTPRoute),
    ingress: c.readOpt(obj["ingress"], toSolverSpec_http01_ingress),
  }}
export function toSolverSpec_selector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    dnsNames: c.readOpt(obj["dnsNames"], x => c.readList(x, c.checkStr)),
    dnsZones: c.readOpt(obj["dnsZones"], x => c.readList(x, c.checkStr)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toSolverSpec_dns01_acmedns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accountSecretRef: toSecretRef(obj["accountSecretRef"]),
    host: c.checkStr(obj["host"]),
  }}
export function toSolverSpec_dns01_akamai(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accessTokenSecretRef: toSecretRef(obj["accessTokenSecretRef"]),
    clientSecretSecretRef: toSecretRef(obj["clientSecretSecretRef"]),
    clientTokenSecretRef: toSecretRef(obj["clientTokenSecretRef"]),
    serviceConsumerDomain: c.checkStr(obj["serviceConsumerDomain"]),
  }}
export function toSolverSpec_dns01_azuredns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    clientID: c.readOpt(obj["clientID"], c.checkStr),
    clientSecretSecretRef: c.readOpt(obj["clientSecretSecretRef"], toSecretRef),
    environment: c.readOpt(obj["environment"], (x => c.readEnum<"AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud" | c.UnexpectedEnumValue>(x))),
    hostedZoneName: c.readOpt(obj["hostedZoneName"], c.checkStr),
    managedIdentity: c.readOpt(obj["managedIdentity"], toSolverSpec_dns01_azuredns_managedIdentity),
    resourceGroupName: c.checkStr(obj["resourceGroupName"]),
    subscriptionID: c.checkStr(obj["subscriptionID"]),
    tenantID: c.readOpt(obj["tenantID"], c.checkStr),
  }}
export function toSolverSpec_dns01_clouddns(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    hostedZoneName: c.readOpt(obj["hostedZoneName"], c.checkStr),
    project: c.checkStr(obj["project"]),
    serviceAccountSecretRef: c.readOpt(obj["serviceAccountSecretRef"], toSecretRef),
  }}
export function toSolverSpec_dns01_cloudflare(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    apiKeySecretRef: c.readOpt(obj["apiKeySecretRef"], toSecretRef),
    apiTokenSecretRef: c.readOpt(obj["apiTokenSecretRef"], toSecretRef),
    email: c.readOpt(obj["email"], c.checkStr),
  }}
export function toSolverSpec_dns01_digitalocean(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    tokenSecretRef: toSecretRef(obj["tokenSecretRef"]),
  }}
export function toSolverSpec_dns01_rfc2136(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nameserver: c.checkStr(obj["nameserver"]),
    tsigAlgorithm: c.readOpt(obj["tsigAlgorithm"], c.checkStr),
    tsigKeyName: c.readOpt(obj["tsigKeyName"], c.checkStr),
    tsigSecretSecretRef: c.readOpt(obj["tsigSecretSecretRef"], toSecretRef),
  }}
export function toSolverSpec_dns01_route53(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accessKeyID: c.readOpt(obj["accessKeyID"], c.checkStr),
    hostedZoneID: c.readOpt(obj["hostedZoneID"], c.checkStr),
    region: c.checkStr(obj["region"]),
    role: c.readOpt(obj["role"], c.checkStr),
    secretAccessKeySecretRef: c.readOpt(obj["secretAccessKeySecretRef"], toSecretRef),
  }}
export function toSolverSpec_dns01_webhook(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    config: c.readOpt(obj["config"], c.identity),
    groupName: c.checkStr(obj["groupName"]),
    solverName: c.checkStr(obj["solverName"]),
  }}
export function toSolverSpec_http01_gatewayHTTPRoute(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
    serviceType: c.readOpt(obj["serviceType"], c.checkStr),
  }}
export function toSolverSpec_http01_ingress(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    class: c.readOpt(obj["class"], c.checkStr),
    ingressTemplate: c.readOpt(obj["ingressTemplate"], toSolverSpec_http01_ingress_ingressTemplate),
    name: c.readOpt(obj["name"], c.checkStr),
    podTemplate: c.readOpt(obj["podTemplate"], toSolverSpec_http01_ingress_podTemplate),
    serviceType: c.readOpt(obj["serviceType"], c.checkStr),
  }}
export function toSolverSpec_dns01_azuredns_managedIdentity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    clientID: c.readOpt(obj["clientID"], c.checkStr),
    resourceID: c.readOpt(obj["resourceID"], c.checkStr),
  }}
export function toSolverSpec_http01_ingress_ingressTemplate(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], toSolverSpec_http01_ingress_ingressTemplate_metadata),
  }}
export function toSolverSpec_http01_ingress_podTemplate(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], toSolverSpec_http01_ingress_podTemplate_metadata),
    spec: c.readOpt(obj["spec"], toSolverSpec_http01_ingress_podTemplate_spec),
  }}
export function toSolverSpec_http01_ingress_ingressTemplate_metadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
export function toSolverSpec_http01_ingress_podTemplate_metadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
export function toSolverSpec_http01_ingress_podTemplate_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    affinity: c.readOpt(obj["affinity"], CoreV1.toAffinity),
    nodeSelector: c.readOpt(obj["nodeSelector"], x => c.readMap(x, c.checkStr)),
    priorityClassName: c.readOpt(obj["priorityClassName"], c.checkStr),
    serviceAccountName: c.readOpt(obj["serviceAccountName"], c.checkStr),
    tolerations: c.readOpt(obj["tolerations"], x => c.readList(x, toSolverSpec_http01_ingress_podTemplate_spec_tolerations)),
  }}
export function toSolverSpec_http01_ingress_podTemplate_spec_tolerations(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    effect: c.readOpt(obj["effect"], c.checkStr),
    key: c.readOpt(obj["key"], c.checkStr),
    operator: c.readOpt(obj["operator"], c.checkStr),
    tolerationSeconds: c.readOpt(obj["tolerationSeconds"], c.checkNum),
    value: c.readOpt(obj["value"], c.checkStr),
  }}

/** Status of the Issuer or ClusterIssuer. This is set and managed automatically. */
export interface IssuerStatus {
  acme?: {
    lastRegisteredEmail?: string | null;
    uri?: string | null;
  } | null;
  conditions?: Array<{
    lastTransitionTime?: c.Time | null;
    message?: string | null;
    observedGeneration?: number | null;
    reason?: string | null;
    status: "True" | "False" | "Unknown" | c.UnexpectedEnumValue;
    type: string;
  }> | null;
}
export function toIssuerStatus(input: c.JSONValue): IssuerStatus {
  const obj = c.checkObj(input);
  return {
    acme: c.readOpt(obj["acme"], toIssuerStatus_acme),
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, toIssuerStatus_conditions)),
  }}
export function fromIssuerStatus(input: IssuerStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(x => ({
      ...x,
      lastTransitionTime: x.lastTransitionTime != null ? c.fromTime(x.lastTransitionTime) : undefined,
    })),
  }}
export function toIssuerStatus_acme(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastRegisteredEmail: c.readOpt(obj["lastRegisteredEmail"], c.checkStr),
    uri: c.readOpt(obj["uri"], c.checkStr),
  }}
export function toIssuerStatus_conditions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    lastTransitionTime: c.readOpt(obj["lastTransitionTime"], c.toTime),
    message: c.readOpt(obj["message"], c.checkStr),
    observedGeneration: c.readOpt(obj["observedGeneration"], c.checkNum),
    reason: c.readOpt(obj["reason"], c.checkStr),
    status: (x => c.readEnum<"True" | "False" | "Unknown" | c.UnexpectedEnumValue>(x))(obj["status"]),
    type: c.checkStr(obj["type"]),
  }}

/** A ClusterIssuer represents a certificate issuing authority which can be referenced as part of `issuerRef` fields. It is similar to an Issuer, however it is cluster-scoped and therefore can be referenced by resources that exist in *any* namespace, not just the same namespace as the referent. */
export interface ClusterIssuer {
  apiVersion?: "cert-manager.io/v1alpha3";
  kind?: "ClusterIssuer";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: IssuerSpec | null;
  status?: IssuerStatus | null;
}
export function toClusterIssuer(input: c.JSONValue): ClusterIssuer & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha3", "ClusterIssuer"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toIssuerSpec),
    status: c.readOpt(obj["status"], toIssuerStatus),
  }}
export function fromClusterIssuer(input: ClusterIssuer): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "cert-manager.io/v1alpha3", "ClusterIssuer"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromIssuerSpec(input.spec) : undefined,
    status: input.status != null ? fromIssuerStatus(input.status) : undefined,
  }}

export interface ClusterIssuerList extends ListOf<ClusterIssuer> {
  apiVersion?: "cert-manager.io/v1alpha3";
  kind?: "ClusterIssuerList";
};
export function toClusterIssuerList(input: c.JSONValue): ClusterIssuerList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha3", "ClusterIssuerList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toClusterIssuer),
  }}

/** An Issuer represents a certificate issuing authority which can be referenced as part of `issuerRef` fields. It is scoped to a single namespace and can therefore only be referenced by resources within the same namespace. */
export interface Issuer {
  apiVersion?: "cert-manager.io/v1alpha3";
  kind?: "Issuer";
  metadata?: MetaV1.ObjectMeta | null;
  spec?: IssuerSpec | null;
  status?: IssuerStatus | null;
}
export function toIssuer(input: c.JSONValue): Issuer & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha3", "Issuer"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: c.readOpt(obj["spec"], toIssuerSpec),
    status: c.readOpt(obj["status"], toIssuerStatus),
  }}
export function fromIssuer(input: Issuer): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "cert-manager.io/v1alpha3", "Issuer"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromIssuerSpec(input.spec) : undefined,
    status: input.status != null ? fromIssuerStatus(input.status) : undefined,
  }}

export interface IssuerList extends ListOf<Issuer> {
  apiVersion?: "cert-manager.io/v1alpha3";
  kind?: "IssuerList";
};
export function toIssuerList(input: c.JSONValue): IssuerList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "cert-manager.io/v1alpha3", "IssuerList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toIssuer),
  }}
