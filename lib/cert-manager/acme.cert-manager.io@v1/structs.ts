// Autogenerated Schema file for AcmeCertManagerIoV1
import * as c from "../../common.ts";

import * as CertManagerIoV1 from "../cert-manager.io@v1/structs.ts";
import * as MetaV1 from "../../builtin/meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** Challenge is a type to represent a Challenge request with an ACME server */
export interface Challenge {
  apiVersion?: "acme.cert-manager.io/v1";
  kind?: "Challenge";
  metadata: MetaV1.ObjectMeta;
  spec: {
    authorizationURL: string;
    dnsName: string;
    issuerRef: {
      group?: string | null;
      kind?: string | null;
      name: string;
    };
    key: string;
    solver: CertManagerIoV1.SolverSpec;
    token: string;
    type: "HTTP-01" | "DNS-01" | c.UnexpectedEnumValue;
    url: string;
    wildcard?: boolean | null;
  };
  status?: {
    presented?: boolean | null;
    processing?: boolean | null;
    reason?: string | null;
    state?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue | null;
  } | null;
}
export function toChallenge(input: c.JSONValue): Challenge & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "acme.cert-manager.io/v1", "Challenge"),
    metadata: MetaV1.toObjectMeta(obj["metadata"]),
    spec: toChallenge_spec(obj["spec"]),
    status: c.readOpt(obj["status"], toChallenge_status),
  }}
export function fromChallenge(input: Challenge): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "acme.cert-manager.io/v1", "Challenge"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? {
      ...input.spec,
      solver: input.spec.solver != null ? CertManagerIoV1.fromSolverSpec(input.spec.solver) : undefined,
    } : undefined,
  }}
export function toChallenge_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    authorizationURL: c.checkStr(obj["authorizationURL"]),
    dnsName: c.checkStr(obj["dnsName"]),
    issuerRef: toChallenge_spec_issuerRef(obj["issuerRef"]),
    key: c.checkStr(obj["key"]),
    solver: CertManagerIoV1.toSolverSpec(obj["solver"]),
    token: c.checkStr(obj["token"]),
    type: (x => c.readEnum<"HTTP-01" | "DNS-01" | c.UnexpectedEnumValue>(x))(obj["type"]),
    url: c.checkStr(obj["url"]),
    wildcard: c.readOpt(obj["wildcard"], c.checkBool),
  }}
export function toChallenge_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    presented: c.readOpt(obj["presented"], c.checkBool),
    processing: c.readOpt(obj["processing"], c.checkBool),
    reason: c.readOpt(obj["reason"], c.checkStr),
    state: c.readOpt(obj["state"], (x => c.readEnum<"valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue>(x))),
  }}
export function toChallenge_spec_issuerRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}

export interface ChallengeList extends ListOf<Challenge> {
  apiVersion?: "acme.cert-manager.io/v1";
  kind?: "ChallengeList";
};
export function toChallengeList(input: c.JSONValue): ChallengeList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "acme.cert-manager.io/v1", "ChallengeList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toChallenge),
  }}

/** Order is a type to represent an Order with an ACME server */
export interface Order {
  apiVersion?: "acme.cert-manager.io/v1";
  kind?: "Order";
  metadata: MetaV1.ObjectMeta;
  spec: {
    commonName?: string | null;
    dnsNames?: Array<string> | null;
    duration?: string | null;
    ipAddresses?: Array<string> | null;
    issuerRef: {
      group?: string | null;
      kind?: string | null;
      name: string;
    };
    request: string;
  };
  status?: {
    authorizations?: Array<{
      challenges?: Array<{
        token: string;
        type: string;
        url: string;
      }> | null;
      identifier?: string | null;
      initialState?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue | null;
      url: string;
      wildcard?: boolean | null;
    }> | null;
    certificate?: string | null;
    failureTime?: c.Time | null;
    finalizeURL?: string | null;
    reason?: string | null;
    state?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue | null;
    url?: string | null;
  } | null;
}
export function toOrder(input: c.JSONValue): Order & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "acme.cert-manager.io/v1", "Order"),
    metadata: MetaV1.toObjectMeta(obj["metadata"]),
    spec: toOrder_spec(obj["spec"]),
    status: c.readOpt(obj["status"], toOrder_status),
  }}
export function fromOrder(input: Order): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "acme.cert-manager.io/v1", "Order"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    status: input.status != null ? {
      ...input.status,
      failureTime: input.status.failureTime != null ? c.fromTime(input.status.failureTime) : undefined,
    } : undefined,
  }}
export function toOrder_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    commonName: c.readOpt(obj["commonName"], c.checkStr),
    dnsNames: c.readOpt(obj["dnsNames"], x => c.readList(x, c.checkStr)),
    duration: c.readOpt(obj["duration"], c.checkStr),
    ipAddresses: c.readOpt(obj["ipAddresses"], x => c.readList(x, c.checkStr)),
    issuerRef: toOrder_spec_issuerRef(obj["issuerRef"]),
    request: c.checkStr(obj["request"]),
  }}
export function toOrder_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    authorizations: c.readOpt(obj["authorizations"], x => c.readList(x, toOrder_status_authorizations)),
    certificate: c.readOpt(obj["certificate"], c.checkStr),
    failureTime: c.readOpt(obj["failureTime"], c.toTime),
    finalizeURL: c.readOpt(obj["finalizeURL"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    state: c.readOpt(obj["state"], (x => c.readEnum<"valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue>(x))),
    url: c.readOpt(obj["url"], c.checkStr),
  }}
export function toOrder_spec_issuerRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toOrder_status_authorizations(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    challenges: c.readOpt(obj["challenges"], x => c.readList(x, toOrder_status_authorizations_challenges)),
    identifier: c.readOpt(obj["identifier"], c.checkStr),
    initialState: c.readOpt(obj["initialState"], (x => c.readEnum<"valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue>(x))),
    url: c.checkStr(obj["url"]),
    wildcard: c.readOpt(obj["wildcard"], c.checkBool),
  }}
export function toOrder_status_authorizations_challenges(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    token: c.checkStr(obj["token"]),
    type: c.checkStr(obj["type"]),
    url: c.checkStr(obj["url"]),
  }}

export interface OrderList extends ListOf<Order> {
  apiVersion?: "acme.cert-manager.io/v1";
  kind?: "OrderList";
};
export function toOrderList(input: c.JSONValue): OrderList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "acme.cert-manager.io/v1", "OrderList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toOrder),
  }}
