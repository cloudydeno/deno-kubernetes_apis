// Autogenerated Schema file for AcmeCertManagerIoV1
import * as c from "../../common.ts";

import * as MetaV1 from "../../builtin/meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** Challenge is a type to represent a Challenge request with an ACME server */
export interface Challenge {
  apiVersion?: "acme.cert-manager.io/v1";
  kind?: "Challenge";
  metadata: MetaV1.ObjectMeta;
  spec: {
    authorizationURL: string;
    dnsName: string;
    issuerRef: {
      group?: string | null;
      kind?: string | null;
      name: string;
    };
    key: string;
    solver: {
      dns01?: {
        acmeDNS?: {
          accountSecretRef: {
            key?: string | null;
            name: string;
          };
          host: string;
        } | null;
        akamai?: {
          accessTokenSecretRef: {
            key?: string | null;
            name: string;
          };
          clientSecretSecretRef: {
            key?: string | null;
            name: string;
          };
          clientTokenSecretRef: {
            key?: string | null;
            name: string;
          };
          serviceConsumerDomain: string;
        } | null;
        azureDNS?: {
          clientID?: string | null;
          clientSecretSecretRef?: {
            key?: string | null;
            name: string;
          } | null;
          environment?: "AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud" | c.UnexpectedEnumValue | null;
          hostedZoneName?: string | null;
          resourceGroupName: string;
          subscriptionID: string;
          tenantID?: string | null;
        } | null;
        cloudDNS?: {
          hostedZoneName?: string | null;
          project: string;
          serviceAccountSecretRef?: {
            key?: string | null;
            name: string;
          } | null;
        } | null;
        cloudflare?: {
          apiKeySecretRef?: {
            key?: string | null;
            name: string;
          } | null;
          apiTokenSecretRef?: {
            key?: string | null;
            name: string;
          } | null;
          email?: string | null;
        } | null;
        cnameStrategy?: "None" | "Follow" | c.UnexpectedEnumValue | null;
        digitalocean?: {
          tokenSecretRef: {
            key?: string | null;
            name: string;
          };
        } | null;
        rfc2136?: {
          nameserver: string;
          tsigAlgorithm?: string | null;
          tsigKeyName?: string | null;
          tsigSecretSecretRef?: {
            key?: string | null;
            name: string;
          } | null;
        } | null;
        route53?: {
          accessKeyID?: string | null;
          hostedZoneID?: string | null;
          region: string;
          role?: string | null;
          secretAccessKeySecretRef?: {
            key?: string | null;
            name: string;
          } | null;
        } | null;
        webhook?: {
          config?: c.JSONValue | null;
          groupName: string;
          solverName: string;
        } | null;
      } | null;
      http01?: {
        ingress?: {
          class?: string | null;
          ingressTemplate?: {
            metadata?: {
              annotations?: Record<string,string> | null;
              labels?: Record<string,string> | null;
            } | null;
          } | null;
          name?: string | null;
          podTemplate?: {
            metadata?: {
              annotations?: Record<string,string> | null;
              labels?: Record<string,string> | null;
            } | null;
            spec?: {
              affinity?: {
                nodeAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                    preference: {
                      matchExpressions?: Array<{
                        key: string;
                        operator: string;
                        values?: Array<string> | null;
                      }> | null;
                      matchFields?: Array<{
                        key: string;
                        operator: string;
                        values?: Array<string> | null;
                      }> | null;
                    };
                    weight: number;
                  }> | null;
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    nodeSelectorTerms: Array<{
                      matchExpressions?: Array<{
                        key: string;
                        operator: string;
                        values?: Array<string> | null;
                      }> | null;
                      matchFields?: Array<{
                        key: string;
                        operator: string;
                        values?: Array<string> | null;
                      }> | null;
                    }>;
                  } | null;
                } | null;
                podAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                    podAffinityTerm: {
                      labelSelector?: {
                        matchExpressions?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                        matchLabels?: Record<string,string> | null;
                      } | null;
                      namespaces?: Array<string> | null;
                      topologyKey: string;
                    };
                    weight: number;
                  }> | null;
                  requiredDuringSchedulingIgnoredDuringExecution?: Array<{
                    labelSelector?: {
                      matchExpressions?: Array<{
                        key: string;
                        operator: string;
                        values?: Array<string> | null;
                      }> | null;
                      matchLabels?: Record<string,string> | null;
                    } | null;
                    namespaces?: Array<string> | null;
                    topologyKey: string;
                  }> | null;
                } | null;
                podAntiAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: Array<{
                    podAffinityTerm: {
                      labelSelector?: {
                        matchExpressions?: Array<{
                          key: string;
                          operator: string;
                          values?: Array<string> | null;
                        }> | null;
                        matchLabels?: Record<string,string> | null;
                      } | null;
                      namespaces?: Array<string> | null;
                      topologyKey: string;
                    };
                    weight: number;
                  }> | null;
                  requiredDuringSchedulingIgnoredDuringExecution?: Array<{
                    labelSelector?: {
                      matchExpressions?: Array<{
                        key: string;
                        operator: string;
                        values?: Array<string> | null;
                      }> | null;
                      matchLabels?: Record<string,string> | null;
                    } | null;
                    namespaces?: Array<string> | null;
                    topologyKey: string;
                  }> | null;
                } | null;
              } | null;
              nodeSelector?: Record<string,string> | null;
              priorityClassName?: string | null;
              serviceAccountName?: string | null;
              tolerations?: Array<{
                effect?: string | null;
                key?: string | null;
                operator?: string | null;
                tolerationSeconds?: number | null;
                value?: string | null;
              }> | null;
            } | null;
          } | null;
          serviceType?: string | null;
        } | null;
      } | null;
      selector?: {
        dnsNames?: Array<string> | null;
        dnsZones?: Array<string> | null;
        matchLabels?: Record<string,string> | null;
      } | null;
    };
    token: string;
    type: "HTTP-01" | "DNS-01" | c.UnexpectedEnumValue;
    url: string;
    wildcard?: boolean | null;
  };
  status?: {
    presented?: boolean | null;
    processing?: boolean | null;
    reason?: string | null;
    state?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue | null;
  } | null;
}
export function toChallenge(input: c.JSONValue): Challenge & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "acme.cert-manager.io/v1", "Challenge"),
    metadata: MetaV1.toObjectMeta(obj["metadata"]),
    spec: toChallenge_spec(obj["spec"]),
    status: c.readOpt(obj["status"], toChallenge_status),
  }}
export function fromChallenge(input: Challenge): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "acme.cert-manager.io/v1", "Challenge"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
  }}
export function toChallenge_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    authorizationURL: c.checkStr(obj["authorizationURL"]),
    dnsName: c.checkStr(obj["dnsName"]),
    issuerRef: toChallenge_spec_issuerRef(obj["issuerRef"]),
    key: c.checkStr(obj["key"]),
    solver: toChallenge_spec_solver(obj["solver"]),
    token: c.checkStr(obj["token"]),
    type: (x => c.readEnum<"HTTP-01" | "DNS-01" | c.UnexpectedEnumValue>(x))(obj["type"]),
    url: c.checkStr(obj["url"]),
    wildcard: c.readOpt(obj["wildcard"], c.checkBool),
  }}
export function toChallenge_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    presented: c.readOpt(obj["presented"], c.checkBool),
    processing: c.readOpt(obj["processing"], c.checkBool),
    reason: c.readOpt(obj["reason"], c.checkStr),
    state: c.readOpt(obj["state"], (x => c.readEnum<"valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue>(x))),
  }}
export function toChallenge_spec_issuerRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    dns01: c.readOpt(obj["dns01"], toChallenge_spec_solver_dns01),
    http01: c.readOpt(obj["http01"], toChallenge_spec_solver_http01),
    selector: c.readOpt(obj["selector"], toChallenge_spec_solver_selector),
  }}
export function toChallenge_spec_solver_dns01(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    acmeDNS: c.readOpt(obj["acmeDNS"], toChallenge_spec_solver_dns01_acmeDNS),
    akamai: c.readOpt(obj["akamai"], toChallenge_spec_solver_dns01_akamai),
    azureDNS: c.readOpt(obj["azureDNS"], toChallenge_spec_solver_dns01_azureDNS),
    cloudDNS: c.readOpt(obj["cloudDNS"], toChallenge_spec_solver_dns01_cloudDNS),
    cloudflare: c.readOpt(obj["cloudflare"], toChallenge_spec_solver_dns01_cloudflare),
    cnameStrategy: c.readOpt(obj["cnameStrategy"], (x => c.readEnum<"None" | "Follow" | c.UnexpectedEnumValue>(x))),
    digitalocean: c.readOpt(obj["digitalocean"], toChallenge_spec_solver_dns01_digitalocean),
    rfc2136: c.readOpt(obj["rfc2136"], toChallenge_spec_solver_dns01_rfc2136),
    route53: c.readOpt(obj["route53"], toChallenge_spec_solver_dns01_route53),
    webhook: c.readOpt(obj["webhook"], toChallenge_spec_solver_dns01_webhook),
  }}
export function toChallenge_spec_solver_http01(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    ingress: c.readOpt(obj["ingress"], toChallenge_spec_solver_http01_ingress),
  }}
export function toChallenge_spec_solver_selector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    dnsNames: c.readOpt(obj["dnsNames"], x => c.readList(x, c.checkStr)),
    dnsZones: c.readOpt(obj["dnsZones"], x => c.readList(x, c.checkStr)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_dns01_acmeDNS(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accountSecretRef: toChallenge_spec_solver_dns01_acmeDNS_accountSecretRef(obj["accountSecretRef"]),
    host: c.checkStr(obj["host"]),
  }}
export function toChallenge_spec_solver_dns01_akamai(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accessTokenSecretRef: toChallenge_spec_solver_dns01_akamai_accessTokenSecretRef(obj["accessTokenSecretRef"]),
    clientSecretSecretRef: toChallenge_spec_solver_dns01_akamai_clientSecretSecretRef(obj["clientSecretSecretRef"]),
    clientTokenSecretRef: toChallenge_spec_solver_dns01_akamai_clientTokenSecretRef(obj["clientTokenSecretRef"]),
    serviceConsumerDomain: c.checkStr(obj["serviceConsumerDomain"]),
  }}
export function toChallenge_spec_solver_dns01_azureDNS(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    clientID: c.readOpt(obj["clientID"], c.checkStr),
    clientSecretSecretRef: c.readOpt(obj["clientSecretSecretRef"], toChallenge_spec_solver_dns01_azureDNS_clientSecretSecretRef),
    environment: c.readOpt(obj["environment"], (x => c.readEnum<"AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud" | c.UnexpectedEnumValue>(x))),
    hostedZoneName: c.readOpt(obj["hostedZoneName"], c.checkStr),
    resourceGroupName: c.checkStr(obj["resourceGroupName"]),
    subscriptionID: c.checkStr(obj["subscriptionID"]),
    tenantID: c.readOpt(obj["tenantID"], c.checkStr),
  }}
export function toChallenge_spec_solver_dns01_cloudDNS(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    hostedZoneName: c.readOpt(obj["hostedZoneName"], c.checkStr),
    project: c.checkStr(obj["project"]),
    serviceAccountSecretRef: c.readOpt(obj["serviceAccountSecretRef"], toChallenge_spec_solver_dns01_cloudDNS_serviceAccountSecretRef),
  }}
export function toChallenge_spec_solver_dns01_cloudflare(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    apiKeySecretRef: c.readOpt(obj["apiKeySecretRef"], toChallenge_spec_solver_dns01_cloudflare_apiKeySecretRef),
    apiTokenSecretRef: c.readOpt(obj["apiTokenSecretRef"], toChallenge_spec_solver_dns01_cloudflare_apiTokenSecretRef),
    email: c.readOpt(obj["email"], c.checkStr),
  }}
export function toChallenge_spec_solver_dns01_digitalocean(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    tokenSecretRef: toChallenge_spec_solver_dns01_digitalocean_tokenSecretRef(obj["tokenSecretRef"]),
  }}
export function toChallenge_spec_solver_dns01_rfc2136(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nameserver: c.checkStr(obj["nameserver"]),
    tsigAlgorithm: c.readOpt(obj["tsigAlgorithm"], c.checkStr),
    tsigKeyName: c.readOpt(obj["tsigKeyName"], c.checkStr),
    tsigSecretSecretRef: c.readOpt(obj["tsigSecretSecretRef"], toChallenge_spec_solver_dns01_rfc2136_tsigSecretSecretRef),
  }}
export function toChallenge_spec_solver_dns01_route53(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    accessKeyID: c.readOpt(obj["accessKeyID"], c.checkStr),
    hostedZoneID: c.readOpt(obj["hostedZoneID"], c.checkStr),
    region: c.checkStr(obj["region"]),
    role: c.readOpt(obj["role"], c.checkStr),
    secretAccessKeySecretRef: c.readOpt(obj["secretAccessKeySecretRef"], toChallenge_spec_solver_dns01_route53_secretAccessKeySecretRef),
  }}
export function toChallenge_spec_solver_dns01_webhook(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    config: c.readOpt(obj["config"], c.identity),
    groupName: c.checkStr(obj["groupName"]),
    solverName: c.checkStr(obj["solverName"]),
  }}
export function toChallenge_spec_solver_http01_ingress(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    class: c.readOpt(obj["class"], c.checkStr),
    ingressTemplate: c.readOpt(obj["ingressTemplate"], toChallenge_spec_solver_http01_ingress_ingressTemplate),
    name: c.readOpt(obj["name"], c.checkStr),
    podTemplate: c.readOpt(obj["podTemplate"], toChallenge_spec_solver_http01_ingress_podTemplate),
    serviceType: c.readOpt(obj["serviceType"], c.checkStr),
  }}
export function toChallenge_spec_solver_dns01_acmeDNS_accountSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver_dns01_akamai_accessTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver_dns01_akamai_clientSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver_dns01_akamai_clientTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver_dns01_azureDNS_clientSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver_dns01_cloudDNS_serviceAccountSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver_dns01_cloudflare_apiKeySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver_dns01_cloudflare_apiTokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver_dns01_digitalocean_tokenSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver_dns01_rfc2136_tsigSecretSecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver_dns01_route53_secretAccessKeySecretRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.readOpt(obj["key"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toChallenge_spec_solver_http01_ingress_ingressTemplate(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], toChallenge_spec_solver_http01_ingress_ingressTemplate_metadata),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], toChallenge_spec_solver_http01_ingress_podTemplate_metadata),
    spec: c.readOpt(obj["spec"], toChallenge_spec_solver_http01_ingress_podTemplate_spec),
  }}
export function toChallenge_spec_solver_http01_ingress_ingressTemplate_metadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_metadata(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    annotations: c.readOpt(obj["annotations"], x => c.readMap(x, c.checkStr)),
    labels: c.readOpt(obj["labels"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    affinity: c.readOpt(obj["affinity"], toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity),
    nodeSelector: c.readOpt(obj["nodeSelector"], x => c.readMap(x, c.checkStr)),
    priorityClassName: c.readOpt(obj["priorityClassName"], c.checkStr),
    serviceAccountName: c.readOpt(obj["serviceAccountName"], c.checkStr),
    tolerations: c.readOpt(obj["tolerations"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_tolerations)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nodeAffinity: c.readOpt(obj["nodeAffinity"], toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity),
    podAffinity: c.readOpt(obj["podAffinity"], toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity),
    podAntiAffinity: c.readOpt(obj["podAntiAffinity"], toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_tolerations(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    effect: c.readOpt(obj["effect"], c.checkStr),
    key: c.readOpt(obj["key"], c.checkStr),
    operator: c.readOpt(obj["operator"], c.checkStr),
    tolerationSeconds: c.readOpt(obj["tolerationSeconds"], c.checkNum),
    value: c.readOpt(obj["value"], c.checkStr),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preferredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["preferredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution)),
    requiredDuringSchedulingIgnoredDuringExecution: c.readOpt(obj["requiredDuringSchedulingIgnoredDuringExecution"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    preference: toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference(obj["preference"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    nodeSelectorTerms: c.readList(obj["nodeSelectorTerms"], toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    podAffinityTerm: toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(obj["podAffinityTerm"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    podAffinityTerm: toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(obj["podAffinityTerm"]),
    weight: c.checkNum(obj["weight"]),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchExpressions)),
    matchFields: c.readOpt(obj["matchFields"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchFields)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchExpressions)),
    matchFields: c.readOpt(obj["matchFields"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchFields)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    labelSelector: c.readOpt(obj["labelSelector"], toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector),
    namespaces: c.readOpt(obj["namespaces"], x => c.readList(x, c.checkStr)),
    topologyKey: c.checkStr(obj["topologyKey"]),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_preferredDuringSchedulingIgnoredDuringExecution_preference_matchFields(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_nodeAffinity_requiredDuringSchedulingIgnoredDuringExecution_nodeSelectorTerms_matchFields(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    matchExpressions: c.readOpt(obj["matchExpressions"], x => c.readList(x, toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions)),
    matchLabels: c.readOpt(obj["matchLabels"], x => c.readMap(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_requiredDuringSchedulingIgnoredDuringExecution_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}
export function toChallenge_spec_solver_http01_ingress_podTemplate_spec_affinity_podAntiAffinity_preferredDuringSchedulingIgnoredDuringExecution_podAffinityTerm_labelSelector_matchExpressions(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    key: c.checkStr(obj["key"]),
    operator: c.checkStr(obj["operator"]),
    values: c.readOpt(obj["values"], x => c.readList(x, c.checkStr)),
  }}

export interface ChallengeList {
  apiVersion?: "acme.cert-manager.io/v1";
  kind?: "Challenge";
  items: Array<Challenge>;
  metadata?: MetaV1.ListMeta | null;
}
export function toChallengeList(input: c.JSONValue): ChallengeList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "acme.cert-manager.io/v1", "Challenge"),
    items: c.readList(obj["items"], toChallenge),
    metadata: c.readOpt(obj["metadata"], MetaV1.toListMeta),
  }}
export function fromChallengeList(input: ChallengeList): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "acme.cert-manager.io/v1", "Challenge"),
    ...input,
    items: input.items?.map(fromChallenge),
    metadata: input.metadata != null ? MetaV1.fromListMeta(input.metadata) : undefined,
  }}

/** Order is a type to represent an Order with an ACME server */
export interface Order {
  apiVersion?: "acme.cert-manager.io/v1";
  kind?: "Order";
  metadata: MetaV1.ObjectMeta;
  spec: {
    commonName?: string | null;
    dnsNames?: Array<string> | null;
    duration?: string | null;
    ipAddresses?: Array<string> | null;
    issuerRef: {
      group?: string | null;
      kind?: string | null;
      name: string;
    };
    request: string;
  };
  status?: {
    authorizations?: Array<{
      challenges?: Array<{
        token: string;
        type: string;
        url: string;
      }> | null;
      identifier?: string | null;
      initialState?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue | null;
      url: string;
      wildcard?: boolean | null;
    }> | null;
    certificate?: string | null;
    failureTime?: c.Time | null;
    finalizeURL?: string | null;
    reason?: string | null;
    state?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue | null;
    url?: string | null;
  } | null;
}
export function toOrder(input: c.JSONValue): Order & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "acme.cert-manager.io/v1", "Order"),
    metadata: MetaV1.toObjectMeta(obj["metadata"]),
    spec: toOrder_spec(obj["spec"]),
    status: c.readOpt(obj["status"], toOrder_status),
  }}
export function fromOrder(input: Order): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "acme.cert-manager.io/v1", "Order"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    status: input.status != null ? {
      ...input.status,
      failureTime: input.status.failureTime != null ? c.fromTime(input.status.failureTime) : undefined,
    } : undefined,
  }}
export function toOrder_spec(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    commonName: c.readOpt(obj["commonName"], c.checkStr),
    dnsNames: c.readOpt(obj["dnsNames"], x => c.readList(x, c.checkStr)),
    duration: c.readOpt(obj["duration"], c.checkStr),
    ipAddresses: c.readOpt(obj["ipAddresses"], x => c.readList(x, c.checkStr)),
    issuerRef: toOrder_spec_issuerRef(obj["issuerRef"]),
    request: c.checkStr(obj["request"]),
  }}
export function toOrder_status(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    authorizations: c.readOpt(obj["authorizations"], x => c.readList(x, toOrder_status_authorizations)),
    certificate: c.readOpt(obj["certificate"], c.checkStr),
    failureTime: c.readOpt(obj["failureTime"], c.toTime),
    finalizeURL: c.readOpt(obj["finalizeURL"], c.checkStr),
    reason: c.readOpt(obj["reason"], c.checkStr),
    state: c.readOpt(obj["state"], (x => c.readEnum<"valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue>(x))),
    url: c.readOpt(obj["url"], c.checkStr),
  }}
export function toOrder_spec_issuerRef(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    group: c.readOpt(obj["group"], c.checkStr),
    kind: c.readOpt(obj["kind"], c.checkStr),
    name: c.checkStr(obj["name"]),
  }}
export function toOrder_status_authorizations(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    challenges: c.readOpt(obj["challenges"], x => c.readList(x, toOrder_status_authorizations_challenges)),
    identifier: c.readOpt(obj["identifier"], c.checkStr),
    initialState: c.readOpt(obj["initialState"], (x => c.readEnum<"valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored" | c.UnexpectedEnumValue>(x))),
    url: c.checkStr(obj["url"]),
    wildcard: c.readOpt(obj["wildcard"], c.checkBool),
  }}
export function toOrder_status_authorizations_challenges(input: c.JSONValue) {
  const obj = c.checkObj(input);
  return {
    token: c.checkStr(obj["token"]),
    type: c.checkStr(obj["type"]),
    url: c.checkStr(obj["url"]),
  }}

export interface OrderList {
  apiVersion?: "acme.cert-manager.io/v1";
  kind?: "Order";
  items: Array<Order>;
  metadata?: MetaV1.ListMeta | null;
}
export function toOrderList(input: c.JSONValue): OrderList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "acme.cert-manager.io/v1", "Order"),
    items: c.readList(obj["items"], toOrder),
    metadata: c.readOpt(obj["metadata"], MetaV1.toListMeta),
  }}
export function fromOrderList(input: OrderList): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "acme.cert-manager.io/v1", "Order"),
    ...input,
    items: input.items?.map(fromOrder),
    metadata: input.metadata != null ? MetaV1.fromListMeta(input.metadata) : undefined,
  }}
