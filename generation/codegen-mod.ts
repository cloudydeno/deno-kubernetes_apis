import { SurfaceMap, SurfaceApi } from "./describe-surface.ts";

export function generateModuleTypescript(surface: SurfaceMap, api: SurfaceApi): string {
  const chunks = new Array<string>();
  chunks.push(`// Autogenerated API file for ${api.friendlyName}`);
  chunks.push(`import {RestClient} from "../../common.ts";`);
  chunks.push(`import * as ${api.friendlyName} from "./structs.ts";`);
  chunks.push('');
  const foreignApis = new Set<SurfaceApi>();

  const hasNamespaced = Array.from(api.kinds.values()).some(x => x.isNamespaced);

  chunks.push(`export class ${api.friendlyName}Api {`);
  chunks.push(`  #client: RestClient;`);
  chunks.push(`  #root = ${JSON.stringify(api.apiRoot)};`);
  chunks.push(`  constructor(client: RestClient) {`);
  chunks.push(`    this.#client = client;`);
  chunks.push(`  }\n`);

  if (hasNamespaced) {
    chunks.push(`  namespace(name: string) {`);
    chunks.push(`    return new ${api.friendlyName}NamespacedApi(this.#client, \`\${this.#root}/namespaces/\${name}\`);`);
    chunks.push(`  }\n`);
  }

  for (const op of api.operations) {
    if (op.scope === 'Namespaced') continue;
    chunks.push(`  async ${op.operationName}() {`);
    chunks.push(`    const query = new URLSearchParams;`);
    for (const param of op.parameters) {
      chunks.push(`    // TODO: ${param.in} ${param.name} ${param.required} ${param.type} ${JSON.stringify(param.schema)}`);
    }
    chunks.push(`    const resp = await this.#client.performRequest(${JSON.stringify(op.method)}, {`);
    chunks.push(`      path: this.#root + ${JSON.stringify(op.subPath)},`);
    chunks.push(`      accept: "application/json",`);
    chunks.push(`      querystring: query,`);
    chunks.push(`    });`);
    for (const [status, resp] of Object.entries(op.responses)) {
      if (!resp.schema?.$ref) continue;
      const shape = api.shapes.readSchema(resp.schema, null);
      if (shape.type === 'foreign') {
        foreignApis.add(shape.api);
        chunks.push(`    return ${shape.api.friendlyName}.to${shape.name}(resp);`);
      } else if (shape.reference) {
        chunks.push(`    return ${api.friendlyName}.to${shape.reference}(resp);`);
      } else {
        chunks.push(`    // TODO: ${status} ${resp.schema?.$ref} ${shape.type}`);
      }
      break;
    }
    chunks.push(`  }\n`);



// const blkJson = await restClient.performRequest("get", {
//   path: '/api/v1/pods',
//   accept: 'application/json',
//   querystring: new URLSearchParams([['limit', '1']])
// });
// const blkList = toPodList(blkJson);
// console.log(blkList);

  }

  chunks.push(`}\n`);

  if (hasNamespaced) {
    chunks.push(`export class ${api.friendlyName}NamespacedApi {`);
    chunks.push(`  #client: RestClient`);
    chunks.push(`  #root: string`);
    chunks.push(`  constructor(client: RestClient, apiRoot: string) {`);
    chunks.push(`    this.#client = client;`);
    chunks.push(`    this.#root = apiRoot;`);
    chunks.push(`  }\n`);

    for (const op of api.operations) {
      if (op.scope !== 'Namespaced') continue;
      chunks.push(`  // ${op.operationName} - ${op.method} ${op.subPath}`);
    }

    chunks.push(`}\n`);
  }

  chunks.push(`/*`);
  chunks.push(JSON.stringify(Array.from(api.kinds), null, 2));
  chunks.push(`*/`);

  for (const foreignApi of foreignApis) {
    chunks.splice(3, 0, `import * as ${foreignApi.friendlyName} from "../${foreignApi.moduleName}/structs.ts";`);
  }

  return chunks.join('\n');
}
