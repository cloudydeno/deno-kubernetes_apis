import { ApiDescription, describeApi } from "./describe-api.ts";
import { ApiShape } from "./describe-shapes.ts";
import { SurfaceMap, SurfaceApi } from "./describe-surface.ts";

export function generateStructsTypescript(surface: SurfaceMap, apiS: SurfaceApi): string {
  const chunks = new Array<string>();
  chunks.push(`// Autogenerated Schema file for ${apiS.friendlyName}`);

  const api = describeApi(surface, apiS);

  const apiVersion = api.apiRootParts.slice(1).join('/');

  if (api.apiName !== 'MetaV1') {
    chunks.push(`import * as MetaV1 from "../meta@v1/structs.ts";`);
    chunks.push(``);
    chunks.push(`type Kind<T extends string> = {`);
    chunks.push(`  apiVersion: "${apiVersion}";`);
    chunks.push(`  kind: T;`);
    chunks.push(`};`);
    chunks.push(`type ListOf<T> = {`);
    chunks.push(`  metadata: MetaV1.ListMeta;`);
    chunks.push(`  items: Array<T>;`);
    chunks.push(`};`);
  }
  chunks.push('');

  for (const [id, shape] of api.shapes.localShapes) {
    const name = id.split('.').slice(-1)[0];
    if (shape.description) {
      chunks.push(`/** ${shape.description} */`);
    }
    switch (shape.type) {

      case 'structure':

        const isKind = shape.kind
          && api.kinds.has(shape.kind.kind);
        const isKindList = shape.kind
          && shape.kind.kind.endsWith('List')
          && api.kinds.has(shape.kind.kind.slice(0, -4));

        if (isKind) {
          chunks.push(`export type ${name} = Kind<${JSON.stringify(shape.kind?.kind)}> & ${name}Fields;`);
          chunks.push(`export interface ${name}Fields {`);
          for (const [field, inner] of shape.fields) {
            if (['apiVersion', 'kind'].includes(field)) continue;
            chunks.push(`  ${field}${shape.required.includes(field) ? '' : '?'}: ${generateType(inner)};`);
          }
          chunks.push(`}`);

        } else if (isKindList) {
          chunks.push(`export type ${name} = Kind<${JSON.stringify(shape.kind?.kind)}> & ListOf<${name.slice(0, -4)}Fields>;`);
          // for (const [field, inner] of shape.fields) {
          //   if (['apiVersion', 'kind', 'items', 'metadata'].includes(field)) continue;
          //   chunks.push(`  ${field}${shape.required.includes(field) ? '' : '?'}: ${generateType(inner)};`);
          // }
          // chunks.push(`};`);

        } else {
          chunks.push(`export interface ${name} {`);
          for (const [field, inner] of shape.fields) {
            chunks.push(`  ${field}${shape.required.includes(field) ? '' : '?'}: ${generateType(inner)};`);
          }
          chunks.push(`}`);
        }
        // console.log(shape)
        break;

      case 'string':
        chunks.push(`export type ${name} = ${generateType(shape)}`);
        break;

      default:
        throw new Error(`TODO: generate struct type ${shape.type}`)

    }
    chunks.push(``);
  }

  function generateType(shape: ApiShape): string {
    if (shape.reference && shape.type === 'structure') {
      // console.log(shape.reference.startsWith(api.shapes.localApi));
      // console.log(shape.reference, Array.from(api.shapes.localShapes.keys()))
      // console.log(api.shapes.localShapes.has(shape.reference));
      if (api.shapes.localShapes.has(shape.reference)) {
        return shape.reference.split('.').slice(-1)[0];
      } else if (shape.reference.startsWith('io.k8s.apimachinery.pkg.apis.meta.v1.')) {
        return `MetaV1.${shape.reference.split('.').slice(-1)[0]}`;
      }
      return `unknown /* ${shape.type} ${shape.reference} */`;

    }

    switch (shape.type) {
      case 'structure': {
        const chunks = new Array<string>();
        chunks.push('{');
        for (const [field, inner] of shape.fields) {
          chunks.push(`  ${field}${shape.required.includes(field) ? '' : '?'}: ${generateType(inner)};`);
        }
        chunks.push('}');
        return chunks.join('\n').replace(/\n/g, '\n  ');
      }

      case 'list': {
        return `Array<${generateType(shape.inner)}>`;
      }

      case 'map': {
        return `Record<string,${generateType(shape.inner)}>`;
      }

      case 'string': {
        if (shape.format === 'date-time' || shape.reference === 'io.k8s.apimachinery.pkg.apis.meta.v1.Time') {
          return 'Date';
        } else if (shape.format === 'int-or-string') {
          return 'number | string';
        } else if (shape.enum) {
          return shape.enum.map(x => JSON.stringify(x)).join(' | ');
        } else {
          return 'string';
        }
      }

      case 'number':
        return 'number';
      case 'boolean':
        return `boolean`;

    }
    return `unknown /* ${shape.type} ${shape.reference} */`;
  }

  return chunks.join('\n');
}
