import { ApiDescription, describeApi } from "./describe-api.ts";
import { ApiShape } from "./describe-shapes.ts";
import { SurfaceMap, SurfaceApi } from "./describe-surface.ts";

export function generateStructsTypescript(surface: SurfaceMap, apiS: SurfaceApi): string {
  const chunks = new Array<string>();
  chunks.push(`// Autogenerated Schema file for ${apiS.friendlyName}`);
  chunks.push(`import * as c from "../../common.ts";`);

  for (const otherApi of apiS.shapes.referencedLibraries) {
    chunks.push(`import * as ${otherApi.friendlyName} from "../${otherApi.moduleName}/structs.ts";`);
  }

  const api = describeApi(surface, apiS);

  if (apiS.apiGroup === 'meta') {
    chunks.push(`
      export class MicroTime {
        constructor() {}
      }
      export function toMicroTime(raw: c.JSONValue): MicroTime {
        const str = c.checkStr(raw);
        throw new Error("TODO: toMicroTime for "+str);
      }
    `.replace(/\n      /g, '\n').trimEnd());
  } else {
    // chunks.push(`import * as MetaV1 from "../meta@v1/structs.ts";`);
    chunks.push(``);
    chunks.push(`type Kind<T extends string> = {`);
    chunks.push(`  apiVersion: "${apiS.apiGroupVersion}";`);
    chunks.push(`  kind: T;`);
    chunks.push(`};`);
    chunks.push(`type ListOf<T> = {`);
    chunks.push(`  metadata: MetaV1.ListMeta;`);
    chunks.push(`  items: Array<T>;`);
    chunks.push(`};`);
  }
  chunks.push('');

  for (const [name, shape] of apiS.shapes.shapes) {
    // const name = id.split('.').slice(-1)[0];
    if (shape.description) {
      chunks.push(`/** ${shape.description} */`);
    }
    switch (shape.type) {

      case 'structure':

        const isKind = shape.kind
          && api.kinds.has(shape.kind.kind);
        const isKindList = shape.kind
          && shape.kind.kind.endsWith('List')
          && api.kinds.has(shape.kind.kind.slice(0, -4));

        if (isKind) {
          chunks.push(`export type ${name} = Kind<${JSON.stringify(shape.kind?.kind)}> & ${name}Fields;`);
          chunks.push(`export interface ${name}Fields {`);
          for (const [field, inner] of shape.fields) {
            if (['apiVersion', 'kind'].includes(field)) continue;
            chunks.push(`  ${field}${shape.required.includes(field) ? '' : '?'}: ${generateType(inner)};`);
          }
          chunks.push(`}`);

        } else if (isKindList) {
          chunks.push(`export type ${name} = Kind<${JSON.stringify(shape.kind?.kind)}> & ListOf<${name.slice(0, -4)}Fields>;`);
          // for (const [field, inner] of shape.fields) {
          //   if (['apiVersion', 'kind', 'items', 'metadata'].includes(field)) continue;
          //   chunks.push(`  ${field}${shape.required.includes(field) ? '' : '?'}: ${generateType(inner)};`);
          // }
          // chunks.push(`};`);

        } else {
          chunks.push(`export interface ${name} {`);
          for (const [field, inner] of shape.fields) {
            const isReq = shape.required.includes(field);
            chunks.push(`  ${field}${isReq ? '' : '?'}: ${generateType(inner)}${isReq ? '' : ' | null'};`);
          }
          chunks.push(`}`);

          chunks.push(`export function to${name}(input: c.JSONValue): ${name} {`);
          chunks.push(`  if (input == null) throw new Error("Type structInitA");`);
          chunks.push(`  if (typeof input !== 'object') throw new Error("Type structInitB");`);
          chunks.push(`  if (Array.isArray(input)) throw new Error("Type structInitC");`);
          chunks.push(`  return {`);
          for (const [field, inner] of shape.fields) {
            const stack = generateReadStack(inner);
            if (!shape.required.includes(field)) {
              stack.unshift('c.readOpt');
            }
            chunks.push(`    ${field}: ${printReadStack(stack, `input[${JSON.stringify(field)}]`)},`);
          }
          chunks.push(`  }}`);

          // export function toAPIGroup(input: c.JSONValue): APIGroup {
          //   if (input == null) throw new Error(`Type structInitA`);
          //   if (typeof input !== 'object') throw new Error(`Type structInitB`);
          //   if (Array.isArray(input)) throw new Error(`Type structInitC`);
          //   return {
          //     apiVersion: c.opt(input['apiVersion'], c.readString),
          //     kind: c.opt(input['kind'], c.readString),
          //     name: c.readString(input.name),
          //     preferredVersion: c.opt(input['preferredVersion'], toGroupVersionForDiscovery),
          //     serverAddressByClientCIDRs: c.opt(input['serverAddressByClientCIDRs'], x => c.readList(x, toServerAddressByClientCIDR)),
          //     versions: c.readList(input['versions'], toGroupVersionForDiscovery),
          //   };
          // }
          // export function fromAPIGroup(input: APIGroup): c.JSONValue {
          //   return {
          //     apiVersion: input['apiVersion'],
          //     kind: input['kind'],
          //     name: input['name'],
          //     versions: [],
          //   };
          // }

        }
        // console.log(shape)
        break;

      case 'string':
        chunks.push(`export type ${name} = ${generateType(shape)};`);
        break;

      default:
        throw new Error(`TODO: generate struct type ${shape.type}`)

    }
    chunks.push(``);
  }

  function generateType(shape: ApiShape): string {
    if (shape.reference && shape.type === 'structure') {
    // if (shape.reference) {
      // console.log(shape.reference.startsWith(api.shapes.localApi));
      // console.log(shape.reference, Array.from(api.shapes.localShapes.keys()))
      // console.log(api.shapes.localShapes.has(shape.reference));
      return shape.reference;
      // if (api.shapes.shapes.has(shape.reference)) {
      //   return shape.reference.split('.').slice(-1)[0];
      // } else if (shape.reference.startsWith('io.k8s.apimachinery.pkg.apis.meta.v1.')) {
      //   return `MetaV1.${shape.reference.split('.').slice(-1)[0]}`;
      // }
      // return `unknown /* ${shape.type} ${shape.reference} */`;

    }

    switch (shape.type) {
      case 'structure': {
        const chunks = new Array<string>();
        chunks.push('{');
        for (const [field, inner] of shape.fields) {
          chunks.push(`  ${field}${shape.required.includes(field) ? '' : '?'}: ${generateType(inner)};`);
        }
        chunks.push('}');
        return chunks.join('\n').replace(/\n/g, '\n  ');
      }

      case 'list': {
        return `Array<${generateType(shape.inner)}>`;
      }

      case 'map': {
        return `Record<string,${generateType(shape.inner)}>`;
      }

      case 'foreign': {
        return `${shape.api.friendlyName}.${shape.name}`;
      }

      case 'string': {
        if (shape.format === 'date-time' || shape.reference === 'io.k8s.apimachinery.pkg.apis.meta.v1.Time') {
          return 'Date';
        } else if (shape.format === 'int-or-string') {
          return 'number | string';
        } else if (shape.enum) {
          return shape.enum.map(x => JSON.stringify(x)).join(' | ');
        } else {
          return 'string';
        }
      }

      case 'number':
        return 'number';
      case 'boolean':
        return `boolean`;

      case 'any': {
        if (shape.reference === 'quantity') {
          return 'c.Quantity';
        }
        break;
      }

    }
    return `unknown /* ${shape.type} ${shape.reference} */`;
  }

  function generateReadStack(shape: ApiShape): string[] {
    if (shape.reference && shape.type === 'structure') {
      return ['to'+shape.reference];
    }

    switch (shape.type) {
      // case 'structure': {
      //   const chunks = new Array<string>();
      //   chunks.push('{');
      //   for (const [field, inner] of shape.fields) {
      //     chunks.push(`  ${field}${shape.required.includes(field) ? '' : '?'}: ${generateType(inner)};`);
      //   }
      //   chunks.push('}');
      //   return chunks.join('\n').replace(/\n/g, '\n  ');
      // }

      case 'list': {
        return ['c.readList', ...generateReadStack(shape.inner)];
      }

      case 'map': {
        return ['c.readMap', ...generateReadStack(shape.inner)];
      }

      case 'foreign': {
        if (shape.api.apiGroup === 'meta' && shape.name === 'Time') {
          return ['c.readDate'];
        }
        return [`${shape.api.friendlyName}.to${shape.name}`];
      }

      case 'string': {
        if (shape.format === 'date-time'/* || shape.reference === 'io.k8s.apimachinery.pkg.apis.meta.v1.Time'*/) {
          return ['c.readDate'];
        // } else if (shape.format === 'int-or-string') {
        //   return ['number | string'];
        // } else if (shape.enum) {
        //   return [shape.enum.map(x => JSON.stringify(x)).join(' | ')];
        } else {
          return ['c.checkStr'];
        }
      }

      case 'number':
        return ['c.checkNum'];
      case 'boolean':
        return ['c.checkBool'];

      case 'any': {

        switch (shape.reference) {
          case 'unknown':
            return []; // no transform
          case 'quantity':
            return ['c.toQuantity'];
        }
        break;
      }

      case 'any':
    }
    return [`unknown /* ${shape.type} ${shape.reference} */`];
  }

  return chunks.join('\n');
}

function printReadStack(stack: string[], rootExpr: string): string {
  const top = stack.shift();
  if (!top) return rootExpr;
  let inner = stack.pop();
  if (!inner) return `${top}(${rootExpr})`;

  while (true) {
    const mid = stack.pop();
    if (!mid) break;
    inner = `x => ${mid}(x, ${inner})`;
  }
  return `${top}(${rootExpr}, ${inner})`;
}
