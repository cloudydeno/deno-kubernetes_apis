import { ApiShape, ForeignShape, SpecialShape, StructureShape } from "./describe-shapes.ts";
import { SurfaceMap, SurfaceApi } from "./describe-surface.ts";

type ExtraStructsList = Array<{name: string, struct: StructureShape}>;

function nameForeignWriteFunc(shape: ForeignShape | SpecialShape): string {
  if (shape.type === 'special' && shape.name === 'IntOrString') return '';
  const module = shape.type === 'special' ? 'c' : shape.api.friendlyName;
  return `${module}.from${shape.name}`;
}

function pushAll<T>(array: T[], items: T[]) {
  for (const item of items) {
    array.push(item);
  }
}

export function generateFromStruct(topShape: ApiShape, inputRef: string): string[] {
  const chunks = new Array<string>();
  chunks.push(`...${inputRef},`);

  if (topShape.type !== 'structure') throw new Error(`TODO`);
  for (const [name, shape] of topShape.fields) {
    const fieldRef = name.includes('-') ? `${inputRef}['${name}']` : `${inputRef}.${name}`;
    switch (shape.type) {
      case 'structure': {
        if (shape.reference) {
          chunks.push(`${maybeQuote(name)}: ${fieldRef} != null ? from${shape.reference}(${fieldRef}) : undefined,`);
        } else {
          const innerLines = generateFromStruct(shape, fieldRef);
          if (innerLines.length > 1) {
            chunks.push(`${maybeQuote(name)}: ${fieldRef} != null ? {`);
            pushAll(chunks, innerLines.map(x => `  ${x}`));
            chunks.push(`} : undefined,`);
          }
        }
        break;
      }
      case 'foreign':
      case 'special': {
        const readFunc = nameForeignWriteFunc(shape);
        if (readFunc) {
          chunks.push(`${maybeQuote(name)}: ${fieldRef} != null ? ${readFunc}(${fieldRef}) : undefined,`);
        }
        break;
      }
      case 'list': {
        switch (shape.inner.type) {
          case 'structure': {
            if (shape.inner.reference) {
              chunks.push(`${maybeQuote(name)}: ${fieldRef}?.map(from${shape.inner.reference}),`);
            } else {
              const innerLines = generateFromStruct(shape.inner, 'x');
              if (innerLines.length > 1) {
                chunks.push(`${maybeQuote(name)}: ${fieldRef}?.map(x => ({`);
                pushAll(chunks, innerLines.map(x => `  ${x}`));
                chunks.push(`})),`);
              }
            }
            break;
          }
          case 'foreign':
          case 'special': {
            const readFunc = nameForeignWriteFunc(shape.inner);
            if (readFunc) {
              chunks.push(`${maybeQuote(name)}: ${fieldRef}?.map(${readFunc}),`);
            }
            break;
          }
        }
        break;
      }
      case 'map': {
        switch (shape.inner.type) {
          case 'structure': {
            if (shape.inner.reference) {
              chunks.push(`${maybeQuote(name)}: c.writeMap(${fieldRef}, from${shape.inner.reference}),`);
            } else {
              const innerLines = generateFromStruct(shape.inner, 'x');
              if (innerLines.length > 1) {
                chunks.push(`${maybeQuote(name)}: c.writeMap(${fieldRef}, x => ({`);
                pushAll(chunks, innerLines.map(x => `  ${x}`));
                chunks.push(`})),`);
              }
            }
            break;
          }
          case 'foreign':
          case 'special': {
            const readFunc = nameForeignWriteFunc(shape.inner);
            if (readFunc) {
              chunks.push(`${maybeQuote(name)}: c.writeMap(${fieldRef}, ${readFunc}),`);
            }
            break;
          }
        }
        break;
      }
    }
  }

  return chunks;
}

export function generateStructsTypescript(surface: SurfaceMap, apiS: SurfaceApi): string {
  const chunks = new Array<string>();
  chunks.push(`// Autogenerated Schema file for ${apiS.friendlyName}`);
  chunks.push(`import * as c from "../../common.ts";`);
  chunks.push(``);

  const foreignApis = new Set<SurfaceApi>();
  if (apiS.apiGroup !== 'meta') {
    foreignApis.add(surface.allApis.find(x => x.friendlyName === 'MetaV1')!);

    chunks.push(`type ListOf<T> = {`);
    chunks.push(`  metadata: MetaV1.ListMeta;`);
    chunks.push(`  items: Array<T>;`);
    chunks.push(`};`);
    chunks.push('');
  }

  for (const [name, shape] of apiS.shapes.shapes) {
    if (shape.description) {
      chunks.push(`/** ${shape.description} */`);
    }
    switch (shape.type) {

      case 'structure':

        const isKind = shape.kind
          && apiS.kinds.has(shape.kind.kind);
        const isKindList = shape.kind
          && shape.kind.kind.endsWith('List')
          && apiS.kinds.has(shape.kind.kind.slice(0, -4));

        const extraStructs = new Array<{name: string, struct: StructureShape}>();

        if (isKind) {
          chunks.push(`export interface ${name} {`);
          chunks.push(`  apiVersion?: ${JSON.stringify(apiS.apiGroupVersion)};`);
          chunks.push(`  kind?: ${JSON.stringify(shape.kind?.kind)};`);

          for (const [field, inner] of shape.fields) {
            if (['apiVersion', 'kind'].includes(field)) continue;
            const isReq = shape.required.includes(field);
            chunks.push(`  ${maybeQuote(field)}${isReq ? '' : '?'}: ${generateType(inner)}${isReq ? '' : ' | null'};`);
          }
          chunks.push(`}`);

          chunks.push(`export function to${name}(input: c.JSONValue): ${name} & c.ApiKind {`);
          chunks.push(`  const obj = c.checkObj(input);`);
          chunks.push(`  return {`);
          chunks.push(`    ...c.assertOrAddApiVersionAndKind(obj, ${JSON.stringify(apiS.apiGroupVersion)}, ${JSON.stringify(shape.kind?.kind)}),`);
          for (const [field, inner] of shape.fields) {
            if (['apiVersion', 'kind'].includes(field)) continue;
            const stack = generateReadStack(inner, `${name}_${field}`, extraStructs);
            if (!shape.required.includes(field)) {
              stack.unshift('c.readOpt');
            }
            chunks.push(`    ${maybeQuote(field)}: ${printReadStack(stack, `obj[${JSON.stringify(field)}]`)},`);
          }
          chunks.push(`  }}`);

          chunks.push(`export function from${name}(input: ${name}): c.JSONValue {`);
          chunks.push(`  return {`);
          chunks.push(`    ...c.assertOrAddApiVersionAndKind(input, ${JSON.stringify(apiS.apiGroupVersion)}, ${JSON.stringify(shape.kind?.kind)}),`);
          chunks.push(...generateFromStruct(shape, 'input').map(x => `    ${x}`));
          chunks.push(`  }}`);


        } else if (isKindList && apiS.apiGroup !== 'meta') {
          chunks.push(`export interface ${name} extends ListOf<${name.slice(0, -4)}> {`);
          chunks.push(`  apiVersion?: ${JSON.stringify(apiS.apiGroupVersion)};`);
          chunks.push(`  kind?: ${JSON.stringify(shape.kind?.kind)};`);
          chunks.push(`};`);

          chunks.push(`export function to${name}(input: c.JSONValue): ${name} & c.ApiKind {`);
          chunks.push(`  const obj = c.checkObj(input);`);
          chunks.push(`  return {`);
          chunks.push(`    ...c.assertOrAddApiVersionAndKind(obj, ${JSON.stringify(apiS.apiGroupVersion)}, ${JSON.stringify(shape.kind?.kind)}),`);
          chunks.push(`    metadata: MetaV1.toListMeta(obj.metadata),`);
          chunks.push(`    items: c.readList(obj.items, to${name.slice(0, -4)}),`);
          chunks.push(`  }}`);

        } else if (isKindList) {
          chunks.push(`export interface ${name} {`);
          chunks.push(`  apiVersion?: ${JSON.stringify(apiS.apiGroupVersion)};`);
          chunks.push(`  kind?: ${JSON.stringify(shape.kind?.kind)};`);
          for (const [field, inner] of shape.fields) {
            if (['apiVersion', 'kind'].includes(field)) continue;
            const isReq = shape.required.includes(field);
            chunks.push(`  ${maybeQuote(field)}${isReq ? '' : '?'}: ${generateType(inner)}${isReq ? '' : ' | null'};`);
          }
          chunks.push(`};`);

          chunks.push(`export function to${name}(input: c.JSONValue): ${name} & c.ApiKind {`);
          chunks.push(`  const obj = c.checkObj(input);`);
          chunks.push(`  return {`);
          chunks.push(`    ...c.assertOrAddApiVersionAndKind(obj, ${JSON.stringify(apiS.apiGroupVersion)}, ${JSON.stringify(shape.kind?.kind)}),`);
          for (const [field, inner] of shape.fields) {
            if (['apiVersion', 'kind'].includes(field)) continue;
            const stack = generateReadStack(inner, `${name}_${field}`, extraStructs);
            if (!shape.required.includes(field)) {
              stack.unshift('c.readOpt');
            }
            chunks.push(`    ${maybeQuote(field)}: ${printReadStack(stack, `obj[${JSON.stringify(field)}]`)},`);
          }
          chunks.push(`  }}`);

          chunks.push(`export function from${name}(input: ${name}): c.JSONValue {`);
          chunks.push(`  return {`);
          chunks.push(...generateFromStruct(shape, 'input').map(x => `    ${x}`));
          chunks.push(`  }}`);


        } else {
          chunks.push(`export interface ${name} {`);
          for (const [field, inner] of shape.fields) {
            const isReq = shape.required.includes(field);
            chunks.push(`  ${maybeQuote(field)}${isReq ? '' : '?'}: ${generateType(inner)}${isReq ? '' : ' | null'};`);
          }
          chunks.push(`}`);

          chunks.push(`export function to${name}(input: c.JSONValue): ${name} {`);
          chunks.push(`  const obj = c.checkObj(input);`);
          chunks.push(`  return {`);
          for (const [field, inner] of shape.fields) {
            const stack = generateReadStack(inner, `${name}_${field}`, extraStructs);
            if (!shape.required.includes(field)) {
              stack.unshift('c.readOpt');
            }
            chunks.push(`    ${maybeQuote(field)}: ${printReadStack(stack, `obj[${JSON.stringify(field)}]`)},`);
          }
          chunks.push(`  }}`);

          chunks.push(`export function from${name}(input: ${name}): c.JSONValue {`);
          chunks.push(`  return {`);
          chunks.push(...generateFromStruct(shape, 'input').map(x => `    ${x}`));
          chunks.push(`  }}`);
        }

        while (true) {
          const extraStruct = extraStructs.shift();
          if (!extraStruct) break;

          chunks.push(`function to${extraStruct.name}(input: c.JSONValue) {`);
          chunks.push(`  const obj = c.checkObj(input);`);
          chunks.push(`  return {`);
          for (const [field, inner] of extraStruct.struct.fields) {
            const stack = generateReadStack(inner, `${extraStruct.name}_${field}`, extraStructs);
            if (!extraStruct.struct.required.includes(field)) {
              stack.unshift('c.readOpt');
            }
            chunks.push(`    ${maybeQuote(field)}: ${printReadStack(stack, `obj[${JSON.stringify(field)}]`)},`);
          }
          chunks.push(`  }}`);
        }

        break;

      case 'string':
        chunks.push(`export type ${name} = ${generateType(shape)};`);
        break;

      case 'any':
        chunks.push(`export type ${name} = c.JSONValue;`);
        break;

      default:
        chunks.push(`export type ${name} = unknown; // TODO!`);
        // throw new Error(`TODO: generate struct type ${shape.type}`);

    }
    chunks.push(``);
  }

  for (const foreignApi of foreignApis) {
    chunks.splice(3, 0, `import * as ${foreignApi.friendlyName} from "../${foreignApi.moduleName}/structs.ts";`);
  }

  return chunks.join('\n');

  function generateType(shape: ApiShape): string {
    if (shape.reference && shape.type === 'structure') {
      return shape.reference;
    }

    switch (shape.type) {
      case 'structure': {
        const chunks = new Array<string>();
        chunks.push('{');
        for (const [field, inner] of shape.fields) {
          const isReq = shape.required.includes(field);
          chunks.push(`  ${maybeQuote(field)}${isReq ? '' : '?'}: ${generateType(inner)}${isReq ? '' : ' | null'};`);
        }
        chunks.push('}');
        return chunks.join('\n').replace(/\n/g, '\n  ');
      }

      case 'list': {
        return `Array<${generateType(shape.inner)}>`;
      }

      case 'map': {
        return `Record<string,${generateType(shape.inner)}>`;
      }

      case 'foreign': {
        foreignApis.add(shape.api);
        return `${shape.api.friendlyName}.${shape.name}`;
      }

      case 'string': {
        if (shape.enum) {
          return shape.enum.map(x => JSON.stringify(x)).concat('c.UnexpectedEnumValue').join(' | ');
        } else {
          return 'string';
        }
      }

      case 'number':
        return 'number';
      case 'boolean':
        return `boolean`;

      case 'special':
        return `c.${shape.name}`;

      case 'any': {
        if (shape.reference === 'unknown') {
          return 'c.JSONValue';
        } else if (shape.reference) {
          return shape.reference;
        }
        break;
      }

    }
    return `unknown /* ${shape.type} ${shape.reference} */`;
  }

  function generateReadStack(shape: ApiShape, curName: string, extraStructs: ExtraStructsList): string[] {
    if (shape.reference && shape.type === 'structure') {
      return ['to'+shape.reference];
    }

    switch (shape.type) {
      case 'structure': {
        extraStructs.push({name: curName, struct: shape});
        return [`to${curName}`];
      }

      case 'list': {
        return ['c.readList', ...generateReadStack(shape.inner, curName, extraStructs)];
      }

      case 'map': {
        return ['c.readMap', ...generateReadStack(shape.inner, curName, extraStructs)];
      }

      case 'foreign': {
        return [`${shape.api.friendlyName}.to${shape.name}`];
      }

      case 'special': {
        return [`c.to${shape.name}`];
      }

      case 'string': {
        if (shape.enum) {
          return ['(x => c.readEnum<'+shape.enum.map(x => JSON.stringify(x)).concat('c.UnexpectedEnumValue').join(' | ')+'>(x))'];
        } else {
          return ['c.checkStr'];
        }
      }

      case 'number':
        return ['c.checkNum'];
      case 'boolean':
        return ['c.checkBool'];

      case 'any': {
        return ['c.identity'];

      }
    }
    return [`unknown /* BUG: found unknown shape.type */`];
  }

}

const letters = 'xyzabc';
function printReadStack(stack: string[], rootExpr: string): string {
  const top = stack.shift();
  if (!top) return rootExpr;
  let inner = stack.pop();
  if (!inner) return `${top}(${rootExpr})`;

  let idx = 0;
  while (true) {
    const mid = stack.pop();
    if (!mid) break;
    const x = letters[idx++];
    inner = `${x} => ${mid}(${x}, ${inner})`;
  }
  return `${top}(${rootExpr}, ${inner})`;
}

function maybeQuote(field: string) {
  if (field.includes('-')) return `'${field}'`;
  return field;
}
